---
title: Think-in-Java学习笔记一：一切都是对象
date: 2016-12-31 10:11:37
tags: notes
categories: Think in Java
---

Think-in-Java学习开篇，马上新的一年就要到来了，回顾了一下2016年的整体过程，从毕业到工作半年，浑浑噩噩过一阵，断断续续学习过一阵，慢慢的由于工作压缩的自己的学习的时间，对学习上的事情也就兴趣下降了不少，直到遇到了某个一个基友，感觉自己还是差别太大，因此想重新迈上提升自己的道路，想要去学习更多的东西拓宽自己的深度与广度，Think-in-Java以前看了一点就废弃掉了，现在重新拾起，进行学习，即刻做起，算是提前一天对2017年做个java层面上的一个平行目标吧。

------



Java一切皆为对象，操作的标识符实际上是对对象的一个引用(reference)。你拥有一个引用并不需要有一个对象与他相关联，如直接申明一个String变量：

```java
String s;
```

这时候s变量是没有跟任何对象相关联的，只是简单的一个引用而已，如果想要跟一个对象进行相关联，则需要new关键字的申明：

```java
String a=new String("aaa");
```
<!--more-->

<h3>存储位置</h3>

五个地方进行数据的存储：

1. 寄存器：最快的存储区，因为它位于不同其他的存储区的地方——处理其内部。
2. 堆栈：位于通用RAM中，可以通过堆栈指针从处理器获得直接支持。堆栈指针乡下则会分配新的内存；向上移动，则会释放掉内存，效率仅次于寄存器。创建程序时，JAVA必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针，**对象的引用即存在堆栈当中，而Java对象不存储在其中**。
3. 堆：一个通用内存池(位于RAM)，**用于存放所有的Java对象**。堆不同于堆栈的好处在于编译器不需要知道内存的数据在堆中存活多长时间，当我们需要一个对象的时候，只需要new一个即可，堆中会自动进行存储分配。因此，在堆中内存的分配拥有很大的灵活性，but，当前灵活性付出的代价就是用堆进行存储分配和清理时可能比栈中进行存储分配花费更多的时间。
4. 常量存储：常量值通常直接存放在程序代码内部，这么做是安全的，因为他们永远不会被改变。
5. 非RAM存储：如果数据完全存活在程序之外，那么它不受程序控制，在程序没运行时候也会存在，基本例子就是流对象和持久化对象，对象存放于磁盘当中。这种存储方式的技巧在于把对象转化成可以存放在其他媒介的事务上。在需要时可以恢复成常规的基于RAM的对象。

**深入(深入理解Java虚拟机)：**

Java虚拟机在执行Java程序的过程会把他所管理的内存划分为若干个不同的数据区域：

**程序计数器**

- 程序计数器是一块较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器，其工作时就是通过改变这个计数器的值来选取下一条执行的字节码指令，分支，循环，跳转，异常处理，县城回复等基础功能都需要依赖其完成。
- 由于Java虚拟机的多线程是通过线程轮流切换并且分配处理器执行时间的方式来实现的，在任何一个确定的时间，一个处理器都只会执行一条线程中的指令，因此为了线程切换后能够恢复到正确的位置，每条线程都需要有一个程序计数器，各个线程之间的计数器互不影响(Android中的ThreadLocal类似？)，独立存储，这类内存区域称为“县城私有”的内存
- 如果线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果是Native方法，则计数器为空

**Java虚拟机栈**

- 和程序计数器一样，堆栈为线程私有，生命周期与线程相同，其描述的为内存模型：每一个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法调用的过程，就对应一个栈帧在虚拟机中入栈出栈的过程。
- **堆栈其实明确而言指的是虚拟机栈中的局部变量表部分**，其存放了编译器可知的各种基本类型，对象引用类型，它不同于对象本身，可能是指向一个对象起始地址的引用指针，可能指向一条字节码指令的地址。
- 堆栈所需要的内存空间在编译期间完成分配，当进入一个方法时候，其所需要的在帧重分配的局部变量空间是完全确定的，方法运行时是不会改变的。

**本地方法栈**

- 本地方法栈与虚拟机栈类似，区别在于本地方法栈执行Native方法，而虚拟机栈执行Java方法

**Java堆**

- Java为线程共享的一块内存区域，在虚拟机启动时创建，堆的作用就是存放对象实例，几乎所有的对象实例都存放在堆中，在Java堆中可以详细分为：新生代和老年代。

**方法区**

- 方法区也是线程共享的内存区域，永存存储已被虚拟机加载的类信息，常量，静态变量等，我们可能成为其为“永久代”，GC的过程在这区域是很少出现的，这个区域的回收目标在于针对常量池中回收的类型的卸载。
- 运行时常量池：是方法区中的一部分，Class文件中除了有类的本班，字段，方法，接口等描述信息外，还有常量池信息，用于存放编译器生成的各个字面量和符号引用，这个部分内容会在类加载后进入方法区的运行时常量池存放。



<h3>基本类型</h3>

程序中的基本类型不用"new"来进行堆内存的分配，而是采用跟C++相同的方式，即创建一个并非引用的“自动”变量，这个变量直接存储“值”，并放在堆栈当中，更加高效。

|  基本类型   |   大小   |   最小值    |      最大值      |   包装器类型   |
| :-----: | :----: | :------: | :-----------: | :-------: |
| boolean |   ——   |    ——    |      ——       |  Boolean  |
|  char   | 16bits | Unicode0 | Unicode2x16-1 | Character |
|  byte   | 8bits  |   -128   |     +127      |   Byte    |
|  short  | 16bits |  -2x15   |    +2x15-1    |   Short   |
|   int   | 32bits |  -2x31   |    +2x31-1    |  Integer  |
|  long   | 64bits |  -2x63   |    +2x63-     |   Long    |
|  float  | 32bits | IEEE754  |    IEEE754    |   Float   |
| double  | 64bits | IEEE754  |    IEEE754    |  Double   |
|  void   |   ——   |    ——    |      ——       |   Void    |
|         |        |          |               |           |

<h3>static关键字</h3>

使用static关键字的情形：

- 只想为特定域分配单一存储空间，而不去考虑究竟想要创建多少对象，甚至根本就不创建任何对象
- 希望某个方法不与包含他的类的任何对象关联在一起，即没创建对象也能对用此方法

当一个事物申明为static时候，就意味着这个域或者方法不会与他的类的任何一个对象实例关联在一起，所以即使从未创建过某各类的任何对象，也可以调用static方法或者访问他的域。