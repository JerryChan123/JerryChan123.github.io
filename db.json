{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/wechatPay.png","path":"images/wechatPay.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.DS_Store","hash":"bab67ef528493e0b65403dc5417e577edbf6dabe","modified":1481595365000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1481595222000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1481595222000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1481595222000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1481595222000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1481595222000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1481595222000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1481595222000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1481595222000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1481595222000},{"_id":"themes/next/_config.yml","hash":"293d3889595b2f0c67c3923b9720e9f88318e1a3","modified":1481599441000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1481595222000},{"_id":"source/.DS_Store","hash":"e317814f3690d816e82722fab99eb30908cae47e","modified":1481601150000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1481595222000},{"_id":"source/_posts/Picasso源码分析.md","hash":"7002f57b6f276fa945c56c090759446cf0fd7afa","modified":1481597013000},{"_id":"source/_posts/android-View的探索-一-setContentView-过程研究.md","hash":"a67276e8ebce4fa2e24ab86734de2329a27180d1","modified":1481596856000},{"_id":"source/_posts/.DS_Store","hash":"be77714dda23409f15b14001c40c1c5277c228be","modified":1481601150000},{"_id":"source/_posts/android-View的探索-二-View的形成过程.md","hash":"6ee18a1d07c5e6d67fddcb7f7b8a9cc61dc6597a","modified":1481596919000},{"_id":"source/_posts/volley源码学习.md","hash":"8a3d5b4b8aaf8b774c7bc0f33ca7371206fb6a5f","modified":1481596959000},{"_id":"source/about/index.md","hash":"ebaef39cb38a07a20525b231bcf2a63ee20369b5","modified":1481601158000},{"_id":"source/categories/.DS_Store","hash":"a7e12e0a972e4aad60c4eeb34a8bf6bd94f7a943","modified":1481597735000},{"_id":"source/categories/index.md","hash":"ae07c45e5eb7a031416735f2adcb83b641eb319a","modified":1481594819000},{"_id":"source/images/.DS_Store","hash":"37a9d1e2e8d1b46c36e3843d580ebdca4d743b6a","modified":1481597727000},{"_id":"source/images/avatar.jpg","hash":"430e34fb52567ec662f7e3b4444b16617cb10767","modified":1481594819000},{"_id":"source/tags/.DS_Store","hash":"f06f7c62f8ffe3018707e20c454ef1758a432653","modified":1481598233000},{"_id":"source/tags/index.md","hash":"bd547aeaa5a6602a9e08972e15ad27cf966cf0b1","modified":1481594819000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1481595222000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1481595222000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1481595208000},{"_id":"themes/next/.git/index","hash":"897f997fb7375f527e7c885f14a943a7d8028a71","modified":1481600421000},{"_id":"themes/next/.git/packed-refs","hash":"80908fda4226cdf164a41c85c7fbea49cb816125","modified":1481595222000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1481595222000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1481595222000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1481595222000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1481595222000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1481595222000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1481595222000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1481595222000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1481595222000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1481595222000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1481595222000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1481595222000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1481595222000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1481595222000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1481595222000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1481595222000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1481595222000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1481595222000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1481595222000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1481595222000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1481595222000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1481595222000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1481595222000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1481595222000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1481595222000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1481595222000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1481595222000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1481595222000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"source/_posts/android-View的探索-一-setContentView-过程研究/.DS_Store","hash":"09e902839006071568f4d12b9e465e8941ff8d2d","modified":1481596846000},{"_id":"source/_posts/android-View的探索-一-setContentView-过程研究/setcontentView.png","hash":"ea900ae1d2f438dd65fc65483de52231daec060e","modified":1481594819000},{"_id":"source/_posts/android-View的探索-二-View的形成过程/.DS_Store","hash":"133adcb0ac730d3d6781e8f207cb843e5a9e549d","modified":1481596906000},{"_id":"source/_posts/android-View的探索-二-View的形成过程/one.png","hash":"df9c760a9e2df3fb7aa99bfbd7aed9fc38a31e63","modified":1481594819000},{"_id":"source/_posts/android-View的探索-二-View的形成过程/two.jpg","hash":"4a42b3b47f62e1c6e4713ff995ce5ab0e0a09b65","modified":1481594819000},{"_id":"source/_posts/volley源码学习/.DS_Store","hash":"a06b6f56dc1d79119455f6ae9f80b6866b6ff3ff","modified":1481596955000},{"_id":"source/_posts/volley源码学习/reuqestqueue_add.png","hash":"944e17c3b85a19b8d51ec7e6b77ff0b5fcf8a3f0","modified":1481594819000},{"_id":"source/_posts/volley源码学习/volley_flowchart.png","hash":"0586d04c44fbd151fd1abdbd3b5c03e71adaf2a5","modified":1481594819000},{"_id":"source/images/wechatPay.png","hash":"eadf0b0c21253d6963e46446daa3fa4f825d5964","modified":1481594819000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1481595208000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1481595208000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1481595208000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1481595208000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1481595208000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1481595208000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1481595208000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1481595208000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1481595208000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1481595208000},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1481595208000},{"_id":"themes/next/.git/logs/HEAD","hash":"5441559104e8bef51e1919bc80a21dff5275b1c6","modified":1481595222000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1481595222000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1481595222000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1481595222000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f12f108c1f8e91cc55d49805d42c1fd96cdf51a6","modified":1481595222000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1481595222000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1481595222000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b8aaa008aafe4c6e325f7513719e1c251430883e","modified":1481595222000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a3ef28678467c45ee9416b41b943252e8036285","modified":1481595222000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1481595222000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1481595222000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1481595222000},{"_id":"themes/next/layout/_partials/header.swig","hash":"f3627f51810bc906e4020a3fef61bc3629b63581","modified":1481595222000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1481595222000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1481595222000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1481595222000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1481595222000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1481595222000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1481595222000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1481595222000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1481595222000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1481595222000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1481595222000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1481595222000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1481595222000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1481595222000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1481595222000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1481595222000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1481595222000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1481595222000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1481595222000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1481595222000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1481595222000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1481595222000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1481595222000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1481595222000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1481595222000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1481595222000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1481595222000},{"_id":"source/_posts/volley源码学习/CacheDispatcher_run.png","hash":"a1be7b2f6e463c9f3aa68aa58d2c3617b563a248","modified":1481594819000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481595222000},{"_id":"themes/next/.git/refs/heads/master","hash":"93d0f27eb58dcc033accd3711a6d88c269c8e1e8","modified":1481595222000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1481595222000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1481595222000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1481595222000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1481595222000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1481595222000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1481595222000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1481595222000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1481595222000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1481595222000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1481595222000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1481595222000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1481595222000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"82a2ac14d4200480a36bf10abcc3cc554ad744d6","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1481595222000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1481595222000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1481595222000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1481595222000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1481595222000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c5b28519b446c2af1e8754a6ae4d766823e6b348","modified":1481595222000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f0d6aa424f434e82ea507f740eeff110f996269","modified":1481595222000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1481595222000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1481595222000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1481595222000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1481595222000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1481595222000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1481595222000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1481595222000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1481595222000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1481595222000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1481595222000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1481595222000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1481595222000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1481595222000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1481595222000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1481595222000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1481595222000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1481595222000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1481595222000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1481595222000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1481595222000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1481595222000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1481595222000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1481595222000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1481595222000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1481595222000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1481595222000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"5441559104e8bef51e1919bc80a21dff5275b1c6","modified":1481595222000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1481595222000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1481595222000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1481595222000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1481595222000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1481595222000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1481595222000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1481595222000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1481595222000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1481595222000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1481595222000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1481595222000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1481595222000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1481595222000},{"_id":"themes/next/.git/objects/pack/pack-21e21d2af8dd47b297c2ceb52008d403d7556bd0.idx","hash":"bc6f6cbc3feffc28d277bf5df5367e40bf45665e","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1481595222000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1481595222000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"5441559104e8bef51e1919bc80a21dff5275b1c6","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5433b6bc9d8f0c4685e760b326445ac51245b0a8","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1481595222000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1481595222000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1481595222000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1481595222000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1481595222000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1481595222000},{"_id":"themes/next/.git/objects/pack/pack-21e21d2af8dd47b297c2ceb52008d403d7556bd0.pack","hash":"8b9f39194da4e6c2eb627becc9e0e15a5219cf98","modified":1481595222000}],"Category":[{"name":"Android开源库源码分析","_id":"ciwmz2w8j0004dgs6iuukjbt9"},{"name":"Android源码研究","_id":"ciwmz2w8r0009dgs6fd3fmt99"}],"Data":[],"Page":[{"title":"about","date":"2016-12-13T03:52:38.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-12-13 11:52:38\n---\n","updated":"2016-12-13T03:52:38.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciwmz2w8g0001dgs6fbknp9q7","content":"","excerpt":"","more":""},{"title":"分类集","type":"categories","date":"2016-12-09T07:36:48.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类集\ntype: \"categories\"\ndate: 2016-12-09 15:36:48\n---\n","updated":"2016-12-13T02:06:59.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ciwmz2w8i0003dgs6quppc5xw","content":"","excerpt":"","more":""},{"title":"Tagcloud","date":"2016-12-09T07:34:44.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2016-12-09 15:34:44\ntype: \"tags\"\n---\n","updated":"2016-12-13T02:06:59.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciwmz2w8n0007dgs6qdt485e3","content":"","excerpt":"","more":""}],"Post":[{"title":"Picasso源码分析","date":"2016-12-12T09:25:20.000Z","_content":"\n\n在Android中基本山所有的app都会涉及到网路图片的加载的需求，在Github上也有各式各样的开源的图片加载框架，从最初的UniversalImageLoader到现在的Gilde，Picasso和Fresco，对于图片加载框架的设计也趋于完善，现在主流也就是Gilde，Picasso和Fresco这个三个核心的框架了，那么这篇文章的目的就是从源码的角度来探究Picasso实现的过程。（本身适合了解基本api的童鞋阅读）\n\n<!---more-->\n\n----\n\n<h3>基本使用</h3>\n\n关于Picasso的基本的使用该方法如下所示：\n\n```java\nPicasso.with(context).load(url).into(imageView);\n```\n\n就只需要一句话就能够轻松将图片设置到你的ImageView当中，如果你有更多丰富的需求，诸如失败图片的正在加载图片的设置，只需要一句话，因为Picasso的图片展示基于Builder设计模式，我们可以任意添加所需要的功能，统统一句话：\n\n```java\npicasso.with(this).load(url).config(Bitmap.Config.ARGB_8888).error(R.mipmap.ic_launcher).into(img);  \n```\n\n用法非常简单，更多用法请仔细阅读api，本文的核心是对于源码的探究，下面我们基于picasso.with(context)为初始入口进行源码层级的阅读分析\n\n\n\n----\n\n<h3>源码分析</h3>\n\n<h4>picasso.with(context)</h4>\n\nwith()方法的代码如下所示：\n\n```java\npublic static Picasso with(Context context) {\n    if (singleton == null) {\n      synchronized (Picasso.class) {\n        if (singleton == null) {\n          singleton = new Builder(context).build();\n        }\n      }\n    }\n    return singleton;\n  }\n\npublic Picasso build() {\n      Context context = this.context;\n\t  //初始化图片下载的loader\n      if (downloader == null) {\n        downloader = Utils.createDefaultDownloader(context);\n      }\n  \t  //缓存初始化\n      if (cache == null) {\n        cache = new LruCache(context);\n      }\n  \t  //初始化线程池\n      if (service == null) {\n        service = new PicassoExecutorService();\n      }\n  \t  //初始化一个请求转换器\n      if (transformer == null) {\n        transformer = RequestTransformer.IDENTITY;\n      }\n\t  //缓存统计\n      Stats stats = new Stats(cache);\n\t  //调度器\n      Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);\n\n      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,\n          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);\n    }\n  }\n```\n\n使用单例模式构造一个Picasso实现—singleton，初始化一个Builder，这个Builder的作用就是串联所有使用者设置的参数,并且调用其build()方法，在build的方法中做了一系列的初始化的操作：\n\n1. 下载的loader的初始化\n2. 图片缓存初始化\n3. 线程池初始化\n4. 请求转换器的初始化\n5. 缓存统计类的初始化\n6. 调度器的初始化\n\n这些一些凭名字可以看出作用，诸如下载loader和图片缓存的，其他的只能一步步探究其作用，暂且搁置，后面遇到了我们再分析，接下来就到了Picasso的构造方法中了：\n\n```java\nPicasso.java \nPicasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,\n      RequestTransformer requestTransformer, List<RequestHandler> extraRequestHandlers, Stats stats,\n      Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) {\n    this.context = context;\n    this.dispatcher = dispatcher;\n    this.cache = cache;\n    this.listener = listener;\n    this.requestTransformer = requestTransformer;\n    this.defaultBitmapConfig = defaultBitmapConfig;\n\n    int builtInHandlers = 7; // Adjust this as internal handlers are added or removed.\n    int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0);\n    List<RequestHandler> allRequestHandlers =\n        new ArrayList<RequestHandler>(builtInHandlers + extraCount);\n\n    //添加各种加载不同图片地址的handler，如网络中的，resoure中的，相册，conteneprovider....\n    allRequestHandlers.add(new ResourceRequestHandler(context));\n\n    if (extraRequestHandlers != null) {\n      allRequestHandlers.addAll(extraRequestHandlers);\n    }\n   \t//\n    allRequestHandlers.add(new ContactsPhotoRequestHandler(context));\n    allRequestHandlers.add(new MediaStoreRequestHandler(context));\n    allRequestHandlers.add(new ContentStreamRequestHandler(context));\n    allRequestHandlers.add(new AssetRequestHandler(context));\n    allRequestHandlers.add(new FileRequestHandler(context));\n    allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));\n    requestHandlers = Collections.unmodifiableList(allRequestHandlers);\n\n    this.stats = stats;\n    this.targetToAction = new WeakHashMap<Object, Action>();\n    this.targetToDeferredRequestCreator = new WeakHashMap<ImageView, DeferredRequestCreator>();\n    this.indicatorsEnabled = indicatorsEnabled;\n    this.loggingEnabled = loggingEnabled;\n    this.referenceQueue = new ReferenceQueue<Object>();\n   \t//初始化一个清除request的Thread\n    this.cleanupThread = new CleanupThread(referenceQueue, HANDLER);\n    this.cleanupThread.start();\n  }\n```\n\nPicasso的构造函数中从Buidler中获取到使用者设置的额外参数设置添加到配置当中，并且赋值给各个变量。在allRequestHandlers维护着所有可能获取到图片的路径，包括网上获取，Drawable文件获取，Asset文件中的获取等等的取图方式，最后初始化一个清除request的Thread。在构造函数中初始化的内容是这些，接下来，我们在查看一下load()方法，我们挑选load(uri)即加载网络图片的来进行源码的探究：\n\n```java\nPicasso.java\npublic RequestCreator load(Uri uri) {\n    return new RequestCreator(this, uri, 0);\n  }\n```\n\nload(uri)的方法非常简单，即返回一个RequestCreator()，这个RequestCreator是所有load(...)方法的返回参数，我们得查看一下这个类的作用:\n\n```java\nRequestCreator.java \nRequestCreator(Picasso picasso, Uri uri, int resourceId) {\n    if (picasso.shutdown) {\n      throw new IllegalStateException(\n          \"Picasso instance already shut down. Cannot submit new requests.\");\n    }\n    this.picasso = picasso;\n    //初始化Reques类\n    this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);\n  }\npublic RequestCreator error(int errorResId){...}\npublic RequestCreator placeholder(int placeholderResId) {...}\npublic RequestCreator fit() {...}\npublic RequestCreator resize(int targetWidth, int targetHeight){...}\npublic RequestCreator centerInside(){...}\npublic RequestCreator clearCenterCrop(){...}\n....\n```\n\n熟悉API的朋友就知道这些方法的具体作用，那么RequestCreator的作用在于在给target设置图片之前，读取用户一切对于目标target的操作，如：error图片的设置，加载过程中图片的设置，设置图片宽高等等，相当于一个预处理类的作用，然后把所有的参传递给Request。所以我们可以在调用into()方法之前将我们所有的要求设置到RequestCreator(Builder设计模式)。\n\n我们再看构造方法中初始化了一个Request.Builder()，进入源码中查看：\n\n```java\nRequest.java\n  Builder(Uri uri, int resourceId, Bitmap.Config bitmapConfig) {\n      this.uri = uri;\n      this.resourceId = resourceId;\n      this.config = bitmapConfig;\n    }\n\n```\n\nRequest.Builder所做的操作就是接收从RequestCreator传递过来参数\n\n\n\ninto()方法\n\n```java\nRequestCreator.java\npublic void into(ImageView target, Callback callback) {\n    long started = System.nanoTime();\n  \t//是否为主线程\n    checkMain();\n\n    if (target == null) {\n      throw new IllegalArgumentException(\"Target must not be null.\");\n    }\n\t//是否有图片资源，如果rui为空或者ResId为空，则取消request\n  \t//uri != null || resourceId != 0\n    if (!data.hasImage()) {\n      picasso.cancelRequest(target);\n      //显示默认图片\n      if (setPlaceholder) {\n        setPlaceholder(target, getPlaceholderDrawable());\n      }\n      return;\n    }\n\t//deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高\n  \t//掉用过这个方法后不能再调用resize()操作\n    if (deferred) {\n      if (data.hasSize()) {\n        throw new IllegalStateException(\"Fit cannot be used with resize.\");\n      }\n      int width = target.getWidth();\n      int height = target.getHeight();\n      if (width == 0 || height == 0) {\n        if (setPlaceholder) {\n          setPlaceholder(target, getPlaceholderDrawable());\n        }\n        picasso.defer(target, new DeferredRequestCreator(this, target, callback));\n        return;\n      }\n      //设置图片宽高\n      data.resize(width, height);\n    }\n\t//新建request\n    Request request = createRequest(started);\n  \t//新建requestKey，即得到一个唯一标识request的key\n    String requestKey = createKey(request);\n\t//是否从缓存中读取\n    if (shouldReadFromMemoryCache(memoryPolicy)) {\n      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);\n      //得到缓存中的图片并且取消请求\n      if (bitmap != null) {\n        picasso.cancelRequest(target);\n        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);\n        if (picasso.loggingEnabled) {\n          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY);\n        }\n        //回调接口\n        if (callback != null) {\n          callback.onSuccess();\n        }\n        return;\n      }\n    }\n\n    if (setPlaceholder) {\n      setPlaceholder(target, getPlaceholderDrawable());\n    }\n\t//构造一个图片请求的动作\n    Action action =\n        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,\n            errorDrawable, requestKey, tag, callback, noFade);\n\t//添加到请求队列当中\n    picasso.enqueueAndSubmit(action);\n  }\n```\n\n在into()方法中主要的执行过程有如下几个步骤：\n\n- 检查运行的线程是否为主线程，如果不是抛异常，结束\n- 检查传入的uri或者resid等是否有图片资源，如果rui为空或者ResId为空，则取消request，结束\n- 检查deferred参数，deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高，调用过这个方法后不能再调用resize()操作。\n- 新建Request，判断是是否拥有缓存，如果有则直接获取并且取消请求，调用setBitMap()为target设置图片，结束\n- 如果没有缓存，则会构造一个Action来处理请求，然后添加至线程池当中\n\n**小提示：**\n\n在其中 createRequest(long started)方法中，会有一个请求转换的过程，这个过程一句使用者是否使用而决定，for  example:如果使用者在其中某一个ImageView的展示中想使用一个baseUrl不同的地址，那么我们就可以实现RequestTransformer接口，并且重写transformRequest(request)来自主构建Request实例。\n\n\n\n```java\nPiscasso.java\nvoid enqueueAndSubmit(Action action) {\n    Object target = action.getTarget();\n    if (target != null && targetToAction.get(target) != action) {\n      // This will also check we are on the main thread.\n      cancelExistingRequest(target);\n      targetToAction.put(target, action);\n    }\n    submit(action);\n  }\n\n  void submit(Action action) {\n    dispatcher.dispatchSubmit(action);\n  }\n```\n\n跟踪enqueueAndSubmit()最终调用到Dispatcher类当中，Dispatcher类所有的action操作(submit,cancel,pause.etc)，相关对应的逻辑处理完后会使用BitmapHunter来获取图片，BitmapHunter会最终回调Dispatcher的图片或是否成功的相关方法。\n\n简单看下Dispatcher的构造函数：\n\nDispatcher.java\n\n```java\nDispatcher.java\nDispatcher(Context context, ExecutorService service, Handler mainThreadHandler,\n      Downloader downloader, Cache cache, Stats stats) {\n    this.dispatcherThread = new DispatcherThread();\n    this.dispatcherThread.start();\n    Utils.flushStackLocalLeaks(dispatcherThread.getLooper());\n    this.context = context;\n    this.service = service;\n  \t//hunter的映射\n    this.hunterMap = new LinkedHashMap<String, BitmapHunter>();\n  \t//失败Action的映射\n    this.failedActions = new WeakHashMap<Object, Action>();\n  \t//暂停Action的映射\n    this.pausedActions = new WeakHashMap<Object, Action>();\n    this.pausedTags = new HashSet<Object>();\n  \t//DispatcherHandler初始化\n    this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);\n  \t//下载类\n    this.downloader = downloader;\n    this.mainThreadHandler = mainThreadHandler;\n    this.cache = cache;\n    this.stats = stats;\n    this.batch = new ArrayList<BitmapHunter>(4);\n    this.airplaneMode = Utils.isAirplaneModeOn(this.context);\n    this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);\n    this.receiver = new NetworkBroadcastReceiver(this);\n    receiver.register();\n  }\n\nvoid dispatchSubmit(Action action) {\n    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));\n  }\n\n private static class DispatcherHandler extends Handler {\n    private final Dispatcher dispatcher;\n\n    public DispatcherHandler(Looper looper, Dispatcher dispatcher) {\n      super(looper);\n      this.dispatcher = dispatcher;\n    }\n\n    @Override public void handleMessage(final Message msg) {\n      switch (msg.what) {\n        case REQUEST_SUBMIT: {\n          Action action = (Action) msg.obj;\n          dispatcher.performSubmit(action);\n          break;\n        }\n        case REQUEST_CANCEL: {\n          Action action = (Action) msg.obj;\n          dispatcher.performCancel(action);\n          break;\n        }\n        case TAG_PAUSE: {\n          Object tag = msg.obj;\n          dispatcher.performPauseTag(tag);\n          break;\n        }\n        case TAG_RESUME: {\n          Object tag = msg.obj;\n          dispatcher.performResumeTag(tag);\n          break;\n        }\n        case HUNTER_COMPLETE: {\n          BitmapHunter hunter = (BitmapHunter) msg.obj;\n          dispatcher.performComplete(hunter);\n          break;\n        }\n        case HUNTER_RETRY: {\n          BitmapHunter hunter = (BitmapHunter) msg.obj;\n          dispatcher.performRetry(hunter);\n          break;\n        }\n        case HUNTER_DECODE_FAILED: {\n          BitmapHunter hunter = (BitmapHunter) msg.obj;\n          dispatcher.performError(hunter, false);\n          break;\n        }\n        case HUNTER_DELAY_NEXT_BATCH: {\n          dispatcher.performBatchComplete();\n          break;\n        }\n        case NETWORK_STATE_CHANGE: {\n          NetworkInfo info = (NetworkInfo) msg.obj;\n          dispatcher.performNetworkStateChange(info);\n          break;\n        }\n        case AIRPLANE_MODE_CHANGE: {\n          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON);\n          break;\n        }\n        default:\n          Picasso.HANDLER.post(new Runnable() {\n            @Override public void run() {\n              throw new AssertionError(\"Unknown handler message received: \" + msg.what);\n            }\n          });\n      }\n    }\n  }\n```\n\n在初始化方法中，核心就是DispatcherHandler初始化，DispatcherHandler负责将消息进行传递调用diapatcher相应的方法，以Msg=REQUEST_SUBMIT为例，那么就会调用dispatcher.performSubmit(action)，dispatcher.performSubmit(action)方法如下所示：\n\n```java\nDispatcher.java\nvoid performSubmit(Action action, boolean dismissFailed) {\n  \t//暂停标识\n    if (pausedTags.contains(action.getTag())) {\n      pausedActions.put(action.getTarget(), action);\n      if (action.getPicasso().loggingEnabled) {\n        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),\n            \"because tag '\" + action.getTag() + \"' is paused\");\n      }\n      return;\n    }\n\t\n    BitmapHunter hunter = hunterMap.get(action.getKey());\n    if (hunter != null) {\n      hunter.attach(action);\n      return;\n    }\n\n    if (service.isShutdown()) {\n      if (action.getPicasso().loggingEnabled) {\n        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\");\n      }\n      return;\n    }\n\n    hunter = forRequest(action.getPicasso(), this, cache, stats, action);\n    hunter.future = service.submit(hunter);\n    hunterMap.put(action.getKey(), hunter);\n    if (dismissFailed) {\n      failedActions.remove(action.getTarget());\n    }\n\n    if (action.getPicasso().loggingEnabled) {\n      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());\n    }\n  }\n```\n\n这个方法的逻辑如下:\n\n1. 暂停的tags中是否包含当前action的tag，有的话则return，否则继续下一步\n2. hunterMap中是否已经包含了相同的hunter，如果有则attach()到hunter中，return；否则继续下一步\n3. 线程池是否shutDown，有则return，没有继续下一步\n4. 通过forRequest()方法获得一个request，并且添加到线程池service中\n\n\n在forRequest()方法中主要获取对应的RequestHandler处理类，这里类似于责任链的设计模式，通过依次传递request给各个handler来找到对应的匹配的RequestHandler。\n\nBitmapHunter是主要的图片处理类，在BitmapHunter中会判断是从网络中还是缓存中获取图片,由于BitmapHunter本身是线程类，且无论从缓存中取数据还是从网络中取数据都是耗时操作，所以才引申除了线程池service这个类来进行执行runnable，查看下代码：\n\n```java\nBitmapHunter.java\nstatic BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,\n      Action action) {\n    Request request = action.getRequest();\n    List<RequestHandler> requestHandlers = picasso.getRequestHandlers();\n\n    // Index-based loop to avoid allocating an iterator.\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0, count = requestHandlers.size(); i < count; i++) {\n      RequestHandler requestHandler = requestHandlers.get(i);\n      if (requestHandler.canHandleRequest(request)) {\n        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);\n      }\n    }\n\n    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);\n  }\n....\n  @Override public void run() {\n    try {\n      //更新县城名字\n      updateThreadName(data);\n      //核心方法\n      result = hunt();\n\n      if (result == null) {\n        dispatcher.dispatchFailed(this);\n      } else {\n        dispatcher.dispatchComplete(this);\n      }\n      //各种异常的捕获处理\n    } catch (Downloader.ResponseException e) {\n      if (!e.localCacheOnly || e.responseCode != 504) {\n        exception = e;\n      }\n      dispatcher.dispatchFailed(this);\n    } catch (NetworkRequestHandler.ContentLengthException e) {\n      exception = e;\n      dispatcher.dispatchRetry(this);\n    } catch (IOException e) {\n      exception = e;\n      dispatcher.dispatchRetry(this);\n    } catch (OutOfMemoryError e) {\n      StringWriter writer = new StringWriter();\n      stats.createSnapshot().dump(new PrintWriter(writer));\n      exception = new RuntimeException(writer.toString(), e);\n      dispatcher.dispatchFailed(this);\n    } catch (Exception e) {\n      exception = e;\n      dispatcher.dispatchFailed(this);\n    } finally {\n      Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);\n    }\n  }\n```\n\nBitmapHunter.run()方法中主要通过调用hunt()方法获取到Bitmap，此时会对result进行判断的操作，如果为空则回调dispatcher.dispatchFailed()，不为空则调用dispatcher.dispatchComplete()方法，并且捕获异常，根据相关的异常来对应回调到dispatcher不同的方法中。\n\nBitmapHunter.hunt()方法详解：\n\n```java\nBitmap hunt() throws IOException {\n    Bitmap bitmap = null;\n\t//是否从缓存读取\n    if (shouldReadFromMemoryCache(memoryPolicy)) {\n      bitmap = cache.get(key);\n      if (bitmap != null) {\n        stats.dispatchCacheHit();\n        loadedFrom = MEMORY;\n        if (picasso.loggingEnabled) {\n          log(OWNER_HUNTER, VERB_DECODED, data.logId(), \"from cache\");\n        }\n        return bitmap;\n      }\n    }\n\t//网络读取\n    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;\n    RequestHandler.Result result = requestHandler.load(data, networkPolicy);\n    if (result != null) {\n      loadedFrom = result.getLoadedFrom();\n      exifRotation = result.getExifOrientation();\n\n      bitmap = result.getBitmap();\n\n      // If there was no Bitmap then we need to decode it from the stream.\n      if (bitmap == null) {\n        InputStream is = result.getStream();\n        try {\n          bitmap = decodeStream(is, data);\n        } finally {\n          Utils.closeQuietly(is);\n        }\n      }\n    }\n\n    if (bitmap != null) {\n      if (picasso.loggingEnabled) {\n        log(OWNER_HUNTER, VERB_DECODED, data.logId());\n      }\n      stats.dispatchBitmapDecoded(bitmap);\n      if (data.needsTransformation() || exifRotation != 0) {\n        synchronized (DECODE_LOCK) {\n          if (data.needsMatrixTransform() || exifRotation != 0) {\n            bitmap = transformResult(data, bitmap, exifRotation);\n            if (picasso.loggingEnabled) {\n              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());\n            }\n          }\n          if (data.hasCustomTransformations()) {\n            bitmap = applyCustomTransformations(data.transformations, bitmap);\n            if (picasso.loggingEnabled) {\n              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), \"from custom transformations\");\n            }\n          }\n        }\n        if (bitmap != null) {\n          stats.dispatchBitmapTransformed(bitmap);\n        }\n      }\n    }\n\n    return bitmap;\n  }\n```\n\nhunt()方法过程如下：\n\n1. 从缓存里面找到对应的图片，有则返回，没有则玩下走；\n\n2. 将Request交付给对应的RequestHandler.load()来获取到图片，并且判断是否需要加工(needsTransformation\n\n   ()),需要则转换图片后再返回Bitmap\n\n回到BitmapHunter.createRequest()，最终过程都会调用到dispatcher.dispatchComplete(this)和dispatcher.dispatchFailed(this)，而这两个方法会调用到dispatcher.performBatchComplete()中。\n\n附：\n\n- dispatcher.dispatchRetry(this)：主要对requset进行重新请求操作，会再次执行一次获取图片的过程\n- dispatcher.dispatchComplete(this)：最终调用performBatchComplete()对主线程发送一个承载着List<BitmapHunter>的msg\n- dispatcher.dispatchFailed(this)：最终调用performBatchComplete()对主线程发送一个承载着List<BitmapHunter>的msg\n\n在其中又会将HUNTER_BATCH_COMPLETE这个msg发送给主线程的handler，即在Picasso.java中初始化的HANDLER:\n\n```java\nDispatcher.java\nvoid performBatchComplete() {\n    List<BitmapHunter> copy = new ArrayList<BitmapHunter>(batch);\n    batch.clear();\n    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));\n    logBatch(copy);\n  }\nvoid performError(BitmapHunter hunter, boolean willReplay) {\n    if (hunter.getPicasso().loggingEnabled) {\n      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter),\n          \"for error\" + (willReplay ? \" (will replay)\" : \"\"));\n    }\n    hunterMap.remove(hunter.getKey());\n    batch(hunter);\n  }\n\n\nPicasso.java\nstatic final Handler HANDLER = new Handler(Looper.getMainLooper()) {\n    @Override public void handleMessage(Message msg) {\n      switch (msg.what) {\n        case HUNTER_BATCH_COMPLETE: {\n          @SuppressWarnings(\"unchecked\") List<BitmapHunter> batch = (List<BitmapHunter>) msg.obj;\n          //noinspection ForLoopReplaceableByForEach\n          for (int i = 0, n = batch.size(); i < n; i++) {\n            BitmapHunter hunter = batch.get(i);\n            hunter.picasso.complete(hunter);\n          }\n          break;\n        }\n        case REQUEST_GCED: {\n          Action action = (Action) msg.obj;\n          if (action.getPicasso().loggingEnabled) {\n            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), \"target got garbage collected\");\n          }\n          action.picasso.cancelExistingRequest(action.getTarget());\n          break;\n        }\n        case REQUEST_BATCH_RESUME:\n          @SuppressWarnings(\"unchecked\") List<Action> batch = (List<Action>) msg.obj;\n          //noinspection ForLoopReplaceableByForEach\n          for (int i = 0, n = batch.size(); i < n; i++) {\n            Action action = batch.get(i);\n            action.picasso.resumeAction(action);\n          }\n          break;\n        default:\n          throw new AssertionError(\"Unknown handler message received: \" + msg.what);\n      }\n    }\n  };\n```\n\n\n\nhunter.picasso.complete(hunter)方法：\n\n```java\nPicasso.java \nvoid complete(BitmapHunter hunter) {\n    Action single = hunter.getAction();\n    List<Action> joined = hunter.getActions();\n\n    boolean hasMultiple = joined != null && !joined.isEmpty();\n    boolean shouldDeliver = single != null || hasMultiple;\n\n    if (!shouldDeliver) {\n      return;\n    }\n\n    Uri uri = hunter.getData().uri;\n    Exception exception = hunter.getException();\n    Bitmap result = hunter.getResult();\n    LoadedFrom from = hunter.getLoadedFrom();\n\n    if (single != null) {\n      deliverAction(result, from, single);\n    }\n\n    if (hasMultiple) {\n      //noinspection ForLoopReplaceableByForEach\n      for (int i = 0, n = joined.size(); i < n; i++) {\n        Action join = joined.get(i);\n        deliverAction(result, from, join);\n      }\n    }\n\n    if (listener != null && exception != null) {\n      listener.onImageLoadFailed(this, uri, exception);\n    }\n  }\n\nprivate void deliverAction(Bitmap result, LoadedFrom from, Action action) {\n    if (action.isCancelled()) {\n      return;\n    }\n    if (!action.willReplay()) {\n      targetToAction.remove(action.getTarget());\n    }\n    if (result != null) {\n      if (from == null) {\n        throw new AssertionError(\"LoadedFrom cannot be null.\");\n      }\n      action.complete(result, from);\n      if (loggingEnabled) {\n        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), \"from \" + from);\n      }\n    } else {\n      action.error();\n      if (loggingEnabled) {\n        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());\n      }\n    }\n  }\n```\n\ncomplete()方法中最终会调用action.complete(result, from)和action.error()来传递给对应的Action实现类，在这里我们选择的是ImageAction来查看对应方法\n\n```java\n@Override public void complete(Bitmap result, Picasso.LoadedFrom from) {\n    if (result == null) {\n      throw new AssertionError(\n          String.format(\"Attempted to complete action with no result!\\n%s\", this));\n    }\n\n    ImageView target = this.target.get();\n    if (target == null) {\n      return;\n    }\n\n    Context context = picasso.context;\n    boolean indicatorsEnabled = picasso.indicatorsEnabled;\n  \t//设置图片\n    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);\n\n    if (callback != null) {\n      callback.onSuccess();\n    }\n  }\n\n  @Override public void error() {\n    ImageView target = this.target.get();\n    if (target == null) {\n      return;\n    }\n    //设置错误图片\n    if (errorResId != 0) {\n      target.setImageResource(errorResId);\n    } else if (errorDrawable != null) {\n      target.setImageDrawable(errorDrawable);\n    }\n\n    if (callback != null) {\n      callback.onError();\n    }\n  }\n```\n\n到这里，基本上也结束了，对应的图片也展示到了Target中，基本的流程也就完成了","source":"_posts/Picasso源码分析.md","raw":"---\ntitle: Picasso源码分析\ndate: 2016-12-12 17:25:20\ncategories: \n- Android开源库源码分析\ntags: \n- android\n---\n\n\n在Android中基本山所有的app都会涉及到网路图片的加载的需求，在Github上也有各式各样的开源的图片加载框架，从最初的UniversalImageLoader到现在的Gilde，Picasso和Fresco，对于图片加载框架的设计也趋于完善，现在主流也就是Gilde，Picasso和Fresco这个三个核心的框架了，那么这篇文章的目的就是从源码的角度来探究Picasso实现的过程。（本身适合了解基本api的童鞋阅读）\n\n<!---more-->\n\n----\n\n<h3>基本使用</h3>\n\n关于Picasso的基本的使用该方法如下所示：\n\n```java\nPicasso.with(context).load(url).into(imageView);\n```\n\n就只需要一句话就能够轻松将图片设置到你的ImageView当中，如果你有更多丰富的需求，诸如失败图片的正在加载图片的设置，只需要一句话，因为Picasso的图片展示基于Builder设计模式，我们可以任意添加所需要的功能，统统一句话：\n\n```java\npicasso.with(this).load(url).config(Bitmap.Config.ARGB_8888).error(R.mipmap.ic_launcher).into(img);  \n```\n\n用法非常简单，更多用法请仔细阅读api，本文的核心是对于源码的探究，下面我们基于picasso.with(context)为初始入口进行源码层级的阅读分析\n\n\n\n----\n\n<h3>源码分析</h3>\n\n<h4>picasso.with(context)</h4>\n\nwith()方法的代码如下所示：\n\n```java\npublic static Picasso with(Context context) {\n    if (singleton == null) {\n      synchronized (Picasso.class) {\n        if (singleton == null) {\n          singleton = new Builder(context).build();\n        }\n      }\n    }\n    return singleton;\n  }\n\npublic Picasso build() {\n      Context context = this.context;\n\t  //初始化图片下载的loader\n      if (downloader == null) {\n        downloader = Utils.createDefaultDownloader(context);\n      }\n  \t  //缓存初始化\n      if (cache == null) {\n        cache = new LruCache(context);\n      }\n  \t  //初始化线程池\n      if (service == null) {\n        service = new PicassoExecutorService();\n      }\n  \t  //初始化一个请求转换器\n      if (transformer == null) {\n        transformer = RequestTransformer.IDENTITY;\n      }\n\t  //缓存统计\n      Stats stats = new Stats(cache);\n\t  //调度器\n      Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);\n\n      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,\n          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);\n    }\n  }\n```\n\n使用单例模式构造一个Picasso实现—singleton，初始化一个Builder，这个Builder的作用就是串联所有使用者设置的参数,并且调用其build()方法，在build的方法中做了一系列的初始化的操作：\n\n1. 下载的loader的初始化\n2. 图片缓存初始化\n3. 线程池初始化\n4. 请求转换器的初始化\n5. 缓存统计类的初始化\n6. 调度器的初始化\n\n这些一些凭名字可以看出作用，诸如下载loader和图片缓存的，其他的只能一步步探究其作用，暂且搁置，后面遇到了我们再分析，接下来就到了Picasso的构造方法中了：\n\n```java\nPicasso.java \nPicasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,\n      RequestTransformer requestTransformer, List<RequestHandler> extraRequestHandlers, Stats stats,\n      Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) {\n    this.context = context;\n    this.dispatcher = dispatcher;\n    this.cache = cache;\n    this.listener = listener;\n    this.requestTransformer = requestTransformer;\n    this.defaultBitmapConfig = defaultBitmapConfig;\n\n    int builtInHandlers = 7; // Adjust this as internal handlers are added or removed.\n    int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0);\n    List<RequestHandler> allRequestHandlers =\n        new ArrayList<RequestHandler>(builtInHandlers + extraCount);\n\n    //添加各种加载不同图片地址的handler，如网络中的，resoure中的，相册，conteneprovider....\n    allRequestHandlers.add(new ResourceRequestHandler(context));\n\n    if (extraRequestHandlers != null) {\n      allRequestHandlers.addAll(extraRequestHandlers);\n    }\n   \t//\n    allRequestHandlers.add(new ContactsPhotoRequestHandler(context));\n    allRequestHandlers.add(new MediaStoreRequestHandler(context));\n    allRequestHandlers.add(new ContentStreamRequestHandler(context));\n    allRequestHandlers.add(new AssetRequestHandler(context));\n    allRequestHandlers.add(new FileRequestHandler(context));\n    allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));\n    requestHandlers = Collections.unmodifiableList(allRequestHandlers);\n\n    this.stats = stats;\n    this.targetToAction = new WeakHashMap<Object, Action>();\n    this.targetToDeferredRequestCreator = new WeakHashMap<ImageView, DeferredRequestCreator>();\n    this.indicatorsEnabled = indicatorsEnabled;\n    this.loggingEnabled = loggingEnabled;\n    this.referenceQueue = new ReferenceQueue<Object>();\n   \t//初始化一个清除request的Thread\n    this.cleanupThread = new CleanupThread(referenceQueue, HANDLER);\n    this.cleanupThread.start();\n  }\n```\n\nPicasso的构造函数中从Buidler中获取到使用者设置的额外参数设置添加到配置当中，并且赋值给各个变量。在allRequestHandlers维护着所有可能获取到图片的路径，包括网上获取，Drawable文件获取，Asset文件中的获取等等的取图方式，最后初始化一个清除request的Thread。在构造函数中初始化的内容是这些，接下来，我们在查看一下load()方法，我们挑选load(uri)即加载网络图片的来进行源码的探究：\n\n```java\nPicasso.java\npublic RequestCreator load(Uri uri) {\n    return new RequestCreator(this, uri, 0);\n  }\n```\n\nload(uri)的方法非常简单，即返回一个RequestCreator()，这个RequestCreator是所有load(...)方法的返回参数，我们得查看一下这个类的作用:\n\n```java\nRequestCreator.java \nRequestCreator(Picasso picasso, Uri uri, int resourceId) {\n    if (picasso.shutdown) {\n      throw new IllegalStateException(\n          \"Picasso instance already shut down. Cannot submit new requests.\");\n    }\n    this.picasso = picasso;\n    //初始化Reques类\n    this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);\n  }\npublic RequestCreator error(int errorResId){...}\npublic RequestCreator placeholder(int placeholderResId) {...}\npublic RequestCreator fit() {...}\npublic RequestCreator resize(int targetWidth, int targetHeight){...}\npublic RequestCreator centerInside(){...}\npublic RequestCreator clearCenterCrop(){...}\n....\n```\n\n熟悉API的朋友就知道这些方法的具体作用，那么RequestCreator的作用在于在给target设置图片之前，读取用户一切对于目标target的操作，如：error图片的设置，加载过程中图片的设置，设置图片宽高等等，相当于一个预处理类的作用，然后把所有的参传递给Request。所以我们可以在调用into()方法之前将我们所有的要求设置到RequestCreator(Builder设计模式)。\n\n我们再看构造方法中初始化了一个Request.Builder()，进入源码中查看：\n\n```java\nRequest.java\n  Builder(Uri uri, int resourceId, Bitmap.Config bitmapConfig) {\n      this.uri = uri;\n      this.resourceId = resourceId;\n      this.config = bitmapConfig;\n    }\n\n```\n\nRequest.Builder所做的操作就是接收从RequestCreator传递过来参数\n\n\n\ninto()方法\n\n```java\nRequestCreator.java\npublic void into(ImageView target, Callback callback) {\n    long started = System.nanoTime();\n  \t//是否为主线程\n    checkMain();\n\n    if (target == null) {\n      throw new IllegalArgumentException(\"Target must not be null.\");\n    }\n\t//是否有图片资源，如果rui为空或者ResId为空，则取消request\n  \t//uri != null || resourceId != 0\n    if (!data.hasImage()) {\n      picasso.cancelRequest(target);\n      //显示默认图片\n      if (setPlaceholder) {\n        setPlaceholder(target, getPlaceholderDrawable());\n      }\n      return;\n    }\n\t//deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高\n  \t//掉用过这个方法后不能再调用resize()操作\n    if (deferred) {\n      if (data.hasSize()) {\n        throw new IllegalStateException(\"Fit cannot be used with resize.\");\n      }\n      int width = target.getWidth();\n      int height = target.getHeight();\n      if (width == 0 || height == 0) {\n        if (setPlaceholder) {\n          setPlaceholder(target, getPlaceholderDrawable());\n        }\n        picasso.defer(target, new DeferredRequestCreator(this, target, callback));\n        return;\n      }\n      //设置图片宽高\n      data.resize(width, height);\n    }\n\t//新建request\n    Request request = createRequest(started);\n  \t//新建requestKey，即得到一个唯一标识request的key\n    String requestKey = createKey(request);\n\t//是否从缓存中读取\n    if (shouldReadFromMemoryCache(memoryPolicy)) {\n      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);\n      //得到缓存中的图片并且取消请求\n      if (bitmap != null) {\n        picasso.cancelRequest(target);\n        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);\n        if (picasso.loggingEnabled) {\n          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY);\n        }\n        //回调接口\n        if (callback != null) {\n          callback.onSuccess();\n        }\n        return;\n      }\n    }\n\n    if (setPlaceholder) {\n      setPlaceholder(target, getPlaceholderDrawable());\n    }\n\t//构造一个图片请求的动作\n    Action action =\n        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,\n            errorDrawable, requestKey, tag, callback, noFade);\n\t//添加到请求队列当中\n    picasso.enqueueAndSubmit(action);\n  }\n```\n\n在into()方法中主要的执行过程有如下几个步骤：\n\n- 检查运行的线程是否为主线程，如果不是抛异常，结束\n- 检查传入的uri或者resid等是否有图片资源，如果rui为空或者ResId为空，则取消request，结束\n- 检查deferred参数，deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高，调用过这个方法后不能再调用resize()操作。\n- 新建Request，判断是是否拥有缓存，如果有则直接获取并且取消请求，调用setBitMap()为target设置图片，结束\n- 如果没有缓存，则会构造一个Action来处理请求，然后添加至线程池当中\n\n**小提示：**\n\n在其中 createRequest(long started)方法中，会有一个请求转换的过程，这个过程一句使用者是否使用而决定，for  example:如果使用者在其中某一个ImageView的展示中想使用一个baseUrl不同的地址，那么我们就可以实现RequestTransformer接口，并且重写transformRequest(request)来自主构建Request实例。\n\n\n\n```java\nPiscasso.java\nvoid enqueueAndSubmit(Action action) {\n    Object target = action.getTarget();\n    if (target != null && targetToAction.get(target) != action) {\n      // This will also check we are on the main thread.\n      cancelExistingRequest(target);\n      targetToAction.put(target, action);\n    }\n    submit(action);\n  }\n\n  void submit(Action action) {\n    dispatcher.dispatchSubmit(action);\n  }\n```\n\n跟踪enqueueAndSubmit()最终调用到Dispatcher类当中，Dispatcher类所有的action操作(submit,cancel,pause.etc)，相关对应的逻辑处理完后会使用BitmapHunter来获取图片，BitmapHunter会最终回调Dispatcher的图片或是否成功的相关方法。\n\n简单看下Dispatcher的构造函数：\n\nDispatcher.java\n\n```java\nDispatcher.java\nDispatcher(Context context, ExecutorService service, Handler mainThreadHandler,\n      Downloader downloader, Cache cache, Stats stats) {\n    this.dispatcherThread = new DispatcherThread();\n    this.dispatcherThread.start();\n    Utils.flushStackLocalLeaks(dispatcherThread.getLooper());\n    this.context = context;\n    this.service = service;\n  \t//hunter的映射\n    this.hunterMap = new LinkedHashMap<String, BitmapHunter>();\n  \t//失败Action的映射\n    this.failedActions = new WeakHashMap<Object, Action>();\n  \t//暂停Action的映射\n    this.pausedActions = new WeakHashMap<Object, Action>();\n    this.pausedTags = new HashSet<Object>();\n  \t//DispatcherHandler初始化\n    this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);\n  \t//下载类\n    this.downloader = downloader;\n    this.mainThreadHandler = mainThreadHandler;\n    this.cache = cache;\n    this.stats = stats;\n    this.batch = new ArrayList<BitmapHunter>(4);\n    this.airplaneMode = Utils.isAirplaneModeOn(this.context);\n    this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);\n    this.receiver = new NetworkBroadcastReceiver(this);\n    receiver.register();\n  }\n\nvoid dispatchSubmit(Action action) {\n    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));\n  }\n\n private static class DispatcherHandler extends Handler {\n    private final Dispatcher dispatcher;\n\n    public DispatcherHandler(Looper looper, Dispatcher dispatcher) {\n      super(looper);\n      this.dispatcher = dispatcher;\n    }\n\n    @Override public void handleMessage(final Message msg) {\n      switch (msg.what) {\n        case REQUEST_SUBMIT: {\n          Action action = (Action) msg.obj;\n          dispatcher.performSubmit(action);\n          break;\n        }\n        case REQUEST_CANCEL: {\n          Action action = (Action) msg.obj;\n          dispatcher.performCancel(action);\n          break;\n        }\n        case TAG_PAUSE: {\n          Object tag = msg.obj;\n          dispatcher.performPauseTag(tag);\n          break;\n        }\n        case TAG_RESUME: {\n          Object tag = msg.obj;\n          dispatcher.performResumeTag(tag);\n          break;\n        }\n        case HUNTER_COMPLETE: {\n          BitmapHunter hunter = (BitmapHunter) msg.obj;\n          dispatcher.performComplete(hunter);\n          break;\n        }\n        case HUNTER_RETRY: {\n          BitmapHunter hunter = (BitmapHunter) msg.obj;\n          dispatcher.performRetry(hunter);\n          break;\n        }\n        case HUNTER_DECODE_FAILED: {\n          BitmapHunter hunter = (BitmapHunter) msg.obj;\n          dispatcher.performError(hunter, false);\n          break;\n        }\n        case HUNTER_DELAY_NEXT_BATCH: {\n          dispatcher.performBatchComplete();\n          break;\n        }\n        case NETWORK_STATE_CHANGE: {\n          NetworkInfo info = (NetworkInfo) msg.obj;\n          dispatcher.performNetworkStateChange(info);\n          break;\n        }\n        case AIRPLANE_MODE_CHANGE: {\n          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON);\n          break;\n        }\n        default:\n          Picasso.HANDLER.post(new Runnable() {\n            @Override public void run() {\n              throw new AssertionError(\"Unknown handler message received: \" + msg.what);\n            }\n          });\n      }\n    }\n  }\n```\n\n在初始化方法中，核心就是DispatcherHandler初始化，DispatcherHandler负责将消息进行传递调用diapatcher相应的方法，以Msg=REQUEST_SUBMIT为例，那么就会调用dispatcher.performSubmit(action)，dispatcher.performSubmit(action)方法如下所示：\n\n```java\nDispatcher.java\nvoid performSubmit(Action action, boolean dismissFailed) {\n  \t//暂停标识\n    if (pausedTags.contains(action.getTag())) {\n      pausedActions.put(action.getTarget(), action);\n      if (action.getPicasso().loggingEnabled) {\n        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),\n            \"because tag '\" + action.getTag() + \"' is paused\");\n      }\n      return;\n    }\n\t\n    BitmapHunter hunter = hunterMap.get(action.getKey());\n    if (hunter != null) {\n      hunter.attach(action);\n      return;\n    }\n\n    if (service.isShutdown()) {\n      if (action.getPicasso().loggingEnabled) {\n        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\");\n      }\n      return;\n    }\n\n    hunter = forRequest(action.getPicasso(), this, cache, stats, action);\n    hunter.future = service.submit(hunter);\n    hunterMap.put(action.getKey(), hunter);\n    if (dismissFailed) {\n      failedActions.remove(action.getTarget());\n    }\n\n    if (action.getPicasso().loggingEnabled) {\n      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());\n    }\n  }\n```\n\n这个方法的逻辑如下:\n\n1. 暂停的tags中是否包含当前action的tag，有的话则return，否则继续下一步\n2. hunterMap中是否已经包含了相同的hunter，如果有则attach()到hunter中，return；否则继续下一步\n3. 线程池是否shutDown，有则return，没有继续下一步\n4. 通过forRequest()方法获得一个request，并且添加到线程池service中\n\n\n在forRequest()方法中主要获取对应的RequestHandler处理类，这里类似于责任链的设计模式，通过依次传递request给各个handler来找到对应的匹配的RequestHandler。\n\nBitmapHunter是主要的图片处理类，在BitmapHunter中会判断是从网络中还是缓存中获取图片,由于BitmapHunter本身是线程类，且无论从缓存中取数据还是从网络中取数据都是耗时操作，所以才引申除了线程池service这个类来进行执行runnable，查看下代码：\n\n```java\nBitmapHunter.java\nstatic BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,\n      Action action) {\n    Request request = action.getRequest();\n    List<RequestHandler> requestHandlers = picasso.getRequestHandlers();\n\n    // Index-based loop to avoid allocating an iterator.\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0, count = requestHandlers.size(); i < count; i++) {\n      RequestHandler requestHandler = requestHandlers.get(i);\n      if (requestHandler.canHandleRequest(request)) {\n        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);\n      }\n    }\n\n    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);\n  }\n....\n  @Override public void run() {\n    try {\n      //更新县城名字\n      updateThreadName(data);\n      //核心方法\n      result = hunt();\n\n      if (result == null) {\n        dispatcher.dispatchFailed(this);\n      } else {\n        dispatcher.dispatchComplete(this);\n      }\n      //各种异常的捕获处理\n    } catch (Downloader.ResponseException e) {\n      if (!e.localCacheOnly || e.responseCode != 504) {\n        exception = e;\n      }\n      dispatcher.dispatchFailed(this);\n    } catch (NetworkRequestHandler.ContentLengthException e) {\n      exception = e;\n      dispatcher.dispatchRetry(this);\n    } catch (IOException e) {\n      exception = e;\n      dispatcher.dispatchRetry(this);\n    } catch (OutOfMemoryError e) {\n      StringWriter writer = new StringWriter();\n      stats.createSnapshot().dump(new PrintWriter(writer));\n      exception = new RuntimeException(writer.toString(), e);\n      dispatcher.dispatchFailed(this);\n    } catch (Exception e) {\n      exception = e;\n      dispatcher.dispatchFailed(this);\n    } finally {\n      Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);\n    }\n  }\n```\n\nBitmapHunter.run()方法中主要通过调用hunt()方法获取到Bitmap，此时会对result进行判断的操作，如果为空则回调dispatcher.dispatchFailed()，不为空则调用dispatcher.dispatchComplete()方法，并且捕获异常，根据相关的异常来对应回调到dispatcher不同的方法中。\n\nBitmapHunter.hunt()方法详解：\n\n```java\nBitmap hunt() throws IOException {\n    Bitmap bitmap = null;\n\t//是否从缓存读取\n    if (shouldReadFromMemoryCache(memoryPolicy)) {\n      bitmap = cache.get(key);\n      if (bitmap != null) {\n        stats.dispatchCacheHit();\n        loadedFrom = MEMORY;\n        if (picasso.loggingEnabled) {\n          log(OWNER_HUNTER, VERB_DECODED, data.logId(), \"from cache\");\n        }\n        return bitmap;\n      }\n    }\n\t//网络读取\n    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;\n    RequestHandler.Result result = requestHandler.load(data, networkPolicy);\n    if (result != null) {\n      loadedFrom = result.getLoadedFrom();\n      exifRotation = result.getExifOrientation();\n\n      bitmap = result.getBitmap();\n\n      // If there was no Bitmap then we need to decode it from the stream.\n      if (bitmap == null) {\n        InputStream is = result.getStream();\n        try {\n          bitmap = decodeStream(is, data);\n        } finally {\n          Utils.closeQuietly(is);\n        }\n      }\n    }\n\n    if (bitmap != null) {\n      if (picasso.loggingEnabled) {\n        log(OWNER_HUNTER, VERB_DECODED, data.logId());\n      }\n      stats.dispatchBitmapDecoded(bitmap);\n      if (data.needsTransformation() || exifRotation != 0) {\n        synchronized (DECODE_LOCK) {\n          if (data.needsMatrixTransform() || exifRotation != 0) {\n            bitmap = transformResult(data, bitmap, exifRotation);\n            if (picasso.loggingEnabled) {\n              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());\n            }\n          }\n          if (data.hasCustomTransformations()) {\n            bitmap = applyCustomTransformations(data.transformations, bitmap);\n            if (picasso.loggingEnabled) {\n              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), \"from custom transformations\");\n            }\n          }\n        }\n        if (bitmap != null) {\n          stats.dispatchBitmapTransformed(bitmap);\n        }\n      }\n    }\n\n    return bitmap;\n  }\n```\n\nhunt()方法过程如下：\n\n1. 从缓存里面找到对应的图片，有则返回，没有则玩下走；\n\n2. 将Request交付给对应的RequestHandler.load()来获取到图片，并且判断是否需要加工(needsTransformation\n\n   ()),需要则转换图片后再返回Bitmap\n\n回到BitmapHunter.createRequest()，最终过程都会调用到dispatcher.dispatchComplete(this)和dispatcher.dispatchFailed(this)，而这两个方法会调用到dispatcher.performBatchComplete()中。\n\n附：\n\n- dispatcher.dispatchRetry(this)：主要对requset进行重新请求操作，会再次执行一次获取图片的过程\n- dispatcher.dispatchComplete(this)：最终调用performBatchComplete()对主线程发送一个承载着List<BitmapHunter>的msg\n- dispatcher.dispatchFailed(this)：最终调用performBatchComplete()对主线程发送一个承载着List<BitmapHunter>的msg\n\n在其中又会将HUNTER_BATCH_COMPLETE这个msg发送给主线程的handler，即在Picasso.java中初始化的HANDLER:\n\n```java\nDispatcher.java\nvoid performBatchComplete() {\n    List<BitmapHunter> copy = new ArrayList<BitmapHunter>(batch);\n    batch.clear();\n    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));\n    logBatch(copy);\n  }\nvoid performError(BitmapHunter hunter, boolean willReplay) {\n    if (hunter.getPicasso().loggingEnabled) {\n      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter),\n          \"for error\" + (willReplay ? \" (will replay)\" : \"\"));\n    }\n    hunterMap.remove(hunter.getKey());\n    batch(hunter);\n  }\n\n\nPicasso.java\nstatic final Handler HANDLER = new Handler(Looper.getMainLooper()) {\n    @Override public void handleMessage(Message msg) {\n      switch (msg.what) {\n        case HUNTER_BATCH_COMPLETE: {\n          @SuppressWarnings(\"unchecked\") List<BitmapHunter> batch = (List<BitmapHunter>) msg.obj;\n          //noinspection ForLoopReplaceableByForEach\n          for (int i = 0, n = batch.size(); i < n; i++) {\n            BitmapHunter hunter = batch.get(i);\n            hunter.picasso.complete(hunter);\n          }\n          break;\n        }\n        case REQUEST_GCED: {\n          Action action = (Action) msg.obj;\n          if (action.getPicasso().loggingEnabled) {\n            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), \"target got garbage collected\");\n          }\n          action.picasso.cancelExistingRequest(action.getTarget());\n          break;\n        }\n        case REQUEST_BATCH_RESUME:\n          @SuppressWarnings(\"unchecked\") List<Action> batch = (List<Action>) msg.obj;\n          //noinspection ForLoopReplaceableByForEach\n          for (int i = 0, n = batch.size(); i < n; i++) {\n            Action action = batch.get(i);\n            action.picasso.resumeAction(action);\n          }\n          break;\n        default:\n          throw new AssertionError(\"Unknown handler message received: \" + msg.what);\n      }\n    }\n  };\n```\n\n\n\nhunter.picasso.complete(hunter)方法：\n\n```java\nPicasso.java \nvoid complete(BitmapHunter hunter) {\n    Action single = hunter.getAction();\n    List<Action> joined = hunter.getActions();\n\n    boolean hasMultiple = joined != null && !joined.isEmpty();\n    boolean shouldDeliver = single != null || hasMultiple;\n\n    if (!shouldDeliver) {\n      return;\n    }\n\n    Uri uri = hunter.getData().uri;\n    Exception exception = hunter.getException();\n    Bitmap result = hunter.getResult();\n    LoadedFrom from = hunter.getLoadedFrom();\n\n    if (single != null) {\n      deliverAction(result, from, single);\n    }\n\n    if (hasMultiple) {\n      //noinspection ForLoopReplaceableByForEach\n      for (int i = 0, n = joined.size(); i < n; i++) {\n        Action join = joined.get(i);\n        deliverAction(result, from, join);\n      }\n    }\n\n    if (listener != null && exception != null) {\n      listener.onImageLoadFailed(this, uri, exception);\n    }\n  }\n\nprivate void deliverAction(Bitmap result, LoadedFrom from, Action action) {\n    if (action.isCancelled()) {\n      return;\n    }\n    if (!action.willReplay()) {\n      targetToAction.remove(action.getTarget());\n    }\n    if (result != null) {\n      if (from == null) {\n        throw new AssertionError(\"LoadedFrom cannot be null.\");\n      }\n      action.complete(result, from);\n      if (loggingEnabled) {\n        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), \"from \" + from);\n      }\n    } else {\n      action.error();\n      if (loggingEnabled) {\n        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());\n      }\n    }\n  }\n```\n\ncomplete()方法中最终会调用action.complete(result, from)和action.error()来传递给对应的Action实现类，在这里我们选择的是ImageAction来查看对应方法\n\n```java\n@Override public void complete(Bitmap result, Picasso.LoadedFrom from) {\n    if (result == null) {\n      throw new AssertionError(\n          String.format(\"Attempted to complete action with no result!\\n%s\", this));\n    }\n\n    ImageView target = this.target.get();\n    if (target == null) {\n      return;\n    }\n\n    Context context = picasso.context;\n    boolean indicatorsEnabled = picasso.indicatorsEnabled;\n  \t//设置图片\n    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);\n\n    if (callback != null) {\n      callback.onSuccess();\n    }\n  }\n\n  @Override public void error() {\n    ImageView target = this.target.get();\n    if (target == null) {\n      return;\n    }\n    //设置错误图片\n    if (errorResId != 0) {\n      target.setImageResource(errorResId);\n    } else if (errorDrawable != null) {\n      target.setImageDrawable(errorDrawable);\n    }\n\n    if (callback != null) {\n      callback.onError();\n    }\n  }\n```\n\n到这里，基本上也结束了，对应的图片也展示到了Target中，基本的流程也就完成了","slug":"Picasso源码分析","published":1,"updated":"2016-12-13T02:43:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwmz2w8c0000dgs6ngfy5lvp","content":"<p>在Android中基本山所有的app都会涉及到网路图片的加载的需求，在Github上也有各式各样的开源的图片加载框架，从最初的UniversalImageLoader到现在的Gilde，Picasso和Fresco，对于图片加载框架的设计也趋于完善，现在主流也就是Gilde，Picasso和Fresco这个三个核心的框架了，那么这篇文章的目的就是从源码的角度来探究Picasso实现的过程。（本身适合了解基本api的童鞋阅读）</p>\n<a id=\"more\"></a>\n<hr>\n<h3>基本使用</h3>\n\n<p>关于Picasso的基本的使用该方法如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.with(context).load(url).into(imageView);</div></pre></td></tr></table></figure>\n<p>就只需要一句话就能够轻松将图片设置到你的ImageView当中，如果你有更多丰富的需求，诸如失败图片的正在加载图片的设置，只需要一句话，因为Picasso的图片展示基于Builder设计模式，我们可以任意添加所需要的功能，统统一句话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">picasso.with(<span class=\"keyword\">this</span>).load(url).config(Bitmap.Config.ARGB_8888).error(R.mipmap.ic_launcher).into(img);</div></pre></td></tr></table></figure>\n<p>用法非常简单，更多用法请仔细阅读api，本文的核心是对于源码的探究，下面我们基于picasso.with(context)为初始入口进行源码层级的阅读分析</p>\n<hr>\n<h3>源码分析</h3>\n\n<h4>picasso.with(context)</h4>\n\n<p>with()方法的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Picasso <span class=\"title\">with</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">synchronized</span> (Picasso.class) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          singleton = <span class=\"keyword\">new</span> Builder(context).build();</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> singleton;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Picasso <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      Context context = <span class=\"keyword\">this</span>.context;</div><div class=\"line\">\t  <span class=\"comment\">//初始化图片下载的loader</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (downloader == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        downloader = Utils.createDefaultDownloader(context);</div><div class=\"line\">      &#125;</div><div class=\"line\">  \t  <span class=\"comment\">//缓存初始化</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (cache == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        cache = <span class=\"keyword\">new</span> LruCache(context);</div><div class=\"line\">      &#125;</div><div class=\"line\">  \t  <span class=\"comment\">//初始化线程池</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        service = <span class=\"keyword\">new</span> PicassoExecutorService();</div><div class=\"line\">      &#125;</div><div class=\"line\">  \t  <span class=\"comment\">//初始化一个请求转换器</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (transformer == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        transformer = RequestTransformer.IDENTITY;</div><div class=\"line\">      &#125;</div><div class=\"line\">\t  <span class=\"comment\">//缓存统计</span></div><div class=\"line\">      Stats stats = <span class=\"keyword\">new</span> Stats(cache);</div><div class=\"line\">\t  <span class=\"comment\">//调度器</span></div><div class=\"line\">      Dispatcher dispatcher = <span class=\"keyword\">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class=\"line\">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>使用单例模式构造一个Picasso实现—singleton，初始化一个Builder，这个Builder的作用就是串联所有使用者设置的参数,并且调用其build()方法，在build的方法中做了一系列的初始化的操作：</p>\n<ol>\n<li>下载的loader的初始化</li>\n<li>图片缓存初始化</li>\n<li>线程池初始化</li>\n<li>请求转换器的初始化</li>\n<li>缓存统计类的初始化</li>\n<li>调度器的初始化</li>\n</ol>\n<p>这些一些凭名字可以看出作用，诸如下载loader和图片缓存的，其他的只能一步步探究其作用，暂且搁置，后面遇到了我们再分析，接下来就到了Picasso的构造方法中了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.<span class=\"function\">java </span></div><div class=\"line\"><span class=\"title\">Picasso</span><span class=\"params\">(Context context, Dispatcher dispatcher, Cache cache, Listener listener,</span></div><div class=\"line\">      RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats,</div><div class=\"line\">      Bitmap.Config defaultBitmapConfig, <span class=\"keyword\">boolean</span> indicatorsEnabled, <span class=\"keyword\">boolean</span> loggingEnabled) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatcher = dispatcher;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cache = cache;</div><div class=\"line\">    <span class=\"keyword\">this</span>.listener = listener;</div><div class=\"line\">    <span class=\"keyword\">this</span>.requestTransformer = requestTransformer;</div><div class=\"line\">    <span class=\"keyword\">this</span>.defaultBitmapConfig = defaultBitmapConfig;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> builtInHandlers = <span class=\"number\">7</span>; <span class=\"comment\">// Adjust this as internal handlers are added or removed.</span></div><div class=\"line\">    <span class=\"keyword\">int</span> extraCount = (extraRequestHandlers != <span class=\"keyword\">null</span> ? extraRequestHandlers.size() : <span class=\"number\">0</span>);</div><div class=\"line\">    List&lt;RequestHandler&gt; allRequestHandlers =</div><div class=\"line\">        <span class=\"keyword\">new</span> ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加各种加载不同图片地址的handler，如网络中的，resoure中的，相册，conteneprovider....</span></div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> ResourceRequestHandler(context));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (extraRequestHandlers != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      allRequestHandlers.addAll(extraRequestHandlers);</div><div class=\"line\">    &#125;</div><div class=\"line\">   \t<span class=\"comment\">//</span></div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> ContactsPhotoRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> MediaStoreRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> ContentStreamRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> AssetRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> FileRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</div><div class=\"line\">    requestHandlers = Collections.unmodifiableList(allRequestHandlers);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.stats = stats;</div><div class=\"line\">    <span class=\"keyword\">this</span>.targetToAction = <span class=\"keyword\">new</span> WeakHashMap&lt;Object, Action&gt;();</div><div class=\"line\">    <span class=\"keyword\">this</span>.targetToDeferredRequestCreator = <span class=\"keyword\">new</span> WeakHashMap&lt;ImageView, DeferredRequestCreator&gt;();</div><div class=\"line\">    <span class=\"keyword\">this</span>.indicatorsEnabled = indicatorsEnabled;</div><div class=\"line\">    <span class=\"keyword\">this</span>.loggingEnabled = loggingEnabled;</div><div class=\"line\">    <span class=\"keyword\">this</span>.referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;Object&gt;();</div><div class=\"line\">   \t<span class=\"comment\">//初始化一个清除request的Thread</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.cleanupThread = <span class=\"keyword\">new</span> CleanupThread(referenceQueue, HANDLER);</div><div class=\"line\">    <span class=\"keyword\">this</span>.cleanupThread.start();</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>Picasso的构造函数中从Buidler中获取到使用者设置的额外参数设置添加到配置当中，并且赋值给各个变量。在allRequestHandlers维护着所有可能获取到图片的路径，包括网上获取，Drawable文件获取，Asset文件中的获取等等的取图方式，最后初始化一个清除request的Thread。在构造函数中初始化的内容是这些，接下来，我们在查看一下load()方法，我们挑选load(uri)即加载网络图片的来进行源码的探究：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">load</span><span class=\"params\">(Uri uri)</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RequestCreator(<span class=\"keyword\">this</span>, uri, <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>load(uri)的方法非常简单，即返回一个RequestCreator()，这个RequestCreator是所有load(…)方法的返回参数，我们得查看一下这个类的作用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">RequestCreator.<span class=\"function\">java </span></div><div class=\"line\"><span class=\"title\">RequestCreator</span><span class=\"params\">(Picasso picasso, Uri uri, <span class=\"keyword\">int</span> resourceId)</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (picasso.shutdown) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">          <span class=\"string\">\"Picasso instance already shut down. Cannot submit new requests.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.picasso = picasso;</div><div class=\"line\">    <span class=\"comment\">//初始化Reques类</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.data = <span class=\"keyword\">new</span> Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">error</span><span class=\"params\">(<span class=\"keyword\">int</span> errorResId)</span></span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">placeholder</span><span class=\"params\">(<span class=\"keyword\">int</span> placeholderResId)</span> </span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">fit</span><span class=\"params\">()</span> </span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> targetWidth, <span class=\"keyword\">int</span> targetHeight)</span></span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">centerInside</span><span class=\"params\">()</span></span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">clearCenterCrop</span><span class=\"params\">()</span></span>&#123;...&#125;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>熟悉API的朋友就知道这些方法的具体作用，那么RequestCreator的作用在于在给target设置图片之前，读取用户一切对于目标target的操作，如：error图片的设置，加载过程中图片的设置，设置图片宽高等等，相当于一个预处理类的作用，然后把所有的参传递给Request。所以我们可以在调用into()方法之前将我们所有的要求设置到RequestCreator(Builder设计模式)。</p>\n<p>我们再看构造方法中初始化了一个Request.Builder()，进入源码中查看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request.<span class=\"function\">java</span></div><div class=\"line\">  <span class=\"title\">Builder</span><span class=\"params\">(Uri uri, <span class=\"keyword\">int</span> resourceId, Bitmap.Config bitmapConfig)</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.uri = uri;</div><div class=\"line\">      <span class=\"keyword\">this</span>.resourceId = resourceId;</div><div class=\"line\">      <span class=\"keyword\">this</span>.config = bitmapConfig;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>Request.Builder所做的操作就是接收从RequestCreator传递过来参数</p>\n<p>into()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">RequestCreator.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">into</span><span class=\"params\">(ImageView target, Callback callback)</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> started = System.nanoTime();</div><div class=\"line\">  \t<span class=\"comment\">//是否为主线程</span></div><div class=\"line\">    checkMain();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Target must not be null.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//是否有图片资源，如果rui为空或者ResId为空，则取消request</span></div><div class=\"line\">  \t<span class=\"comment\">//uri != null || resourceId != 0</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!data.hasImage()) &#123;</div><div class=\"line\">      picasso.cancelRequest(target);</div><div class=\"line\">      <span class=\"comment\">//显示默认图片</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (setPlaceholder) &#123;</div><div class=\"line\">        setPlaceholder(target, getPlaceholderDrawable());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高</span></div><div class=\"line\">  \t<span class=\"comment\">//掉用过这个方法后不能再调用resize()操作</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data.hasSize()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fit cannot be used with resize.\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">int</span> width = target.getWidth();</div><div class=\"line\">      <span class=\"keyword\">int</span> height = target.getHeight();</div><div class=\"line\">      <span class=\"keyword\">if</span> (width == <span class=\"number\">0</span> || height == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (setPlaceholder) &#123;</div><div class=\"line\">          setPlaceholder(target, getPlaceholderDrawable());</div><div class=\"line\">        &#125;</div><div class=\"line\">        picasso.defer(target, <span class=\"keyword\">new</span> DeferredRequestCreator(<span class=\"keyword\">this</span>, target, callback));</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//设置图片宽高</span></div><div class=\"line\">      data.resize(width, height);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//新建request</span></div><div class=\"line\">    Request request = createRequest(started);</div><div class=\"line\">  \t<span class=\"comment\">//新建requestKey，即得到一个唯一标识request的key</span></div><div class=\"line\">    String requestKey = createKey(request);</div><div class=\"line\">\t<span class=\"comment\">//是否从缓存中读取</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class=\"line\">      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class=\"line\">      <span class=\"comment\">//得到缓存中的图片并且取消请求</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        picasso.cancelRequest(target);</div><div class=\"line\">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</div><div class=\"line\">        <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class=\"string\">\"from \"</span> + MEMORY);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//回调接口</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          callback.onSuccess();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (setPlaceholder) &#123;</div><div class=\"line\">      setPlaceholder(target, getPlaceholderDrawable());</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//构造一个图片请求的动作</span></div><div class=\"line\">    Action action =</div><div class=\"line\">        <span class=\"keyword\">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</div><div class=\"line\">            errorDrawable, requestKey, tag, callback, noFade);</div><div class=\"line\">\t<span class=\"comment\">//添加到请求队列当中</span></div><div class=\"line\">    picasso.enqueueAndSubmit(action);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>在into()方法中主要的执行过程有如下几个步骤：</p>\n<ul>\n<li>检查运行的线程是否为主线程，如果不是抛异常，结束</li>\n<li>检查传入的uri或者resid等是否有图片资源，如果rui为空或者ResId为空，则取消request，结束</li>\n<li>检查deferred参数，deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高，调用过这个方法后不能再调用resize()操作。</li>\n<li>新建Request，判断是是否拥有缓存，如果有则直接获取并且取消请求，调用setBitMap()为target设置图片，结束</li>\n<li>如果没有缓存，则会构造一个Action来处理请求，然后添加至线程池当中</li>\n</ul>\n<p><strong>小提示：</strong></p>\n<p>在其中 createRequest(long started)方法中，会有一个请求转换的过程，这个过程一句使用者是否使用而决定，for  example:如果使用者在其中某一个ImageView的展示中想使用一个baseUrl不同的地址，那么我们就可以实现RequestTransformer接口，并且重写transformRequest(request)来自主构建Request实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Piscasso.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">enqueueAndSubmit</span><span class=\"params\">(Action action)</span> &#123;</div><div class=\"line\">    Object target = action.getTarget();</div><div class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</div><div class=\"line\">      <span class=\"comment\">// This will also check we are on the main thread.</span></div><div class=\"line\">      cancelExistingRequest(target);</div><div class=\"line\">      targetToAction.put(target, action);</div><div class=\"line\">    &#125;</div><div class=\"line\">    submit(action);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">submit</span><span class=\"params\">(Action action)</span> </span>&#123;</div><div class=\"line\">    dispatcher.dispatchSubmit(action);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>跟踪enqueueAndSubmit()最终调用到Dispatcher类当中，Dispatcher类所有的action操作(submit,cancel,pause.etc)，相关对应的逻辑处理完后会使用BitmapHunter来获取图片，BitmapHunter会最终回调Dispatcher的图片或是否成功的相关方法。</p>\n<p>简单看下Dispatcher的构造函数：</p>\n<p>Dispatcher.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dispatcher.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"title\">Dispatcher</span><span class=\"params\">(Context context, ExecutorService service, Handler mainThreadHandler,</span></div><div class=\"line\">      Downloader downloader, Cache cache, Stats stats) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatcherThread = <span class=\"keyword\">new</span> DispatcherThread();</div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatcherThread.start();</div><div class=\"line\">    Utils.flushStackLocalLeaks(dispatcherThread.getLooper());</div><div class=\"line\">    <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">    <span class=\"keyword\">this</span>.service = service;</div><div class=\"line\">  \t<span class=\"comment\">//hunter的映射</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.hunterMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;String, BitmapHunter&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//失败Action的映射</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.failedActions = <span class=\"keyword\">new</span> WeakHashMap&lt;Object, Action&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//暂停Action的映射</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.pausedActions = <span class=\"keyword\">new</span> WeakHashMap&lt;Object, Action&gt;();</div><div class=\"line\">    <span class=\"keyword\">this</span>.pausedTags = <span class=\"keyword\">new</span> HashSet&lt;Object&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//DispatcherHandler初始化</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handler = <span class=\"keyword\">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"comment\">//下载类</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.downloader = downloader;</div><div class=\"line\">    <span class=\"keyword\">this</span>.mainThreadHandler = mainThreadHandler;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cache = cache;</div><div class=\"line\">    <span class=\"keyword\">this</span>.stats = stats;</div><div class=\"line\">    <span class=\"keyword\">this</span>.batch = <span class=\"keyword\">new</span> ArrayList&lt;BitmapHunter&gt;(<span class=\"number\">4</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.airplaneMode = Utils.isAirplaneModeOn(<span class=\"keyword\">this</span>.context);</div><div class=\"line\">    <span class=\"keyword\">this</span>.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);</div><div class=\"line\">    <span class=\"keyword\">this</span>.receiver = <span class=\"keyword\">new</span> NetworkBroadcastReceiver(<span class=\"keyword\">this</span>);</div><div class=\"line\">    receiver.register();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchSubmit</span><span class=\"params\">(Action action)</span> </span>&#123;</div><div class=\"line\">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Dispatcher dispatcher;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DispatcherHandler</span><span class=\"params\">(Looper looper, Dispatcher dispatcher)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>(looper);</div><div class=\"line\">      <span class=\"keyword\">this</span>.dispatcher = dispatcher;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_SUBMIT: &#123;</div><div class=\"line\">          Action action = (Action) msg.obj;</div><div class=\"line\">          dispatcher.performSubmit(action);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_CANCEL: &#123;</div><div class=\"line\">          Action action = (Action) msg.obj;</div><div class=\"line\">          dispatcher.performCancel(action);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> TAG_PAUSE: &#123;</div><div class=\"line\">          Object tag = msg.obj;</div><div class=\"line\">          dispatcher.performPauseTag(tag);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> TAG_RESUME: &#123;</div><div class=\"line\">          Object tag = msg.obj;</div><div class=\"line\">          dispatcher.performResumeTag(tag);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_COMPLETE: &#123;</div><div class=\"line\">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class=\"line\">          dispatcher.performComplete(hunter);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_RETRY: &#123;</div><div class=\"line\">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class=\"line\">          dispatcher.performRetry(hunter);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_DECODE_FAILED: &#123;</div><div class=\"line\">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class=\"line\">          dispatcher.performError(hunter, <span class=\"keyword\">false</span>);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_DELAY_NEXT_BATCH: &#123;</div><div class=\"line\">          dispatcher.performBatchComplete();</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> NETWORK_STATE_CHANGE: &#123;</div><div class=\"line\">          NetworkInfo info = (NetworkInfo) msg.obj;</div><div class=\"line\">          dispatcher.performNetworkStateChange(info);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> AIRPLANE_MODE_CHANGE: &#123;</div><div class=\"line\">          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">          Picasso.HANDLER.post(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Unknown handler message received: \"</span> + msg.what);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>在初始化方法中，核心就是DispatcherHandler初始化，DispatcherHandler负责将消息进行传递调用diapatcher相应的方法，以Msg=REQUEST_SUBMIT为例，那么就会调用dispatcher.performSubmit(action)，dispatcher.performSubmit(action)方法如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dispatcher.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">performSubmit</span><span class=\"params\">(Action action, <span class=\"keyword\">boolean</span> dismissFailed)</span> &#123;</div><div class=\"line\">  \t<span class=\"comment\">//暂停标识</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class=\"line\">      pausedActions.put(action.getTarget(), action);</div><div class=\"line\">      <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class=\"line\">            <span class=\"string\">\"because tag '\"</span> + action.getTag() + <span class=\"string\">\"' is paused\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class=\"line\">    <span class=\"keyword\">if</span> (hunter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      hunter.attach(action);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (service.isShutdown()) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class=\"string\">\"because shut down\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    hunter = forRequest(action.getPicasso(), <span class=\"keyword\">this</span>, cache, stats, action);</div><div class=\"line\">    hunter.future = service.submit(hunter);</div><div class=\"line\">    hunterMap.put(action.getKey(), hunter);</div><div class=\"line\">    <span class=\"keyword\">if</span> (dismissFailed) &#123;</div><div class=\"line\">      failedActions.remove(action.getTarget());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这个方法的逻辑如下:</p>\n<ol>\n<li>暂停的tags中是否包含当前action的tag，有的话则return，否则继续下一步</li>\n<li>hunterMap中是否已经包含了相同的hunter，如果有则attach()到hunter中，return；否则继续下一步</li>\n<li>线程池是否shutDown，有则return，没有继续下一步</li>\n<li>通过forRequest()方法获得一个request，并且添加到线程池service中</li>\n</ol>\n<p>在forRequest()方法中主要获取对应的RequestHandler处理类，这里类似于责任链的设计模式，通过依次传递request给各个handler来找到对应的匹配的RequestHandler。</p>\n<p>BitmapHunter是主要的图片处理类，在BitmapHunter中会判断是从网络中还是缓存中获取图片,由于BitmapHunter本身是线程类，且无论从缓存中取数据还是从网络中取数据都是耗时操作，所以才引申除了线程池service这个类来进行执行runnable，查看下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">BitmapHunter.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"keyword\">static</span> BitmapHunter <span class=\"title\">forRequest</span><span class=\"params\">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span></div><div class=\"line\">      Action action) &#123;</div><div class=\"line\">    Request request = action.getRequest();</div><div class=\"line\">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Index-based loop to avoid allocating an iterator.</span></div><div class=\"line\">    <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</div><div class=\"line\">      RequestHandler requestHandler = requestHandlers.get(i);</div><div class=\"line\">      <span class=\"keyword\">if</span> (requestHandler.canHandleRequest(request)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</div><div class=\"line\">  &#125;</div><div class=\"line\">....</div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">//更新县城名字</span></div><div class=\"line\">      updateThreadName(data);</div><div class=\"line\">      <span class=\"comment\">//核心方法</span></div><div class=\"line\">      result = hunt();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        dispatcher.dispatchComplete(<span class=\"keyword\">this</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//各种异常的捕获处理</span></div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Downloader.ResponseException e) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!e.localCacheOnly || e.responseCode != <span class=\"number\">504</span>) &#123;</div><div class=\"line\">        exception = e;</div><div class=\"line\">      &#125;</div><div class=\"line\">      dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NetworkRequestHandler.ContentLengthException e) &#123;</div><div class=\"line\">      exception = e;</div><div class=\"line\">      dispatcher.dispatchRetry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">      exception = e;</div><div class=\"line\">      dispatcher.dispatchRetry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError e) &#123;</div><div class=\"line\">      StringWriter writer = <span class=\"keyword\">new</span> StringWriter();</div><div class=\"line\">      stats.createSnapshot().dump(<span class=\"keyword\">new</span> PrintWriter(writer));</div><div class=\"line\">      exception = <span class=\"keyword\">new</span> RuntimeException(writer.toString(), e);</div><div class=\"line\">      dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">      exception = e;</div><div class=\"line\">      dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>BitmapHunter.run()方法中主要通过调用hunt()方法获取到Bitmap，此时会对result进行判断的操作，如果为空则回调dispatcher.dispatchFailed()，不为空则调用dispatcher.dispatchComplete()方法，并且捕获异常，根据相关的异常来对应回调到dispatcher不同的方法中。</p>\n<p>BitmapHunter.hunt()方法详解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Bitmap <span class=\"title\">hunt</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Bitmap bitmap = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"comment\">//是否从缓存读取</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class=\"line\">      bitmap = cache.get(key);</div><div class=\"line\">      <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        stats.dispatchCacheHit();</div><div class=\"line\">        loadedFrom = MEMORY;</div><div class=\"line\">        <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), <span class=\"string\">\"from cache\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//网络读取</span></div><div class=\"line\">    data.networkPolicy = retryCount == <span class=\"number\">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</div><div class=\"line\">    RequestHandler.Result result = requestHandler.load(data, networkPolicy);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loadedFrom = result.getLoadedFrom();</div><div class=\"line\">      exifRotation = result.getExifOrientation();</div><div class=\"line\"></div><div class=\"line\">      bitmap = result.getBitmap();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// If there was no Bitmap then we need to decode it from the stream.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (bitmap == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        InputStream is = result.getStream();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          bitmap = decodeStream(is, data);</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          Utils.closeQuietly(is);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</div><div class=\"line\">      &#125;</div><div class=\"line\">      stats.dispatchBitmapDecoded(bitmap);</div><div class=\"line\">      <span class=\"keyword\">if</span> (data.needsTransformation() || exifRotation != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (DECODE_LOCK) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (data.needsMatrixTransform() || exifRotation != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            bitmap = transformResult(data, bitmap, exifRotation);</div><div class=\"line\">            <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">if</span> (data.hasCustomTransformations()) &#123;</div><div class=\"line\">            bitmap = applyCustomTransformations(data.transformations, bitmap);</div><div class=\"line\">            <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), <span class=\"string\">\"from custom transformations\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          stats.dispatchBitmapTransformed(bitmap);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>hunt()方法过程如下：</p>\n<ol>\n<li><p>从缓存里面找到对应的图片，有则返回，没有则玩下走；</p>\n</li>\n<li><p>将Request交付给对应的RequestHandler.load()来获取到图片，并且判断是否需要加工(needsTransformation</p>\n<p>()),需要则转换图片后再返回Bitmap</p>\n</li>\n</ol>\n<p>回到BitmapHunter.createRequest()，最终过程都会调用到dispatcher.dispatchComplete(this)和dispatcher.dispatchFailed(this)，而这两个方法会调用到dispatcher.performBatchComplete()中。</p>\n<p>附：</p>\n<ul>\n<li>dispatcher.dispatchRetry(this)：主要对requset进行重新请求操作，会再次执行一次获取图片的过程</li>\n<li>dispatcher.dispatchComplete(this)：最终调用performBatchComplete()对主线程发送一个承载着List<bitmaphunter>的msg</bitmaphunter></li>\n<li>dispatcher.dispatchFailed(this)：最终调用performBatchComplete()对主线程发送一个承载着List<bitmaphunter>的msg</bitmaphunter></li>\n</ul>\n<p>在其中又会将HUNTER_BATCH_COMPLETE这个msg发送给主线程的handler，即在Picasso.java中初始化的HANDLER:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dispatcher.<span class=\"function\">java</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">performBatchComplete</span><span class=\"params\">()</span> &#123;</div><div class=\"line\">    List&lt;BitmapHunter&gt; copy = <span class=\"keyword\">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class=\"line\">    batch.clear();</div><div class=\"line\">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class=\"line\">    logBatch(copy);</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">performError</span><span class=\"params\">(BitmapHunter hunter, <span class=\"keyword\">boolean</span> willReplay)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter),</div><div class=\"line\">          <span class=\"string\">\"for error\"</span> + (willReplay ? <span class=\"string\">\" (will replay)\"</span> : <span class=\"string\">\"\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    hunterMap.remove(hunter.getKey());</div><div class=\"line\">    batch(hunter);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Picasso.java</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Handler HANDLER = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class=\"line\">          <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class=\"line\">          <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class=\"line\">            BitmapHunter hunter = batch.get(i);</div><div class=\"line\">            hunter.picasso.complete(hunter);</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_GCED: &#123;</div><div class=\"line\">          Action action = (Action) msg.obj;</div><div class=\"line\">          <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), <span class=\"string\">\"target got garbage collected\"</span>);</div><div class=\"line\">          &#125;</div><div class=\"line\">          action.picasso.cancelExistingRequest(action.getTarget());</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_BATCH_RESUME:</div><div class=\"line\">          <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) List&lt;Action&gt; batch = (List&lt;Action&gt;) msg.obj;</div><div class=\"line\">          <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class=\"line\">            Action action = batch.get(i);</div><div class=\"line\">            action.picasso.resumeAction(action);</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Unknown handler message received: \"</span> + msg.what);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure>\n<p>hunter.picasso.complete(hunter)方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.<span class=\"function\">java </span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(BitmapHunter hunter)</span> &#123;</div><div class=\"line\">    Action single = hunter.getAction();</div><div class=\"line\">    List&lt;Action&gt; joined = hunter.getActions();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">boolean</span> hasMultiple = joined != <span class=\"keyword\">null</span> &amp;&amp; !joined.isEmpty();</div><div class=\"line\">    <span class=\"keyword\">boolean</span> shouldDeliver = single != <span class=\"keyword\">null</span> || hasMultiple;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!shouldDeliver) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Uri uri = hunter.getData().uri;</div><div class=\"line\">    Exception exception = hunter.getException();</div><div class=\"line\">    Bitmap result = hunter.getResult();</div><div class=\"line\">    LoadedFrom from = hunter.getLoadedFrom();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (single != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      deliverAction(result, from, single);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (hasMultiple) &#123;</div><div class=\"line\">      <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = joined.size(); i &lt; n; i++) &#123;</div><div class=\"line\">        Action join = joined.get(i);</div><div class=\"line\">        deliverAction(result, from, join);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span> &amp;&amp; exception != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      listener.onImageLoadFailed(<span class=\"keyword\">this</span>, uri, exception);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverAction</span><span class=\"params\">(Bitmap result, LoadedFrom from, Action action)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (action.isCancelled()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!action.willReplay()) &#123;</div><div class=\"line\">      targetToAction.remove(action.getTarget());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (from == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LoadedFrom cannot be null.\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      action.complete(result, from);</div><div class=\"line\">      <span class=\"keyword\">if</span> (loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class=\"string\">\"from \"</span> + from);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      action.error();</div><div class=\"line\">      <span class=\"keyword\">if</span> (loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>complete()方法中最终会调用action.complete(result, from)和action.error()来传递给对应的Action实现类，在这里我们选择的是ImageAction来查看对应方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(</div><div class=\"line\">          String.format(<span class=\"string\">\"Attempted to complete action with no result!\\n%s\"</span>, <span class=\"keyword\">this</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ImageView target = <span class=\"keyword\">this</span>.target.get();</div><div class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Context context = picasso.context;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class=\"line\">  \t<span class=\"comment\">//设置图片</span></div><div class=\"line\">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      callback.onSuccess();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ImageView target = <span class=\"keyword\">this</span>.target.get();</div><div class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//设置错误图片</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (errorResId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      target.setImageResource(errorResId);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errorDrawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      target.setImageDrawable(errorDrawable);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      callback.onError();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>到这里，基本上也结束了，对应的图片也展示到了Target中，基本的流程也就完成了</p>\n","excerpt":"<p>在Android中基本山所有的app都会涉及到网路图片的加载的需求，在Github上也有各式各样的开源的图片加载框架，从最初的UniversalImageLoader到现在的Gilde，Picasso和Fresco，对于图片加载框架的设计也趋于完善，现在主流也就是Gilde，Picasso和Fresco这个三个核心的框架了，那么这篇文章的目的就是从源码的角度来探究Picasso实现的过程。（本身适合了解基本api的童鞋阅读）</p>","more":"<hr>\n<h3>基本使用</h3>\n\n<p>关于Picasso的基本的使用该方法如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.with(context).load(url).into(imageView);</div></pre></td></tr></table></figure>\n<p>就只需要一句话就能够轻松将图片设置到你的ImageView当中，如果你有更多丰富的需求，诸如失败图片的正在加载图片的设置，只需要一句话，因为Picasso的图片展示基于Builder设计模式，我们可以任意添加所需要的功能，统统一句话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">picasso.with(<span class=\"keyword\">this</span>).load(url).config(Bitmap.Config.ARGB_8888).error(R.mipmap.ic_launcher).into(img);</div></pre></td></tr></table></figure>\n<p>用法非常简单，更多用法请仔细阅读api，本文的核心是对于源码的探究，下面我们基于picasso.with(context)为初始入口进行源码层级的阅读分析</p>\n<hr>\n<h3>源码分析</h3>\n\n<h4>picasso.with(context)</h4>\n\n<p>with()方法的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Picasso <span class=\"title\">with</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">synchronized</span> (Picasso.class) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          singleton = <span class=\"keyword\">new</span> Builder(context).build();</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> singleton;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Picasso <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      Context context = <span class=\"keyword\">this</span>.context;</div><div class=\"line\">\t  <span class=\"comment\">//初始化图片下载的loader</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (downloader == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        downloader = Utils.createDefaultDownloader(context);</div><div class=\"line\">      &#125;</div><div class=\"line\">  \t  <span class=\"comment\">//缓存初始化</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (cache == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        cache = <span class=\"keyword\">new</span> LruCache(context);</div><div class=\"line\">      &#125;</div><div class=\"line\">  \t  <span class=\"comment\">//初始化线程池</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        service = <span class=\"keyword\">new</span> PicassoExecutorService();</div><div class=\"line\">      &#125;</div><div class=\"line\">  \t  <span class=\"comment\">//初始化一个请求转换器</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (transformer == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        transformer = RequestTransformer.IDENTITY;</div><div class=\"line\">      &#125;</div><div class=\"line\">\t  <span class=\"comment\">//缓存统计</span></div><div class=\"line\">      Stats stats = <span class=\"keyword\">new</span> Stats(cache);</div><div class=\"line\">\t  <span class=\"comment\">//调度器</span></div><div class=\"line\">      Dispatcher dispatcher = <span class=\"keyword\">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class=\"line\">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>使用单例模式构造一个Picasso实现—singleton，初始化一个Builder，这个Builder的作用就是串联所有使用者设置的参数,并且调用其build()方法，在build的方法中做了一系列的初始化的操作：</p>\n<ol>\n<li>下载的loader的初始化</li>\n<li>图片缓存初始化</li>\n<li>线程池初始化</li>\n<li>请求转换器的初始化</li>\n<li>缓存统计类的初始化</li>\n<li>调度器的初始化</li>\n</ol>\n<p>这些一些凭名字可以看出作用，诸如下载loader和图片缓存的，其他的只能一步步探究其作用，暂且搁置，后面遇到了我们再分析，接下来就到了Picasso的构造方法中了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.<span class=\"function\">java </div><div class=\"line\"><span class=\"title\">Picasso</span><span class=\"params\">(Context context, Dispatcher dispatcher, Cache cache, Listener listener,</div><div class=\"line\">      RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats,</div><div class=\"line\">      Bitmap.Config defaultBitmapConfig, <span class=\"keyword\">boolean</span> indicatorsEnabled, <span class=\"keyword\">boolean</span> loggingEnabled)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatcher = dispatcher;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cache = cache;</div><div class=\"line\">    <span class=\"keyword\">this</span>.listener = listener;</div><div class=\"line\">    <span class=\"keyword\">this</span>.requestTransformer = requestTransformer;</div><div class=\"line\">    <span class=\"keyword\">this</span>.defaultBitmapConfig = defaultBitmapConfig;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> builtInHandlers = <span class=\"number\">7</span>; <span class=\"comment\">// Adjust this as internal handlers are added or removed.</span></div><div class=\"line\">    <span class=\"keyword\">int</span> extraCount = (extraRequestHandlers != <span class=\"keyword\">null</span> ? extraRequestHandlers.size() : <span class=\"number\">0</span>);</div><div class=\"line\">    List&lt;RequestHandler&gt; allRequestHandlers =</div><div class=\"line\">        <span class=\"keyword\">new</span> ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//添加各种加载不同图片地址的handler，如网络中的，resoure中的，相册，conteneprovider....</span></div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> ResourceRequestHandler(context));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (extraRequestHandlers != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      allRequestHandlers.addAll(extraRequestHandlers);</div><div class=\"line\">    &#125;</div><div class=\"line\">   \t<span class=\"comment\">//</span></div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> ContactsPhotoRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> MediaStoreRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> ContentStreamRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> AssetRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> FileRequestHandler(context));</div><div class=\"line\">    allRequestHandlers.add(<span class=\"keyword\">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</div><div class=\"line\">    requestHandlers = Collections.unmodifiableList(allRequestHandlers);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.stats = stats;</div><div class=\"line\">    <span class=\"keyword\">this</span>.targetToAction = <span class=\"keyword\">new</span> WeakHashMap&lt;Object, Action&gt;();</div><div class=\"line\">    <span class=\"keyword\">this</span>.targetToDeferredRequestCreator = <span class=\"keyword\">new</span> WeakHashMap&lt;ImageView, DeferredRequestCreator&gt;();</div><div class=\"line\">    <span class=\"keyword\">this</span>.indicatorsEnabled = indicatorsEnabled;</div><div class=\"line\">    <span class=\"keyword\">this</span>.loggingEnabled = loggingEnabled;</div><div class=\"line\">    <span class=\"keyword\">this</span>.referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;Object&gt;();</div><div class=\"line\">   \t<span class=\"comment\">//初始化一个清除request的Thread</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.cleanupThread = <span class=\"keyword\">new</span> CleanupThread(referenceQueue, HANDLER);</div><div class=\"line\">    <span class=\"keyword\">this</span>.cleanupThread.start();</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>Picasso的构造函数中从Buidler中获取到使用者设置的额外参数设置添加到配置当中，并且赋值给各个变量。在allRequestHandlers维护着所有可能获取到图片的路径，包括网上获取，Drawable文件获取，Asset文件中的获取等等的取图方式，最后初始化一个清除request的Thread。在构造函数中初始化的内容是这些，接下来，我们在查看一下load()方法，我们挑选load(uri)即加载网络图片的来进行源码的探究：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.<span class=\"function\">java</div><div class=\"line\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">load</span><span class=\"params\">(Uri uri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RequestCreator(<span class=\"keyword\">this</span>, uri, <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>load(uri)的方法非常简单，即返回一个RequestCreator()，这个RequestCreator是所有load(…)方法的返回参数，我们得查看一下这个类的作用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">RequestCreator.<span class=\"function\">java </div><div class=\"line\"><span class=\"title\">RequestCreator</span><span class=\"params\">(Picasso picasso, Uri uri, <span class=\"keyword\">int</span> resourceId)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (picasso.shutdown) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">          <span class=\"string\">\"Picasso instance already shut down. Cannot submit new requests.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.picasso = picasso;</div><div class=\"line\">    <span class=\"comment\">//初始化Reques类</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.data = <span class=\"keyword\">new</span> Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">error</span><span class=\"params\">(<span class=\"keyword\">int</span> errorResId)</span></span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">placeholder</span><span class=\"params\">(<span class=\"keyword\">int</span> placeholderResId)</span> </span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">fit</span><span class=\"params\">()</span> </span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> targetWidth, <span class=\"keyword\">int</span> targetHeight)</span></span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">centerInside</span><span class=\"params\">()</span></span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestCreator <span class=\"title\">clearCenterCrop</span><span class=\"params\">()</span></span>&#123;...&#125;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>熟悉API的朋友就知道这些方法的具体作用，那么RequestCreator的作用在于在给target设置图片之前，读取用户一切对于目标target的操作，如：error图片的设置，加载过程中图片的设置，设置图片宽高等等，相当于一个预处理类的作用，然后把所有的参传递给Request。所以我们可以在调用into()方法之前将我们所有的要求设置到RequestCreator(Builder设计模式)。</p>\n<p>我们再看构造方法中初始化了一个Request.Builder()，进入源码中查看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request.<span class=\"function\">java</div><div class=\"line\">  <span class=\"title\">Builder</span><span class=\"params\">(Uri uri, <span class=\"keyword\">int</span> resourceId, Bitmap.Config bitmapConfig)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.uri = uri;</div><div class=\"line\">      <span class=\"keyword\">this</span>.resourceId = resourceId;</div><div class=\"line\">      <span class=\"keyword\">this</span>.config = bitmapConfig;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>Request.Builder所做的操作就是接收从RequestCreator传递过来参数</p>\n<p>into()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">RequestCreator.<span class=\"function\">java</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">into</span><span class=\"params\">(ImageView target, Callback callback)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> started = System.nanoTime();</div><div class=\"line\">  \t<span class=\"comment\">//是否为主线程</span></div><div class=\"line\">    checkMain();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Target must not be null.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//是否有图片资源，如果rui为空或者ResId为空，则取消request</span></div><div class=\"line\">  \t<span class=\"comment\">//uri != null || resourceId != 0</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!data.hasImage()) &#123;</div><div class=\"line\">      picasso.cancelRequest(target);</div><div class=\"line\">      <span class=\"comment\">//显示默认图片</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (setPlaceholder) &#123;</div><div class=\"line\">        setPlaceholder(target, getPlaceholderDrawable());</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高</span></div><div class=\"line\">  \t<span class=\"comment\">//掉用过这个方法后不能再调用resize()操作</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (deferred) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data.hasSize()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fit cannot be used with resize.\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">int</span> width = target.getWidth();</div><div class=\"line\">      <span class=\"keyword\">int</span> height = target.getHeight();</div><div class=\"line\">      <span class=\"keyword\">if</span> (width == <span class=\"number\">0</span> || height == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (setPlaceholder) &#123;</div><div class=\"line\">          setPlaceholder(target, getPlaceholderDrawable());</div><div class=\"line\">        &#125;</div><div class=\"line\">        picasso.defer(target, <span class=\"keyword\">new</span> DeferredRequestCreator(<span class=\"keyword\">this</span>, target, callback));</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//设置图片宽高</span></div><div class=\"line\">      data.resize(width, height);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//新建request</span></div><div class=\"line\">    Request request = createRequest(started);</div><div class=\"line\">  \t<span class=\"comment\">//新建requestKey，即得到一个唯一标识request的key</span></div><div class=\"line\">    String requestKey = createKey(request);</div><div class=\"line\">\t<span class=\"comment\">//是否从缓存中读取</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class=\"line\">      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class=\"line\">      <span class=\"comment\">//得到缓存中的图片并且取消请求</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        picasso.cancelRequest(target);</div><div class=\"line\">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</div><div class=\"line\">        <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class=\"string\">\"from \"</span> + MEMORY);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//回调接口</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          callback.onSuccess();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (setPlaceholder) &#123;</div><div class=\"line\">      setPlaceholder(target, getPlaceholderDrawable());</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//构造一个图片请求的动作</span></div><div class=\"line\">    Action action =</div><div class=\"line\">        <span class=\"keyword\">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</div><div class=\"line\">            errorDrawable, requestKey, tag, callback, noFade);</div><div class=\"line\">\t<span class=\"comment\">//添加到请求队列当中</span></div><div class=\"line\">    picasso.enqueueAndSubmit(action);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>在into()方法中主要的执行过程有如下几个步骤：</p>\n<ul>\n<li>检查运行的线程是否为主线程，如果不是抛异常，结束</li>\n<li>检查传入的uri或者resid等是否有图片资源，如果rui为空或者ResId为空，则取消request，结束</li>\n<li>检查deferred参数，deferred参数在设置fit()方法时候为true，fit()方法的作用是让图片的宽高恰好等于imageView的宽高，调用过这个方法后不能再调用resize()操作。</li>\n<li>新建Request，判断是是否拥有缓存，如果有则直接获取并且取消请求，调用setBitMap()为target设置图片，结束</li>\n<li>如果没有缓存，则会构造一个Action来处理请求，然后添加至线程池当中</li>\n</ul>\n<p><strong>小提示：</strong></p>\n<p>在其中 createRequest(long started)方法中，会有一个请求转换的过程，这个过程一句使用者是否使用而决定，for  example:如果使用者在其中某一个ImageView的展示中想使用一个baseUrl不同的地址，那么我们就可以实现RequestTransformer接口，并且重写transformRequest(request)来自主构建Request实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Piscasso.<span class=\"function\">java</div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">enqueueAndSubmit</span><span class=\"params\">(Action action)</span> </span>&#123;</div><div class=\"line\">    Object target = action.getTarget();</div><div class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</div><div class=\"line\">      <span class=\"comment\">// This will also check we are on the main thread.</span></div><div class=\"line\">      cancelExistingRequest(target);</div><div class=\"line\">      targetToAction.put(target, action);</div><div class=\"line\">    &#125;</div><div class=\"line\">    submit(action);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">submit</span><span class=\"params\">(Action action)</span> </span>&#123;</div><div class=\"line\">    dispatcher.dispatchSubmit(action);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>跟踪enqueueAndSubmit()最终调用到Dispatcher类当中，Dispatcher类所有的action操作(submit,cancel,pause.etc)，相关对应的逻辑处理完后会使用BitmapHunter来获取图片，BitmapHunter会最终回调Dispatcher的图片或是否成功的相关方法。</p>\n<p>简单看下Dispatcher的构造函数：</p>\n<p>Dispatcher.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dispatcher.<span class=\"function\">java</div><div class=\"line\"><span class=\"title\">Dispatcher</span><span class=\"params\">(Context context, ExecutorService service, Handler mainThreadHandler,</div><div class=\"line\">      Downloader downloader, Cache cache, Stats stats)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatcherThread = <span class=\"keyword\">new</span> DispatcherThread();</div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatcherThread.start();</div><div class=\"line\">    Utils.flushStackLocalLeaks(dispatcherThread.getLooper());</div><div class=\"line\">    <span class=\"keyword\">this</span>.context = context;</div><div class=\"line\">    <span class=\"keyword\">this</span>.service = service;</div><div class=\"line\">  \t<span class=\"comment\">//hunter的映射</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.hunterMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;String, BitmapHunter&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//失败Action的映射</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.failedActions = <span class=\"keyword\">new</span> WeakHashMap&lt;Object, Action&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//暂停Action的映射</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.pausedActions = <span class=\"keyword\">new</span> WeakHashMap&lt;Object, Action&gt;();</div><div class=\"line\">    <span class=\"keyword\">this</span>.pausedTags = <span class=\"keyword\">new</span> HashSet&lt;Object&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//DispatcherHandler初始化</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handler = <span class=\"keyword\">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"comment\">//下载类</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.downloader = downloader;</div><div class=\"line\">    <span class=\"keyword\">this</span>.mainThreadHandler = mainThreadHandler;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cache = cache;</div><div class=\"line\">    <span class=\"keyword\">this</span>.stats = stats;</div><div class=\"line\">    <span class=\"keyword\">this</span>.batch = <span class=\"keyword\">new</span> ArrayList&lt;BitmapHunter&gt;(<span class=\"number\">4</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.airplaneMode = Utils.isAirplaneModeOn(<span class=\"keyword\">this</span>.context);</div><div class=\"line\">    <span class=\"keyword\">this</span>.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);</div><div class=\"line\">    <span class=\"keyword\">this</span>.receiver = <span class=\"keyword\">new</span> NetworkBroadcastReceiver(<span class=\"keyword\">this</span>);</div><div class=\"line\">    receiver.register();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchSubmit</span><span class=\"params\">(Action action)</span> </span>&#123;</div><div class=\"line\">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Dispatcher dispatcher;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DispatcherHandler</span><span class=\"params\">(Looper looper, Dispatcher dispatcher)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>(looper);</div><div class=\"line\">      <span class=\"keyword\">this</span>.dispatcher = dispatcher;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_SUBMIT: &#123;</div><div class=\"line\">          Action action = (Action) msg.obj;</div><div class=\"line\">          dispatcher.performSubmit(action);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_CANCEL: &#123;</div><div class=\"line\">          Action action = (Action) msg.obj;</div><div class=\"line\">          dispatcher.performCancel(action);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> TAG_PAUSE: &#123;</div><div class=\"line\">          Object tag = msg.obj;</div><div class=\"line\">          dispatcher.performPauseTag(tag);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> TAG_RESUME: &#123;</div><div class=\"line\">          Object tag = msg.obj;</div><div class=\"line\">          dispatcher.performResumeTag(tag);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_COMPLETE: &#123;</div><div class=\"line\">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class=\"line\">          dispatcher.performComplete(hunter);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_RETRY: &#123;</div><div class=\"line\">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class=\"line\">          dispatcher.performRetry(hunter);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_DECODE_FAILED: &#123;</div><div class=\"line\">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class=\"line\">          dispatcher.performError(hunter, <span class=\"keyword\">false</span>);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_DELAY_NEXT_BATCH: &#123;</div><div class=\"line\">          dispatcher.performBatchComplete();</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> NETWORK_STATE_CHANGE: &#123;</div><div class=\"line\">          NetworkInfo info = (NetworkInfo) msg.obj;</div><div class=\"line\">          dispatcher.performNetworkStateChange(info);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> AIRPLANE_MODE_CHANGE: &#123;</div><div class=\"line\">          dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON);</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">          Picasso.HANDLER.post(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Unknown handler message received: \"</span> + msg.what);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>在初始化方法中，核心就是DispatcherHandler初始化，DispatcherHandler负责将消息进行传递调用diapatcher相应的方法，以Msg=REQUEST_SUBMIT为例，那么就会调用dispatcher.performSubmit(action)，dispatcher.performSubmit(action)方法如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dispatcher.<span class=\"function\">java</div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">performSubmit</span><span class=\"params\">(Action action, <span class=\"keyword\">boolean</span> dismissFailed)</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">//暂停标识</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class=\"line\">      pausedActions.put(action.getTarget(), action);</div><div class=\"line\">      <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class=\"line\">            <span class=\"string\">\"because tag '\"</span> + action.getTag() + <span class=\"string\">\"' is paused\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class=\"line\">    <span class=\"keyword\">if</span> (hunter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      hunter.attach(action);</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (service.isShutdown()) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class=\"string\">\"because shut down\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    hunter = forRequest(action.getPicasso(), <span class=\"keyword\">this</span>, cache, stats, action);</div><div class=\"line\">    hunter.future = service.submit(hunter);</div><div class=\"line\">    hunterMap.put(action.getKey(), hunter);</div><div class=\"line\">    <span class=\"keyword\">if</span> (dismissFailed) &#123;</div><div class=\"line\">      failedActions.remove(action.getTarget());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这个方法的逻辑如下:</p>\n<ol>\n<li>暂停的tags中是否包含当前action的tag，有的话则return，否则继续下一步</li>\n<li>hunterMap中是否已经包含了相同的hunter，如果有则attach()到hunter中，return；否则继续下一步</li>\n<li>线程池是否shutDown，有则return，没有继续下一步</li>\n<li>通过forRequest()方法获得一个request，并且添加到线程池service中</li>\n</ol>\n<p>在forRequest()方法中主要获取对应的RequestHandler处理类，这里类似于责任链的设计模式，通过依次传递request给各个handler来找到对应的匹配的RequestHandler。</p>\n<p>BitmapHunter是主要的图片处理类，在BitmapHunter中会判断是从网络中还是缓存中获取图片,由于BitmapHunter本身是线程类，且无论从缓存中取数据还是从网络中取数据都是耗时操作，所以才引申除了线程池service这个类来进行执行runnable，查看下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">BitmapHunter.<span class=\"function\">java</div><div class=\"line\"><span class=\"keyword\">static</span> BitmapHunter <span class=\"title\">forRequest</span><span class=\"params\">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</div><div class=\"line\">      Action action)</span> </span>&#123;</div><div class=\"line\">    Request request = action.getRequest();</div><div class=\"line\">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Index-based loop to avoid allocating an iterator.</span></div><div class=\"line\">    <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</div><div class=\"line\">      RequestHandler requestHandler = requestHandlers.get(i);</div><div class=\"line\">      <span class=\"keyword\">if</span> (requestHandler.canHandleRequest(request)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</div><div class=\"line\">  &#125;</div><div class=\"line\">....</div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">//更新县城名字</span></div><div class=\"line\">      updateThreadName(data);</div><div class=\"line\">      <span class=\"comment\">//核心方法</span></div><div class=\"line\">      result = hunt();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        dispatcher.dispatchComplete(<span class=\"keyword\">this</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//各种异常的捕获处理</span></div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Downloader.ResponseException e) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!e.localCacheOnly || e.responseCode != <span class=\"number\">504</span>) &#123;</div><div class=\"line\">        exception = e;</div><div class=\"line\">      &#125;</div><div class=\"line\">      dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NetworkRequestHandler.ContentLengthException e) &#123;</div><div class=\"line\">      exception = e;</div><div class=\"line\">      dispatcher.dispatchRetry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">      exception = e;</div><div class=\"line\">      dispatcher.dispatchRetry(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError e) &#123;</div><div class=\"line\">      StringWriter writer = <span class=\"keyword\">new</span> StringWriter();</div><div class=\"line\">      stats.createSnapshot().dump(<span class=\"keyword\">new</span> PrintWriter(writer));</div><div class=\"line\">      exception = <span class=\"keyword\">new</span> RuntimeException(writer.toString(), e);</div><div class=\"line\">      dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">      exception = e;</div><div class=\"line\">      dispatcher.dispatchFailed(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>BitmapHunter.run()方法中主要通过调用hunt()方法获取到Bitmap，此时会对result进行判断的操作，如果为空则回调dispatcher.dispatchFailed()，不为空则调用dispatcher.dispatchComplete()方法，并且捕获异常，根据相关的异常来对应回调到dispatcher不同的方法中。</p>\n<p>BitmapHunter.hunt()方法详解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Bitmap <span class=\"title\">hunt</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">    Bitmap bitmap = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"comment\">//是否从缓存读取</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class=\"line\">      bitmap = cache.get(key);</div><div class=\"line\">      <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        stats.dispatchCacheHit();</div><div class=\"line\">        loadedFrom = MEMORY;</div><div class=\"line\">        <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), <span class=\"string\">\"from cache\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">//网络读取</span></div><div class=\"line\">    data.networkPolicy = retryCount == <span class=\"number\">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</div><div class=\"line\">    RequestHandler.Result result = requestHandler.load(data, networkPolicy);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      loadedFrom = result.getLoadedFrom();</div><div class=\"line\">      exifRotation = result.getExifOrientation();</div><div class=\"line\"></div><div class=\"line\">      bitmap = result.getBitmap();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// If there was no Bitmap then we need to decode it from the stream.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (bitmap == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        InputStream is = result.getStream();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          bitmap = decodeStream(is, data);</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          Utils.closeQuietly(is);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</div><div class=\"line\">      &#125;</div><div class=\"line\">      stats.dispatchBitmapDecoded(bitmap);</div><div class=\"line\">      <span class=\"keyword\">if</span> (data.needsTransformation() || exifRotation != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (DECODE_LOCK) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (data.needsMatrixTransform() || exifRotation != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            bitmap = transformResult(data, bitmap, exifRotation);</div><div class=\"line\">            <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">if</span> (data.hasCustomTransformations()) &#123;</div><div class=\"line\">            bitmap = applyCustomTransformations(data.transformations, bitmap);</div><div class=\"line\">            <span class=\"keyword\">if</span> (picasso.loggingEnabled) &#123;</div><div class=\"line\">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), <span class=\"string\">\"from custom transformations\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (bitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          stats.dispatchBitmapTransformed(bitmap);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>hunt()方法过程如下：</p>\n<ol>\n<li><p>从缓存里面找到对应的图片，有则返回，没有则玩下走；</p>\n</li>\n<li><p>将Request交付给对应的RequestHandler.load()来获取到图片，并且判断是否需要加工(needsTransformation</p>\n<p>()),需要则转换图片后再返回Bitmap</p>\n</li>\n</ol>\n<p>回到BitmapHunter.createRequest()，最终过程都会调用到dispatcher.dispatchComplete(this)和dispatcher.dispatchFailed(this)，而这两个方法会调用到dispatcher.performBatchComplete()中。</p>\n<p>附：</p>\n<ul>\n<li>dispatcher.dispatchRetry(this)：主要对requset进行重新请求操作，会再次执行一次获取图片的过程</li>\n<li>dispatcher.dispatchComplete(this)：最终调用performBatchComplete()对主线程发送一个承载着List<BitmapHunter>的msg</li>\n<li>dispatcher.dispatchFailed(this)：最终调用performBatchComplete()对主线程发送一个承载着List<BitmapHunter>的msg</li>\n</ul>\n<p>在其中又会将HUNTER_BATCH_COMPLETE这个msg发送给主线程的handler，即在Picasso.java中初始化的HANDLER:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dispatcher.<span class=\"function\">java</div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">performBatchComplete</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    List&lt;BitmapHunter&gt; copy = <span class=\"keyword\">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class=\"line\">    batch.clear();</div><div class=\"line\">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class=\"line\">    logBatch(copy);</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">performError</span><span class=\"params\">(BitmapHunter hunter, <span class=\"keyword\">boolean</span> willReplay)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter),</div><div class=\"line\">          <span class=\"string\">\"for error\"</span> + (willReplay ? <span class=\"string\">\" (will replay)\"</span> : <span class=\"string\">\"\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">    hunterMap.remove(hunter.getKey());</div><div class=\"line\">    batch(hunter);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Picasso.java</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Handler HANDLER = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class=\"line\">          <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class=\"line\">          <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class=\"line\">            BitmapHunter hunter = batch.get(i);</div><div class=\"line\">            hunter.picasso.complete(hunter);</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_GCED: &#123;</div><div class=\"line\">          Action action = (Action) msg.obj;</div><div class=\"line\">          <span class=\"keyword\">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class=\"line\">            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), <span class=\"string\">\"target got garbage collected\"</span>);</div><div class=\"line\">          &#125;</div><div class=\"line\">          action.picasso.cancelExistingRequest(action.getTarget());</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">case</span> REQUEST_BATCH_RESUME:</div><div class=\"line\">          <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) List&lt;Action&gt; batch = (List&lt;Action&gt;) msg.obj;</div><div class=\"line\">          <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class=\"line\">            Action action = batch.get(i);</div><div class=\"line\">            action.picasso.resumeAction(action);</div><div class=\"line\">          &#125;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Unknown handler message received: \"</span> + msg.what);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure>\n<p>hunter.picasso.complete(hunter)方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">Picasso.<span class=\"function\">java </div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(BitmapHunter hunter)</span> </span>&#123;</div><div class=\"line\">    Action single = hunter.getAction();</div><div class=\"line\">    List&lt;Action&gt; joined = hunter.getActions();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">boolean</span> hasMultiple = joined != <span class=\"keyword\">null</span> &amp;&amp; !joined.isEmpty();</div><div class=\"line\">    <span class=\"keyword\">boolean</span> shouldDeliver = single != <span class=\"keyword\">null</span> || hasMultiple;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!shouldDeliver) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Uri uri = hunter.getData().uri;</div><div class=\"line\">    Exception exception = hunter.getException();</div><div class=\"line\">    Bitmap result = hunter.getResult();</div><div class=\"line\">    LoadedFrom from = hunter.getLoadedFrom();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (single != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      deliverAction(result, from, single);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (hasMultiple) &#123;</div><div class=\"line\">      <span class=\"comment\">//noinspection ForLoopReplaceableByForEach</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = joined.size(); i &lt; n; i++) &#123;</div><div class=\"line\">        Action join = joined.get(i);</div><div class=\"line\">        deliverAction(result, from, join);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span> &amp;&amp; exception != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      listener.onImageLoadFailed(<span class=\"keyword\">this</span>, uri, exception);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverAction</span><span class=\"params\">(Bitmap result, LoadedFrom from, Action action)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (action.isCancelled()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!action.willReplay()) &#123;</div><div class=\"line\">      targetToAction.remove(action.getTarget());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (from == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LoadedFrom cannot be null.\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      action.complete(result, from);</div><div class=\"line\">      <span class=\"keyword\">if</span> (loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), <span class=\"string\">\"from \"</span> + from);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      action.error();</div><div class=\"line\">      <span class=\"keyword\">if</span> (loggingEnabled) &#123;</div><div class=\"line\">        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>complete()方法中最终会调用action.complete(result, from)和action.error()来传递给对应的Action实现类，在这里我们选择的是ImageAction来查看对应方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">complete</span><span class=\"params\">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(</div><div class=\"line\">          String.format(<span class=\"string\">\"Attempted to complete action with no result!\\n%s\"</span>, <span class=\"keyword\">this</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ImageView target = <span class=\"keyword\">this</span>.target.get();</div><div class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Context context = picasso.context;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class=\"line\">  \t<span class=\"comment\">//设置图片</span></div><div class=\"line\">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      callback.onSuccess();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ImageView target = <span class=\"keyword\">this</span>.target.get();</div><div class=\"line\">    <span class=\"keyword\">if</span> (target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//设置错误图片</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (errorResId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      target.setImageResource(errorResId);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errorDrawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      target.setImageDrawable(errorDrawable);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      callback.onError();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>到这里，基本上也结束了，对应的图片也展示到了Target中，基本的流程也就完成了</p>"},{"title":"android View的探索(一) : setContentView()过程研究","date":"2016-12-09T07:56:36.000Z","_content":"这里开启一轮关于View的研究，主要选择View开始研究的原因是我愿意(ง •̀_•́)ง,！在深入了解View的过程中，主要有两个目的，其一是整理一下以前对于View的认识且纠正一下错思维误区，其二是更深入了解其运行原理以备日后能够侃侃而谈骗基友。\n<!--more-->\n------\n###下面进入正题：setContentView()\n首先从最宏观的角度来说，我们在学习android的过程中第一次遇到关于View方法就是setContentView()，随着学习的加深，我们发现当代码中要实例化一个View的时候，很多时候是通过LayoutInflater来进行的，那为什么setContentView()不需要通过这种方式？\n\n为啥不需要，就是我们这篇文章要研究的内容，so read the fucking code。\n\n-----\n\n```java\n   ---- Acvtivity.java ----\n\n   public void setContentView(@LayoutRes int layoutResID) {\n       getWindow().setContentView(layoutResID);\n       initWindowDecorActionBar();\n   }\n​\nfinal void attach(Context context, ActivityThread aThread,\n           Instrumentation instr, IBinder token, int ident,\n           Application application, Intent intent, ActivityInfo info,\n           CharSequence title, Activity parent, String id,\n           NonConfigurationInstances lastNonConfigurationInstances,\n           Configuration config, String referrer, IVoiceInteractor voiceInteractor) {\n       attachBaseContext(context);\n       mFragments.attachHost(null /*parent*/);\n       mWindow = new PhoneWindow(this);\n       mWindow.setCallback(this);\n       mWindow.setOnWindowDismissedCallback(this);\n       mWindow.getLayoutInflater().setPrivateFactory(this);\n       if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {\n           mWindow.setSoftInputMode(info.softInputMode);\n       }\n       if (info.uiOptions != 0) {\n           mWindow.setUiOptions(info.uiOptions);\n       }\n     ....\n   }\n```\n上述代码来源于最基础的Activity类，我们从最基本的看起即可，在代码可以看到主要做了两个操作：\n> 获取window进行设置contentView\n\n> 初始化ActionBar\n\n从上方我们可以推测，初始化contentView的过程，其实是在window中进行的，而这个window的具体实现则是PhoneWindow,在Activity的attach方法中我们可以知道，因此需要进入的PhoneWindow中过去查看setContentView()：\n\n```java\n   ---- PhoneWindow.java ----\n\n​\n// This is the view in which the window contents are placed. It is either\n   // mDecor itself, or a child of mDecor where the contents go.\n   private ViewGroup mContentParent;\n // This is the top-level view of the window, containing the window decor.\n   private DecorView mDecor;\n@Override\n   public void setContentView(int layoutResID) {\n       if (mContentParent == null) {\n         //初始化DecorView\n           installDecor();\n       } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n           mContentParent.removeAllViews();\n       }\n​\n       if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n           final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                   getContext());\n           transitionTo(newScene);\n       } else {\n         //调用inflate初始化\n           mLayoutInflater.inflate(layoutResID, mContentParent);\n\n       }\n       mContentParent.requestApplyInsets();\n       final Callback cb = getCallback();\n       if (cb != null && !isDestroyed()) {\n           cb.onContentChanged();\n       }\n   }\n```\n在上述代码中FEATURE_CONTENT_TRANSITIONS是5.0增加的一个标识来识别是否进行实现Activity或者Fragment切换时的异常复杂的动画效果，我们可以省略来进行代码分析:\n> installDecor()，初始化DecorView以及mContentParent操作\n\n> 调用LayoutInflater.inflate()方法初始化布局\n\n```java\n   ---- PhoneWindow.java ----\n\n​\n     private void installDecor() {\n       if (mDecor == null) {\n         //此方法new了一个DecorView\n           mDecor = generateDecor();\n           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n           mDecor.setIsRootNamespace(true);\n           if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n           }\n       }\n       if (mContentParent == null) {\n         //进行mContentParent初始化的过程\n           mContentParent = generateLayout(mDecor);\n​\n           // Set up decor part of UI to ignore fitsSystemWindows if appropriate.\n           mDecor.makeOptionalFitsSystemWindows();\n           ...\n   }\n```\n在DecorView和mContentParent初始化完成后，系统再调用inflate()方法来进行布局的初始化的过程，我们需要知道具体是哪个LayoutInflater来完成工作的:\n```java\n // PhoneWindow.java ----\n\npublic PhoneWindow(Context context) {\n       super(context);\n       mLayoutInflater = LayoutInflater.from(context);\n   }\n //LayoutInflater.java ----\n\n public static LayoutInflater from(Context context) {\n       LayoutInflater LayoutInflater =\n               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n       if (LayoutInflater == null) {\n           throw new AssertionError(\"LayoutInflater not found.\");\n       }\n       return LayoutInflater;\n   }\n//ContextImpl.java\n\n@Override\n   public Object getSystemService(String name) {\n       return SystemServiceRegistry.getSystemService(this, name);\n\n   }\n//SystemServiceRegistry\n\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n               new CachedServiceFetcher<LayoutInflater>() {\n           @Override\n           public LayoutInflater createService(ContextImpl ctx) {\n               return new PhoneLayoutInflater(ctx.getOuterContext());\n\n           }});\n```\n我们看到inflater的初始化来自于from方法，这在我们撸代码的时候其实也经常会那么写，但是点到进去会发现是个抽象类，而inflater由context.getSystemService()获取，由于context的具体实现类是ContextImpl，我们再一次追溯，知道在SystemServiceRegistry中找到了具体实现类：PhoneLayoutInflater。\n接着我们回溯到PhoneWindow的mLayoutInflater.inflate(layoutResID, mContentParent)，其实到这步就已经跟我们在布局中使用LayoutInflater的效果一样了。\nbut，我们要有好奇心，点进去看看我们跳回inflate()这个方法,跳回PhoneLayoutInflater中进行查看，发现里面并没有inflate方法，那只能重新回到LayoutInflater.java中了，发现找了半天并没有什么卵用，不过了解到LayoutInlfater的具体实现是PhoneLayoutInflater对我们也是很有帮助的=￣ω￣=。\n````java\n//LayoutInflater.java\n\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n   //获取资源文件\n\n       final Resources res = getContext().getResources();\n\n       if (DEBUG) {\n           Log.d(TAG, \"INFLATING from resource: \\\"\" + res.getResourceName(resource) + \"\\\" (\"\n                   + Integer.toHexString(resource) + \")\");\n       }\n  //获取xml解析器XmlResourceParser\n\n       final XmlResourceParser parser = res.getLayout(resource);\n\n       try {\n          //返回解析后得到的View\n\n           return inflate(parser, root, attachToRoot);\n\n       } finally {\n           parser.close();\n       }\n   }\n```\n最终还是比较简单的，我们在inflate中看到，其实获得XmlResourceParser解析器，然后将布局文件添加到了根布局当中。\n\n等等最后还有一个方法：\n```java\n//PhoneWindow.java\nfinal Callback cb = getCallback();\nif (cb != null && !isDestroyed()) {  \n  cb.onContentChanged();\n}\n```\n这个callback是干哈用的，点进去：\n```java\n public void setCallback(Callback callback) {\n\n       mCallback = callback;\n   }\n​\n   /**\n     * Return the current Callback interface for this window.\n     */\n   public final Callback getCallback() {\n       return mCallback;\n   }\n```\n我们只能找到setCallBack()这个方法的具体位置，我们在上面的activity找到了window=new PhoneWindow()这个实现:\n```java\n//activity\nfinal void attach(Context context, ActivityThread aThread,\n           Instrumentation instr, IBinder token, int ident,\n           Application application, Intent intent, ActivityInfo info,\n           CharSequence title, Activity parent, String id,\n           NonConfigurationInstances lastNonConfigurationInstances,\n           Configuration config, String referrer, IVoiceInteractor voiceInteractor) {\n       attachBaseContext(context);\n       mFragments.attachHost(null /*parent*/);\n       mWindow = new PhoneWindow(this);\n       mWindow.setCallback(this);\n       mWindow.setOnWindowDismissedCallback(this);\n       mWindow.getLayoutInflater().setPrivateFactory(this);\n       if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {\n           mWindow.setSoftInputMode(info.softInputMode);\n       }\n       if (info.uiOptions != 0) {\n           mWindow.setUiOptions(info.uiOptions);\n       }\n     ....\n   }\n```\n mWindow.setCallback(this)这句话是不是够了！嗯哼！那么 cb.onContentChanged()这个方法其实就是调用了在activity中的onContentChanged方法，这是通知ContentView发生改变的方法，我们可以重写进行一些你喜欢的操作。\n\n----\n\n####总结\n画张图吧，这样比较好理解：\n\n{% asset_img setcontentView.png setContentView()过程图 %}\n\n\n","source":"_posts/android-View的探索-一-setContentView-过程研究.md","raw":"---\ntitle: 'android View的探索(一) : setContentView()过程研究'\ndate: 2016-12-09 15:56:36\ntags: android\ncategories: Android源码研究\n---\n这里开启一轮关于View的研究，主要选择View开始研究的原因是我愿意(ง •̀_•́)ง,！在深入了解View的过程中，主要有两个目的，其一是整理一下以前对于View的认识且纠正一下错思维误区，其二是更深入了解其运行原理以备日后能够侃侃而谈骗基友。\n<!--more-->\n------\n###下面进入正题：setContentView()\n首先从最宏观的角度来说，我们在学习android的过程中第一次遇到关于View方法就是setContentView()，随着学习的加深，我们发现当代码中要实例化一个View的时候，很多时候是通过LayoutInflater来进行的，那为什么setContentView()不需要通过这种方式？\n\n为啥不需要，就是我们这篇文章要研究的内容，so read the fucking code。\n\n-----\n\n```java\n   ---- Acvtivity.java ----\n\n   public void setContentView(@LayoutRes int layoutResID) {\n       getWindow().setContentView(layoutResID);\n       initWindowDecorActionBar();\n   }\n​\nfinal void attach(Context context, ActivityThread aThread,\n           Instrumentation instr, IBinder token, int ident,\n           Application application, Intent intent, ActivityInfo info,\n           CharSequence title, Activity parent, String id,\n           NonConfigurationInstances lastNonConfigurationInstances,\n           Configuration config, String referrer, IVoiceInteractor voiceInteractor) {\n       attachBaseContext(context);\n       mFragments.attachHost(null /*parent*/);\n       mWindow = new PhoneWindow(this);\n       mWindow.setCallback(this);\n       mWindow.setOnWindowDismissedCallback(this);\n       mWindow.getLayoutInflater().setPrivateFactory(this);\n       if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {\n           mWindow.setSoftInputMode(info.softInputMode);\n       }\n       if (info.uiOptions != 0) {\n           mWindow.setUiOptions(info.uiOptions);\n       }\n     ....\n   }\n```\n上述代码来源于最基础的Activity类，我们从最基本的看起即可，在代码可以看到主要做了两个操作：\n> 获取window进行设置contentView\n\n> 初始化ActionBar\n\n从上方我们可以推测，初始化contentView的过程，其实是在window中进行的，而这个window的具体实现则是PhoneWindow,在Activity的attach方法中我们可以知道，因此需要进入的PhoneWindow中过去查看setContentView()：\n\n```java\n   ---- PhoneWindow.java ----\n\n​\n// This is the view in which the window contents are placed. It is either\n   // mDecor itself, or a child of mDecor where the contents go.\n   private ViewGroup mContentParent;\n // This is the top-level view of the window, containing the window decor.\n   private DecorView mDecor;\n@Override\n   public void setContentView(int layoutResID) {\n       if (mContentParent == null) {\n         //初始化DecorView\n           installDecor();\n       } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n           mContentParent.removeAllViews();\n       }\n​\n       if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n           final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                   getContext());\n           transitionTo(newScene);\n       } else {\n         //调用inflate初始化\n           mLayoutInflater.inflate(layoutResID, mContentParent);\n\n       }\n       mContentParent.requestApplyInsets();\n       final Callback cb = getCallback();\n       if (cb != null && !isDestroyed()) {\n           cb.onContentChanged();\n       }\n   }\n```\n在上述代码中FEATURE_CONTENT_TRANSITIONS是5.0增加的一个标识来识别是否进行实现Activity或者Fragment切换时的异常复杂的动画效果，我们可以省略来进行代码分析:\n> installDecor()，初始化DecorView以及mContentParent操作\n\n> 调用LayoutInflater.inflate()方法初始化布局\n\n```java\n   ---- PhoneWindow.java ----\n\n​\n     private void installDecor() {\n       if (mDecor == null) {\n         //此方法new了一个DecorView\n           mDecor = generateDecor();\n           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n           mDecor.setIsRootNamespace(true);\n           if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n           }\n       }\n       if (mContentParent == null) {\n         //进行mContentParent初始化的过程\n           mContentParent = generateLayout(mDecor);\n​\n           // Set up decor part of UI to ignore fitsSystemWindows if appropriate.\n           mDecor.makeOptionalFitsSystemWindows();\n           ...\n   }\n```\n在DecorView和mContentParent初始化完成后，系统再调用inflate()方法来进行布局的初始化的过程，我们需要知道具体是哪个LayoutInflater来完成工作的:\n```java\n // PhoneWindow.java ----\n\npublic PhoneWindow(Context context) {\n       super(context);\n       mLayoutInflater = LayoutInflater.from(context);\n   }\n //LayoutInflater.java ----\n\n public static LayoutInflater from(Context context) {\n       LayoutInflater LayoutInflater =\n               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n       if (LayoutInflater == null) {\n           throw new AssertionError(\"LayoutInflater not found.\");\n       }\n       return LayoutInflater;\n   }\n//ContextImpl.java\n\n@Override\n   public Object getSystemService(String name) {\n       return SystemServiceRegistry.getSystemService(this, name);\n\n   }\n//SystemServiceRegistry\n\nregisterService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,\n               new CachedServiceFetcher<LayoutInflater>() {\n           @Override\n           public LayoutInflater createService(ContextImpl ctx) {\n               return new PhoneLayoutInflater(ctx.getOuterContext());\n\n           }});\n```\n我们看到inflater的初始化来自于from方法，这在我们撸代码的时候其实也经常会那么写，但是点到进去会发现是个抽象类，而inflater由context.getSystemService()获取，由于context的具体实现类是ContextImpl，我们再一次追溯，知道在SystemServiceRegistry中找到了具体实现类：PhoneLayoutInflater。\n接着我们回溯到PhoneWindow的mLayoutInflater.inflate(layoutResID, mContentParent)，其实到这步就已经跟我们在布局中使用LayoutInflater的效果一样了。\nbut，我们要有好奇心，点进去看看我们跳回inflate()这个方法,跳回PhoneLayoutInflater中进行查看，发现里面并没有inflate方法，那只能重新回到LayoutInflater.java中了，发现找了半天并没有什么卵用，不过了解到LayoutInlfater的具体实现是PhoneLayoutInflater对我们也是很有帮助的=￣ω￣=。\n````java\n//LayoutInflater.java\n\npublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n   //获取资源文件\n\n       final Resources res = getContext().getResources();\n\n       if (DEBUG) {\n           Log.d(TAG, \"INFLATING from resource: \\\"\" + res.getResourceName(resource) + \"\\\" (\"\n                   + Integer.toHexString(resource) + \")\");\n       }\n  //获取xml解析器XmlResourceParser\n\n       final XmlResourceParser parser = res.getLayout(resource);\n\n       try {\n          //返回解析后得到的View\n\n           return inflate(parser, root, attachToRoot);\n\n       } finally {\n           parser.close();\n       }\n   }\n```\n最终还是比较简单的，我们在inflate中看到，其实获得XmlResourceParser解析器，然后将布局文件添加到了根布局当中。\n\n等等最后还有一个方法：\n```java\n//PhoneWindow.java\nfinal Callback cb = getCallback();\nif (cb != null && !isDestroyed()) {  \n  cb.onContentChanged();\n}\n```\n这个callback是干哈用的，点进去：\n```java\n public void setCallback(Callback callback) {\n\n       mCallback = callback;\n   }\n​\n   /**\n     * Return the current Callback interface for this window.\n     */\n   public final Callback getCallback() {\n       return mCallback;\n   }\n```\n我们只能找到setCallBack()这个方法的具体位置，我们在上面的activity找到了window=new PhoneWindow()这个实现:\n```java\n//activity\nfinal void attach(Context context, ActivityThread aThread,\n           Instrumentation instr, IBinder token, int ident,\n           Application application, Intent intent, ActivityInfo info,\n           CharSequence title, Activity parent, String id,\n           NonConfigurationInstances lastNonConfigurationInstances,\n           Configuration config, String referrer, IVoiceInteractor voiceInteractor) {\n       attachBaseContext(context);\n       mFragments.attachHost(null /*parent*/);\n       mWindow = new PhoneWindow(this);\n       mWindow.setCallback(this);\n       mWindow.setOnWindowDismissedCallback(this);\n       mWindow.getLayoutInflater().setPrivateFactory(this);\n       if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {\n           mWindow.setSoftInputMode(info.softInputMode);\n       }\n       if (info.uiOptions != 0) {\n           mWindow.setUiOptions(info.uiOptions);\n       }\n     ....\n   }\n```\n mWindow.setCallback(this)这句话是不是够了！嗯哼！那么 cb.onContentChanged()这个方法其实就是调用了在activity中的onContentChanged方法，这是通知ContentView发生改变的方法，我们可以重写进行一些你喜欢的操作。\n\n----\n\n####总结\n画张图吧，这样比较好理解：\n\n{% asset_img setcontentView.png setContentView()过程图 %}\n\n\n","slug":"android-View的探索-一-setContentView-过程研究","published":1,"updated":"2016-12-13T02:40:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwmz2w8g0002dgs6kotec2fu","content":"<p>这里开启一轮关于View的研究，主要选择View开始研究的原因是我愿意(ง •̀_•́)ง,！在深入了解View的过程中，主要有两个目的，其一是整理一下以前对于View的认识且纠正一下错思维误区，其二是更深入了解其运行原理以备日后能够侃侃而谈骗基友。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><p>###下面进入正题：setContentView()<br>首先从最宏观的角度来说，我们在学习android的过程中第一次遇到关于View方法就是setContentView()，随着学习的加深，我们发现当代码中要实例化一个View的时候，很多时候是通过LayoutInflater来进行的，那为什么setContentView()不需要通过这种方式？</p>\n<p>为啥不需要，就是我们这篇文章要研究的内容，so read the fucking code。</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">   ---- Acvtivity.java ----</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</div><div class=\"line\">       getWindow().setContentView(layoutResID);</div><div class=\"line\">       initWindowDecorActionBar();</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</span></span></div><div class=\"line\">           Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</div><div class=\"line\">           Application application, Intent intent, ActivityInfo info,</div><div class=\"line\">           CharSequence title, Activity parent, String id,</div><div class=\"line\">           NonConfigurationInstances lastNonConfigurationInstances,</div><div class=\"line\">           Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</div><div class=\"line\">       attachBaseContext(context);</div><div class=\"line\">       mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</div><div class=\"line\">       mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setOnWindowDismissedCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.getLayoutInflater().setPrivateFactory(<span class=\"keyword\">this</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</div><div class=\"line\">           mWindow.setSoftInputMode(info.softInputMode);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.uiOptions != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           mWindow.setUiOptions(info.uiOptions);</div><div class=\"line\">       &#125;</div><div class=\"line\">     ....</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>上述代码来源于最基础的Activity类，我们从最基本的看起即可，在代码可以看到主要做了两个操作：</p>\n<blockquote>\n<p>获取window进行设置contentView</p>\n<p>初始化ActionBar</p>\n</blockquote>\n<p>从上方我们可以推测，初始化contentView的过程，其实是在window中进行的，而这个window的具体实现则是PhoneWindow,在Activity的attach方法中我们可以知道，因此需要进入的PhoneWindow中过去查看setContentView()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">   ---- PhoneWindow.java ----</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\"><span class=\"comment\">// This is the view in which the window contents are placed. It is either</span></div><div class=\"line\">   <span class=\"comment\">// mDecor itself, or a child of mDecor where the contents go.</span></div><div class=\"line\">   <span class=\"keyword\">private</span> ViewGroup mContentParent;</div><div class=\"line\"> <span class=\"comment\">// This is the top-level view of the window, containing the window decor.</span></div><div class=\"line\">   <span class=\"keyword\">private</span> DecorView mDecor;</div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//初始化DecorView</span></div><div class=\"line\">           installDecor();</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">           mContentParent.removeAllViews();</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class=\"line\">                   getContext());</div><div class=\"line\">           transitionTo(newScene);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"comment\">//调用inflate初始化</span></div><div class=\"line\">           mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">       mContentParent.requestApplyInsets();</div><div class=\"line\">       <span class=\"keyword\">final</span> Callback cb = getCallback();</div><div class=\"line\">       <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</div><div class=\"line\">           cb.onContentChanged();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在上述代码中FEATURE_CONTENT_TRANSITIONS是5.0增加的一个标识来识别是否进行实现Activity或者Fragment切换时的异常复杂的动画效果，我们可以省略来进行代码分析:</p>\n<blockquote>\n<p>installDecor()，初始化DecorView以及mContentParent操作</p>\n<p>调用LayoutInflater.inflate()方法初始化布局</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">   ---- PhoneWindow.java ----</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//此方法new了一个DecorView</span></div><div class=\"line\">           mDecor = generateDecor();</div><div class=\"line\">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</div><div class=\"line\">           mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</div><div class=\"line\">           <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//进行mContentParent初始化的过程</span></div><div class=\"line\">           mContentParent = generateLayout(mDecor);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></div><div class=\"line\">           mDecor.makeOptionalFitsSystemWindows();</div><div class=\"line\">           ...</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在DecorView和mContentParent初始化完成后，系统再调用inflate()方法来进行布局的初始化的过程，我们需要知道具体是哪个LayoutInflater来完成工作的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">// PhoneWindow.java ----</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneWindow</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>(context);</div><div class=\"line\">       mLayoutInflater = LayoutInflater.from(context);</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"comment\">//LayoutInflater.java ----</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">       LayoutInflater LayoutInflater =</div><div class=\"line\">               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> LayoutInflater;</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//ContextImpl.java</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//SystemServiceRegistry</span></div><div class=\"line\"></div><div class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class=\"line\">               <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class=\"line\"></div><div class=\"line\">           &#125;&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们看到inflater的初始化来自于from方法，这在我们撸代码的时候其实也经常会那么写，但是点到进去会发现是个抽象类，而inflater由context.getSystemService()获取，由于context的具体实现类是ContextImpl，我们再一次追溯，知道在SystemServiceRegistry中找到了具体实现类：PhoneLayoutInflater。<br>接着我们回溯到PhoneWindow的mLayoutInflater.inflate(layoutResID, mContentParent)，其实到这步就已经跟我们在布局中使用LayoutInflater的效果一样了。<br>but，我们要有好奇心，点进去看看我们跳回inflate()这个方法,跳回PhoneLayoutInflater中进行查看，发现里面并没有inflate方法，那只能重新回到LayoutInflater.java中了，发现找了半天并没有什么卵用，不过了解到LayoutInlfater的具体实现是PhoneLayoutInflater对我们也是很有帮助的=￣ω￣=。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//LayoutInflater.java</div><div class=\"line\"></div><div class=\"line\">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class=\"line\">   //获取资源文件</div><div class=\"line\"></div><div class=\"line\">       final Resources res = getContext().getResources();</div><div class=\"line\"></div><div class=\"line\">       if (DEBUG) &#123;</div><div class=\"line\">           Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;</div><div class=\"line\">                   + Integer.toHexString(resource) + &quot;)&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">  //获取xml解析器XmlResourceParser</div><div class=\"line\"></div><div class=\"line\">       final XmlResourceParser parser = res.getLayout(resource);</div><div class=\"line\"></div><div class=\"line\">       try &#123;</div><div class=\"line\">          //返回解析后得到的View</div><div class=\"line\"></div><div class=\"line\">           return inflate(parser, root, attachToRoot);</div><div class=\"line\"></div><div class=\"line\">       &#125; finally &#123;</div><div class=\"line\">           parser.close();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>最终还是比较简单的，我们在inflate中看到，其实获得XmlResourceParser解析器，然后将布局文件添加到了根布局当中。</p>\n<p>等等最后还有一个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//PhoneWindow.java</span></div><div class=\"line\"><span class=\"keyword\">final</span> Callback cb = getCallback();</div><div class=\"line\"><span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;  </div><div class=\"line\">  cb.onContentChanged();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个callback是干哈用的，点进去：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCallback</span><span class=\"params\">(Callback callback)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       mCallback = callback;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">     * Return the current Callback interface for this window.</div><div class=\"line\">     */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Callback <span class=\"title\">getCallback</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> mCallback;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>我们只能找到setCallBack()这个方法的具体位置，我们在上面的activity找到了window=new PhoneWindow()这个实现:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//activity</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</span></span></div><div class=\"line\">           Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</div><div class=\"line\">           Application application, Intent intent, ActivityInfo info,</div><div class=\"line\">           CharSequence title, Activity parent, String id,</div><div class=\"line\">           NonConfigurationInstances lastNonConfigurationInstances,</div><div class=\"line\">           Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</div><div class=\"line\">       attachBaseContext(context);</div><div class=\"line\">       mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</div><div class=\"line\">       mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setOnWindowDismissedCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.getLayoutInflater().setPrivateFactory(<span class=\"keyword\">this</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</div><div class=\"line\">           mWindow.setSoftInputMode(info.softInputMode);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.uiOptions != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           mWindow.setUiOptions(info.uiOptions);</div><div class=\"line\">       &#125;</div><div class=\"line\">     ....</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p> mWindow.setCallback(this)这句话是不是够了！嗯哼！那么 cb.onContentChanged()这个方法其实就是调用了在activity中的onContentChanged方法，这是通知ContentView发生改变的方法，我们可以重写进行一些你喜欢的操作。</p>\n<hr>\n<p>####总结<br>画张图吧，这样比较好理解：</p>\n<img src=\"/2016/12/09/android-View的探索-一-setContentView-过程研究/setcontentView.png\" alt=\"setContentView()过程图\" title=\"setContentView()过程图\">\n","excerpt":"<p>这里开启一轮关于View的研究，主要选择View开始研究的原因是我愿意(ง •̀_•́)ง,！在深入了解View的过程中，主要有两个目的，其一是整理一下以前对于View的认识且纠正一下错思维误区，其二是更深入了解其运行原理以备日后能够侃侃而谈骗基友。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><p>###下面进入正题：setContentView()<br>首先从最宏观的角度来说，我们在学习android的过程中第一次遇到关于View方法就是setContentView()，随着学习的加深，我们发现当代码中要实例化一个View的时候，很多时候是通过LayoutInflater来进行的，那为什么setContentView()不需要通过这种方式？</p>\n<p>为啥不需要，就是我们这篇文章要研究的内容，so read the fucking code。</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">   ---- Acvtivity.java ----</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</div><div class=\"line\">       getWindow().setContentView(layoutResID);</div><div class=\"line\">       initWindowDecorActionBar();</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</div><div class=\"line\">           Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</div><div class=\"line\">           Application application, Intent intent, ActivityInfo info,</div><div class=\"line\">           CharSequence title, Activity parent, String id,</div><div class=\"line\">           NonConfigurationInstances lastNonConfigurationInstances,</div><div class=\"line\">           Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</div><div class=\"line\">       attachBaseContext(context);</div><div class=\"line\">       mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</div><div class=\"line\">       mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setOnWindowDismissedCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.getLayoutInflater().setPrivateFactory(<span class=\"keyword\">this</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</div><div class=\"line\">           mWindow.setSoftInputMode(info.softInputMode);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.uiOptions != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           mWindow.setUiOptions(info.uiOptions);</div><div class=\"line\">       &#125;</div><div class=\"line\">     ....</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>上述代码来源于最基础的Activity类，我们从最基本的看起即可，在代码可以看到主要做了两个操作：</p>\n<blockquote>\n<p>获取window进行设置contentView</p>\n<p>初始化ActionBar</p>\n</blockquote>\n<p>从上方我们可以推测，初始化contentView的过程，其实是在window中进行的，而这个window的具体实现则是PhoneWindow,在Activity的attach方法中我们可以知道，因此需要进入的PhoneWindow中过去查看setContentView()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">   ---- PhoneWindow.java ----</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\"><span class=\"comment\">// This is the view in which the window contents are placed. It is either</span></div><div class=\"line\">   <span class=\"comment\">// mDecor itself, or a child of mDecor where the contents go.</span></div><div class=\"line\">   <span class=\"keyword\">private</span> ViewGroup mContentParent;</div><div class=\"line\"> <span class=\"comment\">// This is the top-level view of the window, containing the window decor.</span></div><div class=\"line\">   <span class=\"keyword\">private</span> DecorView mDecor;</div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//初始化DecorView</span></div><div class=\"line\">           installDecor();</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">           mContentParent.removeAllViews();</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class=\"line\">                   getContext());</div><div class=\"line\">           transitionTo(newScene);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"comment\">//调用inflate初始化</span></div><div class=\"line\">           mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">       mContentParent.requestApplyInsets();</div><div class=\"line\">       <span class=\"keyword\">final</span> Callback cb = getCallback();</div><div class=\"line\">       <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</div><div class=\"line\">           cb.onContentChanged();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在上述代码中FEATURE_CONTENT_TRANSITIONS是5.0增加的一个标识来识别是否进行实现Activity或者Fragment切换时的异常复杂的动画效果，我们可以省略来进行代码分析:</p>\n<blockquote>\n<p>installDecor()，初始化DecorView以及mContentParent操作</p>\n<p>调用LayoutInflater.inflate()方法初始化布局</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">   ---- PhoneWindow.java ----</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//此方法new了一个DecorView</span></div><div class=\"line\">           mDecor = generateDecor();</div><div class=\"line\">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</div><div class=\"line\">           mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</div><div class=\"line\">           <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//进行mContentParent初始化的过程</span></div><div class=\"line\">           mContentParent = generateLayout(mDecor);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></div><div class=\"line\">           mDecor.makeOptionalFitsSystemWindows();</div><div class=\"line\">           ...</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在DecorView和mContentParent初始化完成后，系统再调用inflate()方法来进行布局的初始化的过程，我们需要知道具体是哪个LayoutInflater来完成工作的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">// PhoneWindow.java ----</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneWindow</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">super</span>(context);</div><div class=\"line\">       mLayoutInflater = LayoutInflater.from(context);</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"comment\">//LayoutInflater.java ----</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LayoutInflater <span class=\"title\">from</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">       LayoutInflater LayoutInflater =</div><div class=\"line\">               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (LayoutInflater == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"LayoutInflater not found.\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> LayoutInflater;</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//ContextImpl.java</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> SystemServiceRegistry.getSystemService(<span class=\"keyword\">this</span>, name);</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//SystemServiceRegistry</span></div><div class=\"line\"></div><div class=\"line\">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class=\"line\">               <span class=\"keyword\">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">createService</span><span class=\"params\">(ContextImpl ctx)</span> </span>&#123;</div><div class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class=\"line\"></div><div class=\"line\">           &#125;&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们看到inflater的初始化来自于from方法，这在我们撸代码的时候其实也经常会那么写，但是点到进去会发现是个抽象类，而inflater由context.getSystemService()获取，由于context的具体实现类是ContextImpl，我们再一次追溯，知道在SystemServiceRegistry中找到了具体实现类：PhoneLayoutInflater。<br>接着我们回溯到PhoneWindow的mLayoutInflater.inflate(layoutResID, mContentParent)，其实到这步就已经跟我们在布局中使用LayoutInflater的效果一样了。<br>but，我们要有好奇心，点进去看看我们跳回inflate()这个方法,跳回PhoneLayoutInflater中进行查看，发现里面并没有inflate方法，那只能重新回到LayoutInflater.java中了，发现找了半天并没有什么卵用，不过了解到LayoutInlfater的具体实现是PhoneLayoutInflater对我们也是很有帮助的=￣ω￣=。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//LayoutInflater.java</div><div class=\"line\"></div><div class=\"line\">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class=\"line\">   //获取资源文件</div><div class=\"line\"></div><div class=\"line\">       final Resources res = getContext().getResources();</div><div class=\"line\"></div><div class=\"line\">       if (DEBUG) &#123;</div><div class=\"line\">           Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;</div><div class=\"line\">                   + Integer.toHexString(resource) + &quot;)&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">  //获取xml解析器XmlResourceParser</div><div class=\"line\"></div><div class=\"line\">       final XmlResourceParser parser = res.getLayout(resource);</div><div class=\"line\"></div><div class=\"line\">       try &#123;</div><div class=\"line\">          //返回解析后得到的View</div><div class=\"line\"></div><div class=\"line\">           return inflate(parser, root, attachToRoot);</div><div class=\"line\"></div><div class=\"line\">       &#125; finally &#123;</div><div class=\"line\">           parser.close();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>最终还是比较简单的，我们在inflate中看到，其实获得XmlResourceParser解析器，然后将布局文件添加到了根布局当中。</p>\n<p>等等最后还有一个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//PhoneWindow.java</span></div><div class=\"line\"><span class=\"keyword\">final</span> Callback cb = getCallback();</div><div class=\"line\"><span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;  </div><div class=\"line\">  cb.onContentChanged();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个callback是干哈用的，点进去：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCallback</span><span class=\"params\">(Callback callback)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       mCallback = callback;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">     * Return the current Callback interface for this window.</div><div class=\"line\">     */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Callback <span class=\"title\">getCallback</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> mCallback;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>我们只能找到setCallBack()这个方法的具体位置，我们在上面的activity找到了window=new PhoneWindow()这个实现:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//activity</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</div><div class=\"line\">           Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</div><div class=\"line\">           Application application, Intent intent, ActivityInfo info,</div><div class=\"line\">           CharSequence title, Activity parent, String id,</div><div class=\"line\">           NonConfigurationInstances lastNonConfigurationInstances,</div><div class=\"line\">           Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</div><div class=\"line\">       attachBaseContext(context);</div><div class=\"line\">       mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</div><div class=\"line\">       mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.setOnWindowDismissedCallback(<span class=\"keyword\">this</span>);</div><div class=\"line\">       mWindow.getLayoutInflater().setPrivateFactory(<span class=\"keyword\">this</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</div><div class=\"line\">           mWindow.setSoftInputMode(info.softInputMode);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (info.uiOptions != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           mWindow.setUiOptions(info.uiOptions);</div><div class=\"line\">       &#125;</div><div class=\"line\">     ....</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p> mWindow.setCallback(this)这句话是不是够了！嗯哼！那么 cb.onContentChanged()这个方法其实就是调用了在activity中的onContentChanged方法，这是通知ContentView发生改变的方法，我们可以重写进行一些你喜欢的操作。</p>\n<hr>\n<p>####总结<br>画张图吧，这样比较好理解：</p>\n<img src=\"/2016/12/09/android-View的探索-一-setContentView-过程研究/setcontentView.png\" alt=\"setContentView()过程图\" title=\"setContentView()过程图\">"},{"title":"android View的探索(二) : View的形成过程","date":"2016-12-09T08:35:46.000Z","_content":"\n我们在设计项目的时候，经常会遇到一些奇奇怪怪的需求，在这些需求中，对于UI的需求更是占了大半部分，这时候我们就避免不了与View打交道，熟悉自定义View的旁友应该会将onMeasure()->onLayout->onDraw的调用过程烂熟于心。因此，为了在撸代码的时候更加的对VIew得心应手，我们有必要对其进行一个深入的了解，下面就从构造方法看起吧。\n<!--more-->\n\nView的构造方法如下：\n```java\npublic View(Context context) {\n\n       mContext = context;\n       mResources = context != null ? context.getResources() : null;\n       mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED;\n       ....\n\n           sCompatibilityDone = true;\n       }\n   }\n​\n public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n       this(context);\n​\n       final TypedArray a = context.obtainStyledAttributes(\n               attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);\n​\n       if (mDebugViewAttributes) {\n           saveAttributeData(attrs, a);\n       }\n​\n       Drawable background = null;\n​\n       ...\n\n       final int N = a.getIndexCount();\n       for (int i = 0; i < N; i++) {\n           int attr = a.getIndex(i);\n           switch (attr) {\n               //读取attr的参数\n               ...\n           }\n  //设置View的滚动模式\n       setOverScrollMode(overScrollMode);\n​\n       // Cache start/end user padding as we cannot fully resolve padding here (we dont have yet\n       // the resolved layout direction). Those cached values will be used later during padding\n       // resolution.\n       mUserPaddingStart = startPadding;\n       mUserPaddingEnd = endPadding;\n  //设置背景\n       if (background != null) {\n           setBackground(background);\n       }\n​\n       // setBackground above will record that padding is currently provided by the background.\n       // If we have padding specified via xml, record that here instead and use it.\n       mLeftPaddingDefined = leftPaddingDefined;\n       mRightPaddingDefined = rightPaddingDefined;\n​\n       ...\n   }\n\n```\n\n对于View的构造方法而言，在其中只是做了相关参数的初始化以及传入参数attr的数据的获取的操作，相对来说，并没有什么特别需要注意的地方，那我们直接查看到onMeasure中：\n\n```java\n /**\n\n     * <p>\n     * Measure the view and its content to determine the measured width and the\n     * measured height. This method is invoked by {@link #measure(int, int)} and\n     * should be overridden by subclasses to provide accurate and efficient\n     * measurement of their contents.\n     * </p>\n     *\n     * <p>\n     * <strong>CONTRACT:</strong> When overriding this method, you\n     * <em>must</em> call {@link #setMeasuredDimension(int, int)} to store the\n     * measured width and height of this view. Failure to do so will trigger an\n     * <code>IllegalStateException</code>, thrown by\n     * {@link #measure(int, int)}. Calling the superclass'\n     * {@link #onMeasure(int, int)} is a valid use.\n     * </p>\n     *\n     * <p>\n     * The base class implementation of measure defaults to the background size,\n     * unless a larger size is allowed by the MeasureSpec. Subclasses should\n     * override {@link #onMeasure(int, int)} to provide better measurements of\n     * their content.\n     * </p>\n     *\n     * <p>\n     * If this method is overridden, it is the subclass's responsibility to make\n     * sure the measured height and width are at least the view's minimum height\n     * and width ({@link #getSuggestedMinimumHeight()} and\n     * {@link #getSuggestedMinimumWidth()}).\n     * </p>\n     *\n   */\n     \n   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n       setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n               getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n   }\n   \n```\n\n在View注释中已经把onMeasure()解释得相当的完善了，我们可以在注释中获取一些信息：\n* onMeasure()方法中会测量其本身View以及包含内容的宽高\n\n* 当我们在子类中重写onMeasure()方法时，我们需要调用setMeasuredDimension(int, int)为这个View进行保存宽高\n\n* View默认的是background的大小\n\n```java\n\n/**\n\n     * Utility to return a default size. Uses the supplied size if the\n     * MeasureSpec imposed no constraints. Will get larger if allowed\n     * by the MeasureSpec.\n     *\n     * @param size Default size for this view\n     * @param measureSpec Constraints imposed by the parent\n     * @return The size this view should be.\n     */\npublic static int getDefaultSize(int size, int measureSpec) {\n       int result = size;\n       int specMode = MeasureSpec.getMode(measureSpec);\n       int specSize = MeasureSpec.getSize(measureSpec);\n​\n       switch (specMode) {\n       case MeasureSpec.UNSPECIFIED:\n           result = size;\n           break;\n       case MeasureSpec.AT_MOST:\n       case MeasureSpec.EXACTLY:\n           result = specSize;\n           break;\n       }\n       return result;\n   }\nprotected int getSuggestedMinimumWidth() {\n       return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());\n   }\nprotected int getSuggestedMinimumHeight() {\n       return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());\n​\n   }\n\n```\n\n在上述代码中，我们可以看到在getDefaultSize()方法中通过MeasureSpec来获得测量模式和大小(MeasureSpec代表一个32位的int值，高两位代表了specMode，低30位specSize)。specMode总共有三种()\n* MeasureSpec.UNSPECIFIED:父容器不对View有任何的影响，要多大就给多大\n\n* MeasureSpec.EXACTLY:父容器检测出View所需要的精确大小，这是View的最终大小就是specSize的值，其对应了match_parent模式\n\n* MeasureSpec.AT_MOST:父容器制定了可用大小，即specSize，View的大小不能大于这个值，对应wrap_content模式\n\n上述三种模式的说明来自于《android艺术开发探索》。在View的测量中，我们可以看到View的大小的测量跟设置的模式以及父布局是息息相关的，因此我们在进行自定义View的时候需要考虑到这两方面的因素。\n我们重新回溯到setMeasuredDimension()方法中：\n\n```java\nprotected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {\n\n       boolean optical = isLayoutModeOptical(this);\n       if (optical != isLayoutModeOptical(mParent)) {\n           Insets insets = getOpticalInsets();\n           int opticalWidth = insets.left + insets.right;\n           int opticalHeight = insets.top + insets.bottom;\n​\n           measuredWidth += optical ? opticalWidth : -opticalWidth;\n           measuredHeight += optical ? opticalHeight : -opticalHeight;\n       }\n       setMeasuredDimensionRaw(measuredWidth, measuredHeight);\n   }\n private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {\n       mMeasuredWidth = measuredWidth;\n       mMeasuredHeight = measuredHeight;\n​\n       mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;\n   }\n```\n在其中我们看到最终会将计算得到的宽高传给mMeasuredHeight和mMeasuredWidth。\n接下来在看看onLayout方法：\n```java\n /**\n\n     * Called from layout when this view should\n     * assign a size and position to each of its children.\n     *\n     * Derived classes with children should override\n     * this method and call layout on each of\n     * their children.\n     * @param changed This is a new size or position for this view\n     * @param left Left position, relative to parent\n     * @param top Top position, relative to parent\n     * @param right Right position, relative to parent\n     * @param bottom Bottom position, relative to parent\n     */\n   protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n   }\n```\nonLayout()是一个空实现的方法，从注释当中我们可以看到此方法更适用于ViewGroup，只有View是一个ViewGroup才需要考虑到layout的位置的问题。\n\n往下走，onDraw():\n```java\n/**\n\n     * Implement this to do your drawing.\n     *\n     * @param canvas the canvas on which the background will be drawn\n     */\n   protected void onDraw(Canvas canvas) {\n   }\n```\n同样是空实现，这里自定义View通过重写该方法来进行绘制的操作。\n\nViewRootIpml\n分析完上面的三个方法，我们更多地是看到一些赋值和空实现的方法，那么到底View的怎么开始绘制的过程的呢？这时候涉及到ViewRootIpml这个类了，它是连接View和WindowManager的桥梁，具体的作用是什么呢，我们从构建开始说起，一步步往下学习，首先我们找到其初始化的地方：\n```java\n//WindowManagerGlobal\n\n   public void addView(View view, ViewGroup.LayoutParams params,\n\n           Display display, Window parentWindow) {\n           ...\n\n​\n\n           ViewRootImpl root;\n           View panelParentView = null;\n\n           ...\n\n​\n\n           root = new ViewRootImpl(view.getContext(), display);\n​\n           view.setLayoutParams(wparams);\n​\n           mViews.add(view);\n           mRoots.add(root);\n           mParams.add(wparams);\n\n       }\n  try {\n\n           root.setView(view, wparams, panelParentView);\n       } catch (RuntimeException e) {\n           // BadTokenException or InvalidDisplayException, clean up.\n           synchronized (mLock) {\n               final int index = findViewLocked(view, false);\n               if (index >= 0) {\n                   removeViewLocked(index, true);\n               }\n           }\n           throw e;\n       }\n\n​\n       ...\n\n   }\n​\n```\n我们在WindowManager的实现类WindowManagerGlobal找到了其ViewRootImpl初始化的地方(关于WindowManager在以后会进行深入探讨，现在主要知道它是window窗口的管理类即可)，从addView()方法中我们推测其是将View添加到window的一个过程(addView这个方法在ActivityThread的handleResumeActivity()中实现)，然后又调用了ViewRootImpl的setView()方法：\n```java\n//ViewRootImpl\n\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n\n       synchronized (this) {\n           if (mView == null) {\n\n                 ...\n\n               requestLayout();\n\n              ...\n\n               }\n\n       }\n   }\n  @Override\n\n   public void requestLayout() {\n\n       if (!mHandlingLayoutInLayoutRequest) {\n           checkThread();\n           mLayoutRequested = true;\n           scheduleTraversals();\n\n       }\n\n   }\n\n   void scheduleTraversals() {\n\n           if (!mTraversalScheduled) {\n\n               mTraversalScheduled = true;\n               mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n               mChoreographer.postCallback(\n                       Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n               if (!mUnbufferedInputDispatch) {\n                   scheduleConsumeBatchedInput();\n               }\n               notifyRendererOfFramePending();\n               pokeDrawLockIfNeeded();\n           }\n       }\n   final class TraversalRunnable implements Runnable {\n\n           @Override\n           public void run() {\n               doTraversal();\n\n           }\n       }\n   void doTraversal() {\n           if (mTraversalScheduled) {\n               mTraversalScheduled = false;\n               mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n​\n               if (mProfile) {\n                   Debug.startMethodTracing(\"ViewAncestor\");\n               }\n​\n               performTraversals();\n\n​\n               if (mProfile) {\n                   Debug.stopMethodTracing();\n                   mProfile = false;\n               }\n           }\n       }\n  private void performTraversals() {\n\n        ...\n\n        performMeasure()；\n       ...\n       performLayout();\n\n        ...\n\n        performDraw();\n\n     }\n\n​\n```\n在这里我们可以看到当第一次进来的时候会设置mView的值，在其中调用了requestLayout()进行布局，然后依次是scheduleTraversals()->doTraversal()->performTraversals()的过程，在performTraversals()方法中调用了performMeasure(),performLayout(),performDraw()方法：\n```java\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n\n       Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\");\n       try {\n           mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n       } finally {\n           Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n       }\n   }\n  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,\n           int desiredWindowHeight) {\n         //当前mView是由WindowsManagerGlobal.addView传递过来，在ViewRootImpl中\n         //通过setView()获得到的。\n         final View host = mView;\n         ...\n           host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());\n   ...\n           \n        mInLayout = false;\n   }\n private void performDraw() {\n       if (mAttachInfo.mDisplayState == Display.STATE_OFF && !mReportNextDraw) {\n           return;\n       }\n​\n       final boolean fullRedrawNeeded = mFullRedrawNeeded;\n       mFullRedrawNeeded = false;\n​\n       mIsDrawing = true;\n       Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"draw\");\n       try {\n           draw(fullRedrawNeeded);\n       } finally {\n           mIsDrawing = false;\n           Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n       }\n\n           try {\n               mWindowSession.finishDrawing(mWindow);\n           } catch (RemoteException e) {\n           }\n       }\n   }\n private void draw(boolean fullRedrawNeeded) {\n\n       \n\n       ....\n\n         if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {\n\n           return;\n         }\n\n               \n\n       }\n\n       if (animating) {\n           mFullRedrawNeeded = true;\n           scheduleTraversals();\n       }\n   }\n​\n   /**\n     * @return true if drawing was successful, false if an error occurred\n     */\n   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n           boolean scalingRequired, Rect dirty) {\n​\n     \n\n       mView.draw(canvas);\n\n​\n         drawAccessibilityFocusedDrawableIfNeeded(canvas);\n\n           \n\n       return true;\n   }\n​\n```\n在上面我们最终可以看到，measure->layout->draw的过程最终回调到了View中的对应的是三个方法,所以我们重新回到View中研究一下这些方法,从measure()看起：\n```java\n/**\n\n     * <p>\n     * This is called to find out how big a view should be. The parent\n     * supplies constraint information in the width and height parameters.\n     * </p>\n     *\n     * <p>\n     * The actual measurement work of a view is performed in\n     * {@link #onMeasure(int, int)}, called by this method. Therefore, only\n     * {@link #onMeasure(int, int)} can and must be overridden by subclasses.\n     * </p>\n     *\n     *\n     * @param widthMeasureSpec Horizontal space requirements as imposed by the\n     *       parent\n     * @param heightMeasureSpec Vertical space requirements as imposed by the\n     *       parent\n     *\n     * @see #onMeasure(int, int)\n     */\n\npublic final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n\n       boolean optical = isLayoutModeOptical(this);\n\n   //是否采用视觉边界\n\n       if (optical != isLayoutModeOptical(mParent)) {\n\n           Insets insets = getOpticalInsets();\n\n           int oWidth = insets.left + insets.right;\n\n           int oHeight = insets.top + insets.bottom;\n           widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);\n           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);\n       }\n\n        ···\n\n       onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n       ···     \n\n   }\n```\n从注释中我们可以了解到，其实该方法是计算View树的宽高的最终方法，宽高由父布局和子布局共同决定，且该方法不允许子类进行相关操作，因为其是final的，子类想要设置宽高需要通过onMeasure()方法来进行。\n\n接下来我们再看下layout()方法：\n```java\n/**\n\n     * Assign a size and position to a view and all of its\n\n     * descendants\n     *\n     * <p>This is the second phase of the layout mechanism.\n     * (The first is measuring). In this phase, each parent calls\n     * layout on all of its children to position them.\n     * This is typically done using the child measurements\n     * that were stored in the measure pass().</p>\n     *\n     * <p>Derived classes should not override this method.\n     * Derived classes with children should override\n     * onLayout. In that method, they should\n     * call layout on each of their children.</p>\n     *\n     * @param l Left position, relative to parent\n     * @param t Top position, relative to parent\n     * @param r Right position, relative to parent\n     * @param b Bottom position, relative to parent\n     */\n   @SuppressWarnings({\"unchecked\"})\n   public void layout(int l, int t, int r, int b) {\n       if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {\n           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);\n           mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n       }\n​\n       int oldL = mLeft;\n       int oldT = mTop;\n       int oldB = mBottom;\n       int oldR = mRight;\n​\n       boolean changed = isLayoutModeOptical(mParent) ?\n               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);\n\n  //setFrame会判断是否需要重新布局，即如果我们在完成一次View展示后，重新设置View的大小，那么\n      //setFrame返回tru\n\n       if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n           onLayout(changed, l, t, r, b);\n\n           mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;\n​\n           ListenerInfo li = mListenerInfo;\n           if (li != null && li.mOnLayoutChangeListeners != null) {\n               ArrayList<OnLayoutChangeListener> listenersCopy =\n                       (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();\n               int numListeners = listenersCopy.size();\n               for (int i = 0; i < numListeners; ++i) {\n                   listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);\n               }\n           }\n       }\n​\n       mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;\n       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;\n   }\n```\n确认过大小后，我们需要定位View最终位置，在layout中会调用到onLayout()来获得我们需要展示的childrenView的效果。\ndraw()方法：\n```java\n/**\n\n     * Manually render this view (and all of its children) to the given Canvas.\n     * The view must have already done a full layout before this function is\n     * called. When implementing a view, implement\n     * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.\n     * If you do need to override this method, call the superclass version.\n     *\n     * @param canvas The Canvas to which the View is rendered.\n     */\n   @CallSuper\n   public void draw(Canvas canvas) {\n       final int privateFlags = mPrivateFlags;\n       final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&\n               (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);\n       mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;\n​\n       /*\n         * Draw traversal performs several drawing steps which must be executed\n         * in the appropriate order:\n         *\n         *     1. Draw the background\n         *     2. If necessary, save the canvas' layers to prepare for fading\n\n         *     3. Draw view's content\n\n         *     4. Draw children\n         *     5. If necessary, draw the fading edges and restore layers\n         *     6. Draw decorations (scrollbars for instance)\n         */\n​\n       // Step 1, draw the background, if needed\n       int saveCount;\n​\n       if (!dirtyOpaque) {\n           drawBackground(canvas);\n       }\n​\n       // skip step 2 & 5 if possible (common case)\n       final int viewFlags = mViewFlags;\n       boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;\n       boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;\n       if (!verticalEdges && !horizontalEdges) {\n           // Step 3, draw the content\n           if (!dirtyOpaque) onDraw(canvas);\n​\n           // Step 4, draw the children\n          //递归draw\n\n           dispatchDraw(canvas);\n​\n           // Overlay is part of the content and draws beneath Foreground\n           if (mOverlay != null && !mOverlay.isEmpty()) {\n               mOverlay.getOverlayView().dispatchDraw(canvas);\n           }\n​\n           // Step 6, draw decorations (foreground, scrollbars)\n           onDrawForeground(canvas);\n​\n           // we're done...\n           return;\n       }\n​\n```\n看代码注释就可以很轻松知道draw中的步骤，这里就不详细解释了。\n\n看到这里就对我们对View从哪里开始，并且如何一步步从测量绘制完成有了一个稍微深入的认识，画一个图先总结一下吧：\n\n{% asset_img one.png one %}\n\n但是我们只看到了绘制完成的部分，并没有看到View是怎么展示在我们面前的，想要知道View如何被调用再到绘制完成显示出来，这就牵扯到atcivity的启动的过程了，这里不对这方面进行讲解，详细的过程可以大概看下：\nhttp://www.jianshu.com/p/93c66b3f08d6 \n我写的这篇文章(写的比较乱，有时间整理一下=￣ω￣=)，本身我们就知道activity启动完成显示到手机上会执行到onResume()这个方法，这个方法可硬对应在ActivityThread中的handleResumeActivity():\n```java\n   final void handleResumeActivity(...){\n          ....\n           else if (!willBeVisible) {\n               if (localLOGV) Slog.v(\n                   TAG, \"Launch \" + r + \" mStartedActivity set\");\n               r.hideForNow = true;\n           }\n​\n           // Get rid of anything left hanging around.\n           cleanUpPendingRemoveWindows(r);\n​\n           // The window is now visible if it has been added, we are not\n           // simply finishing, and we are not starting another activity.\n           if (!r.activity.mFinished && willBeVisible\n                   && r.activity.mDecor != null && !r.hideForNow) {\n               if (r.newConfig != null) {\n                   r.tmpConfig.setTo(r.newConfig);\n                   if (r.overrideConfig != null) {\n                       r.tmpConfig.updateFrom(r.overrideConfig);\n                   }\n                   if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \"\n                           + r.activityInfo.name + \" with newConfig \" + r.tmpConfig);\n                   performConfigurationChanged(r.activity, r.tmpConfig);\n                   freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));\n                   r.newConfig = null;\n               }\n               if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\"\n                       + isForward);\n               WindowManager.LayoutParams l = r.window.getAttributes();\n               if ((l.softInputMode\n                       & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)\n                       != forwardBit) {\n                   l.softInputMode = (l.softInputMode\n                           & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))\n                           | forwardBit;\n                   if (r.activity.mVisibleFromClient) {\n                       ViewManager wm = a.getWindowManager();\n                       View decor = r.window.getDecorView();\n                       wm.updateViewLayout(decor, l);\n                   }\n               }\n               r.activity.mVisibleFromServer = true;\n               mNumVisibleActivities++;\n               if (r.activity.mVisibleFromClient) {\n                   r.activity.makeVisible();\n               }\n           }\n​\n           if (!r.onlyLocalRequest) {\n               r.nextIdle = mNewActivities;\n               mNewActivities = r;\n               if (localLOGV) Slog.v(\n                   TAG, \"Scheduling idle handler for \" + r);\n               Looper.myQueue().addIdleHandler(new Idler());\n           }\n           r.onlyLocalRequest = false;\n​\n           // Tell the activity manager we have resumed.\n           if (reallyResume) {\n               try {\n                   ActivityManagerNative.getDefault().activityResumed(token);\n               } catch (RemoteException ex) {\n               }\n           }\n​\n       } else {\n           // If an exception was thrown when trying to resume, then\n           // just end this activity.\n           try {\n               ActivityManagerNative.getDefault()\n                   .finishActivity(token, Activity.RESULT_CANCELED, null, false);\n           } catch (RemoteException ex) {\n           }\n       }\n   }\n```\n代码中有句 r.activity.makeVisible()就是展示的关键的代码，他会让DecorView变为Visibile状态，最终展示出来。\n\n-------\n####ViewGrop\n上面通过一系列的讲解只是从最简单的角度上而言——当页面中只有一个View的时候，但是绝大部分情况下是不可能的，往往项目中VIew树的层级是很深的(**这里建议使用RelativeLayout作为初始布局容器**)，那就涉及到ViewGroup了，其实ViewGroup也很简单，只不过多了一些递归的过程而已。\n\n这里选择FrameLayout来进行大概的讲述吧(因为好多文章用了LinearLayout，RelativeLayout我又嫌麻烦。。)，从onMeasure()开始看：\n```java\n  @Override\n\n   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n      //获取子View的数量\n\n       int count = getChildCount();\n  \n      //当前布局宽高否是match_parent\n       final boolean measureMatchParentChildren =\n               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||\n               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;\n       mMatchParentChildren.clear();\n​\n       int maxHeight = 0;\n       int maxWidth = 0;\n       int childState = 0;\n​\n       for (int i = 0; i < count; i++) {\n           final View child = getChildAt(i);\n          //GONE的布局不会进行测量\n\n           if (mMeasureAllChildren || child.getVisibility() != GONE) {\n              //测量时加上margin参数\n\n               measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);\n               final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n               maxWidth = Math.max(maxWidth,\n                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);\n               maxHeight = Math.max(maxHeight,\n                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);\n               childState = combineMeasuredStates(childState, child.getMeasuredState());\n               if (measureMatchParentChildren) {\n                   //子布局中是否由含match_parent的布局，有则添加到mMatchParentChildren中\n                   if (lp.width == LayoutParams.MATCH_PARENT ||\n                           lp.height == LayoutParams.MATCH_PARENT) {\n                       mMatchParentChildren.add(child);\n                   }\n               }\n           }\n       }\n​\n       // Account for padding too\n       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();\n       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();\n​\n       // Check against our minimum height and width\n       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());\n       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());\n​\n       // Check against our foreground's minimum height and width\n      //计算图片宽度，取图片宽高和最大宽高两者之间最大值\n\n       final Drawable drawable = getForeground();\n       if (drawable != null) {\n           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());\n           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());\n       }\n​\n       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),\n               resolveSizeAndState(maxHeight, heightMeasureSpec,\n                       childState << MEASURED_HEIGHT_STATE_SHIFT));​\n       count = mMatchParentChildren.size();\n\n      //这里对于子布局是match_parent的进行重新测量得到准确值\n       if (count > 1) {\n           for (int i = 0; i < count; i++) {\n               final View child = mMatchParentChildren.get(i);\n               final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n​\n               final int childWidthMeasureSpec;\n               if (lp.width == LayoutParams.MATCH_PARENT) {\n                   final int width = Math.max(0, getMeasuredWidth()\n                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()\n                           - lp.leftMargin - lp.rightMargin);\n                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(\n                           width, MeasureSpec.EXACTLY);\n               } else {\n                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,\n                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +\n                           lp.leftMargin + lp.rightMargin,\n                           lp.width);\n               }\n​\n               final int childHeightMeasureSpec;\n               if (lp.height == LayoutParams.MATCH_PARENT) {\n                   final int height = Math.max(0, getMeasuredHeight()\n                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()\n                           - lp.topMargin - lp.bottomMargin);\n                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(\n                           height, MeasureSpec.EXACTLY);\n               } else {\n                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,\n                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +\n                           lp.topMargin + lp.bottomMargin,\n                           lp.height);\n               }\n                //调用子布局的measure()方法\n               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n\n           }\n       }\n   }\n​\nprotected void measureChildWithMargins(View child,\n           int parentWidthMeasureSpec, int widthUsed,\n           int parentHeightMeasureSpec, int heightUsed) {\n       final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n​\n       final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                       + widthUsed, lp.width);\n       final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                       + heightUsed, lp.height);\n​            //调用子布局的measure()方法\n       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n   }\n```\n从onMeasure()可以看到主要的方法就是child.measure()的调用，他会调用到View的measure()，measure()又会重新调用onMeasure()由此形成依次递归直到获取到正确的测量结果。\n\nonLayout()方法：\n```java\n   @Override\n\n   protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n       layoutChildren(left, top, right, bottom, false /* no force left gravity */);\n   }\n​\n   void layoutChildren(int left, int top, int right, int bottom,\n                                 boolean forceLeftGravity) {\n       final int count = getChildCount();\n​\n       final int parentLeft = getPaddingLeftWithForeground();\n       final int parentRight = right - left - getPaddingRightWithForeground();\n​\n       final int parentTop = getPaddingTopWithForeground();\n       final int parentBottom = bottom - top - getPaddingBottomWithForeground();\n​\n       for (int i = 0; i < count; i++) {\n           final View child = getChildAt(i);\n           if (child.getVisibility() != GONE) {\n               final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n​\n               final int width = child.getMeasuredWidth();\n               final int height = child.getMeasuredHeight();\n​\n               int childLeft;\n               int childTop;\n​\n               int gravity = lp.gravity;\n               if (gravity == -1) {\n                   gravity = DEFAULT_CHILD_GRAVITY;\n               }\n​\n               final int layoutDirection = getLayoutDirection();\n               final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n               final int verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;\n​\n               switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n                   case Gravity.CENTER_HORIZONTAL:\n                       childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +\n                       lp.leftMargin - lp.rightMargin;\n                       break;\n                   case Gravity.RIGHT:\n                       if (!forceLeftGravity) {\n                           childLeft = parentRight - width - lp.rightMargin;\n                           break;\n                       }\n                   case Gravity.LEFT:\n                   default:\n                       childLeft = parentLeft + lp.leftMargin;\n               }\n​\n               switch (verticalGravity) {\n                   case Gravity.TOP:\n                       childTop = parentTop + lp.topMargin;\n                       break;\n                   case Gravity.CENTER_VERTICAL:\n                       childTop = parentTop + (parentBottom - parentTop - height) / 2 +\n                       lp.topMargin - lp.bottomMargin;\n                       break;\n                   case Gravity.BOTTOM:\n                       childTop = parentBottom - height - lp.bottomMargin;\n                       break;\n                   default:\n                       childTop = parentTop + lp.topMargin;\n               }\n​              //调用子View的layout\n               child.layout(childLeft, childTop, childLeft + width, childTop + height);\n           }\n       }\n   }\n​\n```\n可以看到layout也是一个递归调用的过程，这里就不详细讲述了，而由于ViewGroup没有onDraw()方法，这里就不需要讲了。\n\n附上一张View的生命周期:\n{% asset_img two.jpg cyclelife %}\n\n\n-----\n\n终于写完了，脑袋都要爆炸了，View形成的过程大概就是这样的，谢谢阅读，如果觉得哪写的不对或者不好的地方欢迎留言交流，希望能够一起进步~","source":"_posts/android-View的探索-二-View的形成过程.md","raw":"---\ntitle: 'android View的探索(二) : View的形成过程'\ndate: 2016-12-09 16:35:46\ntags: android\ncategories: Android源码研究\n---\n\n我们在设计项目的时候，经常会遇到一些奇奇怪怪的需求，在这些需求中，对于UI的需求更是占了大半部分，这时候我们就避免不了与View打交道，熟悉自定义View的旁友应该会将onMeasure()->onLayout->onDraw的调用过程烂熟于心。因此，为了在撸代码的时候更加的对VIew得心应手，我们有必要对其进行一个深入的了解，下面就从构造方法看起吧。\n<!--more-->\n\nView的构造方法如下：\n```java\npublic View(Context context) {\n\n       mContext = context;\n       mResources = context != null ? context.getResources() : null;\n       mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED;\n       ....\n\n           sCompatibilityDone = true;\n       }\n   }\n​\n public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n       this(context);\n​\n       final TypedArray a = context.obtainStyledAttributes(\n               attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);\n​\n       if (mDebugViewAttributes) {\n           saveAttributeData(attrs, a);\n       }\n​\n       Drawable background = null;\n​\n       ...\n\n       final int N = a.getIndexCount();\n       for (int i = 0; i < N; i++) {\n           int attr = a.getIndex(i);\n           switch (attr) {\n               //读取attr的参数\n               ...\n           }\n  //设置View的滚动模式\n       setOverScrollMode(overScrollMode);\n​\n       // Cache start/end user padding as we cannot fully resolve padding here (we dont have yet\n       // the resolved layout direction). Those cached values will be used later during padding\n       // resolution.\n       mUserPaddingStart = startPadding;\n       mUserPaddingEnd = endPadding;\n  //设置背景\n       if (background != null) {\n           setBackground(background);\n       }\n​\n       // setBackground above will record that padding is currently provided by the background.\n       // If we have padding specified via xml, record that here instead and use it.\n       mLeftPaddingDefined = leftPaddingDefined;\n       mRightPaddingDefined = rightPaddingDefined;\n​\n       ...\n   }\n\n```\n\n对于View的构造方法而言，在其中只是做了相关参数的初始化以及传入参数attr的数据的获取的操作，相对来说，并没有什么特别需要注意的地方，那我们直接查看到onMeasure中：\n\n```java\n /**\n\n     * <p>\n     * Measure the view and its content to determine the measured width and the\n     * measured height. This method is invoked by {@link #measure(int, int)} and\n     * should be overridden by subclasses to provide accurate and efficient\n     * measurement of their contents.\n     * </p>\n     *\n     * <p>\n     * <strong>CONTRACT:</strong> When overriding this method, you\n     * <em>must</em> call {@link #setMeasuredDimension(int, int)} to store the\n     * measured width and height of this view. Failure to do so will trigger an\n     * <code>IllegalStateException</code>, thrown by\n     * {@link #measure(int, int)}. Calling the superclass'\n     * {@link #onMeasure(int, int)} is a valid use.\n     * </p>\n     *\n     * <p>\n     * The base class implementation of measure defaults to the background size,\n     * unless a larger size is allowed by the MeasureSpec. Subclasses should\n     * override {@link #onMeasure(int, int)} to provide better measurements of\n     * their content.\n     * </p>\n     *\n     * <p>\n     * If this method is overridden, it is the subclass's responsibility to make\n     * sure the measured height and width are at least the view's minimum height\n     * and width ({@link #getSuggestedMinimumHeight()} and\n     * {@link #getSuggestedMinimumWidth()}).\n     * </p>\n     *\n   */\n     \n   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n       setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n               getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n   }\n   \n```\n\n在View注释中已经把onMeasure()解释得相当的完善了，我们可以在注释中获取一些信息：\n* onMeasure()方法中会测量其本身View以及包含内容的宽高\n\n* 当我们在子类中重写onMeasure()方法时，我们需要调用setMeasuredDimension(int, int)为这个View进行保存宽高\n\n* View默认的是background的大小\n\n```java\n\n/**\n\n     * Utility to return a default size. Uses the supplied size if the\n     * MeasureSpec imposed no constraints. Will get larger if allowed\n     * by the MeasureSpec.\n     *\n     * @param size Default size for this view\n     * @param measureSpec Constraints imposed by the parent\n     * @return The size this view should be.\n     */\npublic static int getDefaultSize(int size, int measureSpec) {\n       int result = size;\n       int specMode = MeasureSpec.getMode(measureSpec);\n       int specSize = MeasureSpec.getSize(measureSpec);\n​\n       switch (specMode) {\n       case MeasureSpec.UNSPECIFIED:\n           result = size;\n           break;\n       case MeasureSpec.AT_MOST:\n       case MeasureSpec.EXACTLY:\n           result = specSize;\n           break;\n       }\n       return result;\n   }\nprotected int getSuggestedMinimumWidth() {\n       return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());\n   }\nprotected int getSuggestedMinimumHeight() {\n       return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());\n​\n   }\n\n```\n\n在上述代码中，我们可以看到在getDefaultSize()方法中通过MeasureSpec来获得测量模式和大小(MeasureSpec代表一个32位的int值，高两位代表了specMode，低30位specSize)。specMode总共有三种()\n* MeasureSpec.UNSPECIFIED:父容器不对View有任何的影响，要多大就给多大\n\n* MeasureSpec.EXACTLY:父容器检测出View所需要的精确大小，这是View的最终大小就是specSize的值，其对应了match_parent模式\n\n* MeasureSpec.AT_MOST:父容器制定了可用大小，即specSize，View的大小不能大于这个值，对应wrap_content模式\n\n上述三种模式的说明来自于《android艺术开发探索》。在View的测量中，我们可以看到View的大小的测量跟设置的模式以及父布局是息息相关的，因此我们在进行自定义View的时候需要考虑到这两方面的因素。\n我们重新回溯到setMeasuredDimension()方法中：\n\n```java\nprotected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {\n\n       boolean optical = isLayoutModeOptical(this);\n       if (optical != isLayoutModeOptical(mParent)) {\n           Insets insets = getOpticalInsets();\n           int opticalWidth = insets.left + insets.right;\n           int opticalHeight = insets.top + insets.bottom;\n​\n           measuredWidth += optical ? opticalWidth : -opticalWidth;\n           measuredHeight += optical ? opticalHeight : -opticalHeight;\n       }\n       setMeasuredDimensionRaw(measuredWidth, measuredHeight);\n   }\n private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {\n       mMeasuredWidth = measuredWidth;\n       mMeasuredHeight = measuredHeight;\n​\n       mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;\n   }\n```\n在其中我们看到最终会将计算得到的宽高传给mMeasuredHeight和mMeasuredWidth。\n接下来在看看onLayout方法：\n```java\n /**\n\n     * Called from layout when this view should\n     * assign a size and position to each of its children.\n     *\n     * Derived classes with children should override\n     * this method and call layout on each of\n     * their children.\n     * @param changed This is a new size or position for this view\n     * @param left Left position, relative to parent\n     * @param top Top position, relative to parent\n     * @param right Right position, relative to parent\n     * @param bottom Bottom position, relative to parent\n     */\n   protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n   }\n```\nonLayout()是一个空实现的方法，从注释当中我们可以看到此方法更适用于ViewGroup，只有View是一个ViewGroup才需要考虑到layout的位置的问题。\n\n往下走，onDraw():\n```java\n/**\n\n     * Implement this to do your drawing.\n     *\n     * @param canvas the canvas on which the background will be drawn\n     */\n   protected void onDraw(Canvas canvas) {\n   }\n```\n同样是空实现，这里自定义View通过重写该方法来进行绘制的操作。\n\nViewRootIpml\n分析完上面的三个方法，我们更多地是看到一些赋值和空实现的方法，那么到底View的怎么开始绘制的过程的呢？这时候涉及到ViewRootIpml这个类了，它是连接View和WindowManager的桥梁，具体的作用是什么呢，我们从构建开始说起，一步步往下学习，首先我们找到其初始化的地方：\n```java\n//WindowManagerGlobal\n\n   public void addView(View view, ViewGroup.LayoutParams params,\n\n           Display display, Window parentWindow) {\n           ...\n\n​\n\n           ViewRootImpl root;\n           View panelParentView = null;\n\n           ...\n\n​\n\n           root = new ViewRootImpl(view.getContext(), display);\n​\n           view.setLayoutParams(wparams);\n​\n           mViews.add(view);\n           mRoots.add(root);\n           mParams.add(wparams);\n\n       }\n  try {\n\n           root.setView(view, wparams, panelParentView);\n       } catch (RuntimeException e) {\n           // BadTokenException or InvalidDisplayException, clean up.\n           synchronized (mLock) {\n               final int index = findViewLocked(view, false);\n               if (index >= 0) {\n                   removeViewLocked(index, true);\n               }\n           }\n           throw e;\n       }\n\n​\n       ...\n\n   }\n​\n```\n我们在WindowManager的实现类WindowManagerGlobal找到了其ViewRootImpl初始化的地方(关于WindowManager在以后会进行深入探讨，现在主要知道它是window窗口的管理类即可)，从addView()方法中我们推测其是将View添加到window的一个过程(addView这个方法在ActivityThread的handleResumeActivity()中实现)，然后又调用了ViewRootImpl的setView()方法：\n```java\n//ViewRootImpl\n\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n\n       synchronized (this) {\n           if (mView == null) {\n\n                 ...\n\n               requestLayout();\n\n              ...\n\n               }\n\n       }\n   }\n  @Override\n\n   public void requestLayout() {\n\n       if (!mHandlingLayoutInLayoutRequest) {\n           checkThread();\n           mLayoutRequested = true;\n           scheduleTraversals();\n\n       }\n\n   }\n\n   void scheduleTraversals() {\n\n           if (!mTraversalScheduled) {\n\n               mTraversalScheduled = true;\n               mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n               mChoreographer.postCallback(\n                       Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n               if (!mUnbufferedInputDispatch) {\n                   scheduleConsumeBatchedInput();\n               }\n               notifyRendererOfFramePending();\n               pokeDrawLockIfNeeded();\n           }\n       }\n   final class TraversalRunnable implements Runnable {\n\n           @Override\n           public void run() {\n               doTraversal();\n\n           }\n       }\n   void doTraversal() {\n           if (mTraversalScheduled) {\n               mTraversalScheduled = false;\n               mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n​\n               if (mProfile) {\n                   Debug.startMethodTracing(\"ViewAncestor\");\n               }\n​\n               performTraversals();\n\n​\n               if (mProfile) {\n                   Debug.stopMethodTracing();\n                   mProfile = false;\n               }\n           }\n       }\n  private void performTraversals() {\n\n        ...\n\n        performMeasure()；\n       ...\n       performLayout();\n\n        ...\n\n        performDraw();\n\n     }\n\n​\n```\n在这里我们可以看到当第一次进来的时候会设置mView的值，在其中调用了requestLayout()进行布局，然后依次是scheduleTraversals()->doTraversal()->performTraversals()的过程，在performTraversals()方法中调用了performMeasure(),performLayout(),performDraw()方法：\n```java\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n\n       Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\");\n       try {\n           mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n       } finally {\n           Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n       }\n   }\n  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,\n           int desiredWindowHeight) {\n         //当前mView是由WindowsManagerGlobal.addView传递过来，在ViewRootImpl中\n         //通过setView()获得到的。\n         final View host = mView;\n         ...\n           host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());\n   ...\n           \n        mInLayout = false;\n   }\n private void performDraw() {\n       if (mAttachInfo.mDisplayState == Display.STATE_OFF && !mReportNextDraw) {\n           return;\n       }\n​\n       final boolean fullRedrawNeeded = mFullRedrawNeeded;\n       mFullRedrawNeeded = false;\n​\n       mIsDrawing = true;\n       Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"draw\");\n       try {\n           draw(fullRedrawNeeded);\n       } finally {\n           mIsDrawing = false;\n           Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n       }\n\n           try {\n               mWindowSession.finishDrawing(mWindow);\n           } catch (RemoteException e) {\n           }\n       }\n   }\n private void draw(boolean fullRedrawNeeded) {\n\n       \n\n       ....\n\n         if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {\n\n           return;\n         }\n\n               \n\n       }\n\n       if (animating) {\n           mFullRedrawNeeded = true;\n           scheduleTraversals();\n       }\n   }\n​\n   /**\n     * @return true if drawing was successful, false if an error occurred\n     */\n   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n           boolean scalingRequired, Rect dirty) {\n​\n     \n\n       mView.draw(canvas);\n\n​\n         drawAccessibilityFocusedDrawableIfNeeded(canvas);\n\n           \n\n       return true;\n   }\n​\n```\n在上面我们最终可以看到，measure->layout->draw的过程最终回调到了View中的对应的是三个方法,所以我们重新回到View中研究一下这些方法,从measure()看起：\n```java\n/**\n\n     * <p>\n     * This is called to find out how big a view should be. The parent\n     * supplies constraint information in the width and height parameters.\n     * </p>\n     *\n     * <p>\n     * The actual measurement work of a view is performed in\n     * {@link #onMeasure(int, int)}, called by this method. Therefore, only\n     * {@link #onMeasure(int, int)} can and must be overridden by subclasses.\n     * </p>\n     *\n     *\n     * @param widthMeasureSpec Horizontal space requirements as imposed by the\n     *       parent\n     * @param heightMeasureSpec Vertical space requirements as imposed by the\n     *       parent\n     *\n     * @see #onMeasure(int, int)\n     */\n\npublic final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n\n       boolean optical = isLayoutModeOptical(this);\n\n   //是否采用视觉边界\n\n       if (optical != isLayoutModeOptical(mParent)) {\n\n           Insets insets = getOpticalInsets();\n\n           int oWidth = insets.left + insets.right;\n\n           int oHeight = insets.top + insets.bottom;\n           widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);\n           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);\n       }\n\n        ···\n\n       onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n       ···     \n\n   }\n```\n从注释中我们可以了解到，其实该方法是计算View树的宽高的最终方法，宽高由父布局和子布局共同决定，且该方法不允许子类进行相关操作，因为其是final的，子类想要设置宽高需要通过onMeasure()方法来进行。\n\n接下来我们再看下layout()方法：\n```java\n/**\n\n     * Assign a size and position to a view and all of its\n\n     * descendants\n     *\n     * <p>This is the second phase of the layout mechanism.\n     * (The first is measuring). In this phase, each parent calls\n     * layout on all of its children to position them.\n     * This is typically done using the child measurements\n     * that were stored in the measure pass().</p>\n     *\n     * <p>Derived classes should not override this method.\n     * Derived classes with children should override\n     * onLayout. In that method, they should\n     * call layout on each of their children.</p>\n     *\n     * @param l Left position, relative to parent\n     * @param t Top position, relative to parent\n     * @param r Right position, relative to parent\n     * @param b Bottom position, relative to parent\n     */\n   @SuppressWarnings({\"unchecked\"})\n   public void layout(int l, int t, int r, int b) {\n       if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {\n           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);\n           mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n       }\n​\n       int oldL = mLeft;\n       int oldT = mTop;\n       int oldB = mBottom;\n       int oldR = mRight;\n​\n       boolean changed = isLayoutModeOptical(mParent) ?\n               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);\n\n  //setFrame会判断是否需要重新布局，即如果我们在完成一次View展示后，重新设置View的大小，那么\n      //setFrame返回tru\n\n       if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n           onLayout(changed, l, t, r, b);\n\n           mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;\n​\n           ListenerInfo li = mListenerInfo;\n           if (li != null && li.mOnLayoutChangeListeners != null) {\n               ArrayList<OnLayoutChangeListener> listenersCopy =\n                       (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();\n               int numListeners = listenersCopy.size();\n               for (int i = 0; i < numListeners; ++i) {\n                   listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);\n               }\n           }\n       }\n​\n       mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;\n       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;\n   }\n```\n确认过大小后，我们需要定位View最终位置，在layout中会调用到onLayout()来获得我们需要展示的childrenView的效果。\ndraw()方法：\n```java\n/**\n\n     * Manually render this view (and all of its children) to the given Canvas.\n     * The view must have already done a full layout before this function is\n     * called. When implementing a view, implement\n     * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.\n     * If you do need to override this method, call the superclass version.\n     *\n     * @param canvas The Canvas to which the View is rendered.\n     */\n   @CallSuper\n   public void draw(Canvas canvas) {\n       final int privateFlags = mPrivateFlags;\n       final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&\n               (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);\n       mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;\n​\n       /*\n         * Draw traversal performs several drawing steps which must be executed\n         * in the appropriate order:\n         *\n         *     1. Draw the background\n         *     2. If necessary, save the canvas' layers to prepare for fading\n\n         *     3. Draw view's content\n\n         *     4. Draw children\n         *     5. If necessary, draw the fading edges and restore layers\n         *     6. Draw decorations (scrollbars for instance)\n         */\n​\n       // Step 1, draw the background, if needed\n       int saveCount;\n​\n       if (!dirtyOpaque) {\n           drawBackground(canvas);\n       }\n​\n       // skip step 2 & 5 if possible (common case)\n       final int viewFlags = mViewFlags;\n       boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;\n       boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;\n       if (!verticalEdges && !horizontalEdges) {\n           // Step 3, draw the content\n           if (!dirtyOpaque) onDraw(canvas);\n​\n           // Step 4, draw the children\n          //递归draw\n\n           dispatchDraw(canvas);\n​\n           // Overlay is part of the content and draws beneath Foreground\n           if (mOverlay != null && !mOverlay.isEmpty()) {\n               mOverlay.getOverlayView().dispatchDraw(canvas);\n           }\n​\n           // Step 6, draw decorations (foreground, scrollbars)\n           onDrawForeground(canvas);\n​\n           // we're done...\n           return;\n       }\n​\n```\n看代码注释就可以很轻松知道draw中的步骤，这里就不详细解释了。\n\n看到这里就对我们对View从哪里开始，并且如何一步步从测量绘制完成有了一个稍微深入的认识，画一个图先总结一下吧：\n\n{% asset_img one.png one %}\n\n但是我们只看到了绘制完成的部分，并没有看到View是怎么展示在我们面前的，想要知道View如何被调用再到绘制完成显示出来，这就牵扯到atcivity的启动的过程了，这里不对这方面进行讲解，详细的过程可以大概看下：\nhttp://www.jianshu.com/p/93c66b3f08d6 \n我写的这篇文章(写的比较乱，有时间整理一下=￣ω￣=)，本身我们就知道activity启动完成显示到手机上会执行到onResume()这个方法，这个方法可硬对应在ActivityThread中的handleResumeActivity():\n```java\n   final void handleResumeActivity(...){\n          ....\n           else if (!willBeVisible) {\n               if (localLOGV) Slog.v(\n                   TAG, \"Launch \" + r + \" mStartedActivity set\");\n               r.hideForNow = true;\n           }\n​\n           // Get rid of anything left hanging around.\n           cleanUpPendingRemoveWindows(r);\n​\n           // The window is now visible if it has been added, we are not\n           // simply finishing, and we are not starting another activity.\n           if (!r.activity.mFinished && willBeVisible\n                   && r.activity.mDecor != null && !r.hideForNow) {\n               if (r.newConfig != null) {\n                   r.tmpConfig.setTo(r.newConfig);\n                   if (r.overrideConfig != null) {\n                       r.tmpConfig.updateFrom(r.overrideConfig);\n                   }\n                   if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \"\n                           + r.activityInfo.name + \" with newConfig \" + r.tmpConfig);\n                   performConfigurationChanged(r.activity, r.tmpConfig);\n                   freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));\n                   r.newConfig = null;\n               }\n               if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\"\n                       + isForward);\n               WindowManager.LayoutParams l = r.window.getAttributes();\n               if ((l.softInputMode\n                       & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)\n                       != forwardBit) {\n                   l.softInputMode = (l.softInputMode\n                           & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))\n                           | forwardBit;\n                   if (r.activity.mVisibleFromClient) {\n                       ViewManager wm = a.getWindowManager();\n                       View decor = r.window.getDecorView();\n                       wm.updateViewLayout(decor, l);\n                   }\n               }\n               r.activity.mVisibleFromServer = true;\n               mNumVisibleActivities++;\n               if (r.activity.mVisibleFromClient) {\n                   r.activity.makeVisible();\n               }\n           }\n​\n           if (!r.onlyLocalRequest) {\n               r.nextIdle = mNewActivities;\n               mNewActivities = r;\n               if (localLOGV) Slog.v(\n                   TAG, \"Scheduling idle handler for \" + r);\n               Looper.myQueue().addIdleHandler(new Idler());\n           }\n           r.onlyLocalRequest = false;\n​\n           // Tell the activity manager we have resumed.\n           if (reallyResume) {\n               try {\n                   ActivityManagerNative.getDefault().activityResumed(token);\n               } catch (RemoteException ex) {\n               }\n           }\n​\n       } else {\n           // If an exception was thrown when trying to resume, then\n           // just end this activity.\n           try {\n               ActivityManagerNative.getDefault()\n                   .finishActivity(token, Activity.RESULT_CANCELED, null, false);\n           } catch (RemoteException ex) {\n           }\n       }\n   }\n```\n代码中有句 r.activity.makeVisible()就是展示的关键的代码，他会让DecorView变为Visibile状态，最终展示出来。\n\n-------\n####ViewGrop\n上面通过一系列的讲解只是从最简单的角度上而言——当页面中只有一个View的时候，但是绝大部分情况下是不可能的，往往项目中VIew树的层级是很深的(**这里建议使用RelativeLayout作为初始布局容器**)，那就涉及到ViewGroup了，其实ViewGroup也很简单，只不过多了一些递归的过程而已。\n\n这里选择FrameLayout来进行大概的讲述吧(因为好多文章用了LinearLayout，RelativeLayout我又嫌麻烦。。)，从onMeasure()开始看：\n```java\n  @Override\n\n   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n      //获取子View的数量\n\n       int count = getChildCount();\n  \n      //当前布局宽高否是match_parent\n       final boolean measureMatchParentChildren =\n               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||\n               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;\n       mMatchParentChildren.clear();\n​\n       int maxHeight = 0;\n       int maxWidth = 0;\n       int childState = 0;\n​\n       for (int i = 0; i < count; i++) {\n           final View child = getChildAt(i);\n          //GONE的布局不会进行测量\n\n           if (mMeasureAllChildren || child.getVisibility() != GONE) {\n              //测量时加上margin参数\n\n               measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);\n               final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n               maxWidth = Math.max(maxWidth,\n                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);\n               maxHeight = Math.max(maxHeight,\n                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);\n               childState = combineMeasuredStates(childState, child.getMeasuredState());\n               if (measureMatchParentChildren) {\n                   //子布局中是否由含match_parent的布局，有则添加到mMatchParentChildren中\n                   if (lp.width == LayoutParams.MATCH_PARENT ||\n                           lp.height == LayoutParams.MATCH_PARENT) {\n                       mMatchParentChildren.add(child);\n                   }\n               }\n           }\n       }\n​\n       // Account for padding too\n       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();\n       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();\n​\n       // Check against our minimum height and width\n       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());\n       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());\n​\n       // Check against our foreground's minimum height and width\n      //计算图片宽度，取图片宽高和最大宽高两者之间最大值\n\n       final Drawable drawable = getForeground();\n       if (drawable != null) {\n           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());\n           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());\n       }\n​\n       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),\n               resolveSizeAndState(maxHeight, heightMeasureSpec,\n                       childState << MEASURED_HEIGHT_STATE_SHIFT));​\n       count = mMatchParentChildren.size();\n\n      //这里对于子布局是match_parent的进行重新测量得到准确值\n       if (count > 1) {\n           for (int i = 0; i < count; i++) {\n               final View child = mMatchParentChildren.get(i);\n               final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n​\n               final int childWidthMeasureSpec;\n               if (lp.width == LayoutParams.MATCH_PARENT) {\n                   final int width = Math.max(0, getMeasuredWidth()\n                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()\n                           - lp.leftMargin - lp.rightMargin);\n                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(\n                           width, MeasureSpec.EXACTLY);\n               } else {\n                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,\n                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +\n                           lp.leftMargin + lp.rightMargin,\n                           lp.width);\n               }\n​\n               final int childHeightMeasureSpec;\n               if (lp.height == LayoutParams.MATCH_PARENT) {\n                   final int height = Math.max(0, getMeasuredHeight()\n                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()\n                           - lp.topMargin - lp.bottomMargin);\n                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(\n                           height, MeasureSpec.EXACTLY);\n               } else {\n                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,\n                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +\n                           lp.topMargin + lp.bottomMargin,\n                           lp.height);\n               }\n                //调用子布局的measure()方法\n               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n\n           }\n       }\n   }\n​\nprotected void measureChildWithMargins(View child,\n           int parentWidthMeasureSpec, int widthUsed,\n           int parentHeightMeasureSpec, int heightUsed) {\n       final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n​\n       final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                       + widthUsed, lp.width);\n       final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                       + heightUsed, lp.height);\n​            //调用子布局的measure()方法\n       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n   }\n```\n从onMeasure()可以看到主要的方法就是child.measure()的调用，他会调用到View的measure()，measure()又会重新调用onMeasure()由此形成依次递归直到获取到正确的测量结果。\n\nonLayout()方法：\n```java\n   @Override\n\n   protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n       layoutChildren(left, top, right, bottom, false /* no force left gravity */);\n   }\n​\n   void layoutChildren(int left, int top, int right, int bottom,\n                                 boolean forceLeftGravity) {\n       final int count = getChildCount();\n​\n       final int parentLeft = getPaddingLeftWithForeground();\n       final int parentRight = right - left - getPaddingRightWithForeground();\n​\n       final int parentTop = getPaddingTopWithForeground();\n       final int parentBottom = bottom - top - getPaddingBottomWithForeground();\n​\n       for (int i = 0; i < count; i++) {\n           final View child = getChildAt(i);\n           if (child.getVisibility() != GONE) {\n               final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n​\n               final int width = child.getMeasuredWidth();\n               final int height = child.getMeasuredHeight();\n​\n               int childLeft;\n               int childTop;\n​\n               int gravity = lp.gravity;\n               if (gravity == -1) {\n                   gravity = DEFAULT_CHILD_GRAVITY;\n               }\n​\n               final int layoutDirection = getLayoutDirection();\n               final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n               final int verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;\n​\n               switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n                   case Gravity.CENTER_HORIZONTAL:\n                       childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +\n                       lp.leftMargin - lp.rightMargin;\n                       break;\n                   case Gravity.RIGHT:\n                       if (!forceLeftGravity) {\n                           childLeft = parentRight - width - lp.rightMargin;\n                           break;\n                       }\n                   case Gravity.LEFT:\n                   default:\n                       childLeft = parentLeft + lp.leftMargin;\n               }\n​\n               switch (verticalGravity) {\n                   case Gravity.TOP:\n                       childTop = parentTop + lp.topMargin;\n                       break;\n                   case Gravity.CENTER_VERTICAL:\n                       childTop = parentTop + (parentBottom - parentTop - height) / 2 +\n                       lp.topMargin - lp.bottomMargin;\n                       break;\n                   case Gravity.BOTTOM:\n                       childTop = parentBottom - height - lp.bottomMargin;\n                       break;\n                   default:\n                       childTop = parentTop + lp.topMargin;\n               }\n​              //调用子View的layout\n               child.layout(childLeft, childTop, childLeft + width, childTop + height);\n           }\n       }\n   }\n​\n```\n可以看到layout也是一个递归调用的过程，这里就不详细讲述了，而由于ViewGroup没有onDraw()方法，这里就不需要讲了。\n\n附上一张View的生命周期:\n{% asset_img two.jpg cyclelife %}\n\n\n-----\n\n终于写完了，脑袋都要爆炸了，View形成的过程大概就是这样的，谢谢阅读，如果觉得哪写的不对或者不好的地方欢迎留言交流，希望能够一起进步~","slug":"android-View的探索-二-View的形成过程","published":1,"updated":"2016-12-13T02:41:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwmz2w8m0006dgs606ng7g76","content":"<p>我们在设计项目的时候，经常会遇到一些奇奇怪怪的需求，在这些需求中，对于UI的需求更是占了大半部分，这时候我们就避免不了与View打交道，熟悉自定义View的旁友应该会将onMeasure()-&gt;onLayout-&gt;onDraw的调用过程烂熟于心。因此，为了在撸代码的时候更加的对VIew得心应手，我们有必要对其进行一个深入的了解，下面就从构造方法看起吧。<br><a id=\"more\"></a></p>\n<p>View的构造方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">View</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       mContext = context;</div><div class=\"line\">       mResources = context != <span class=\"keyword\">null</span> ? context.getResources() : <span class=\"keyword\">null</span>;</div><div class=\"line\">       mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED;</div><div class=\"line\">       ....</div><div class=\"line\"></div><div class=\"line\">           sCompatibilityDone = <span class=\"keyword\">true</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">View</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr, <span class=\"keyword\">int</span> defStyleRes)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>(context);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> TypedArray a = context.obtainStyledAttributes(</div><div class=\"line\">               attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">if</span> (mDebugViewAttributes) &#123;</div><div class=\"line\">           saveAttributeData(attrs, a);</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       Drawable background = <span class=\"keyword\">null</span>;</div><div class=\"line\">​</div><div class=\"line\">       ...</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = a.getIndexCount();</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">int</span> attr = a.getIndex(i);</div><div class=\"line\">           <span class=\"keyword\">switch</span> (attr) &#123;</div><div class=\"line\">               <span class=\"comment\">//读取attr的参数</span></div><div class=\"line\">               ...</div><div class=\"line\">           &#125;</div><div class=\"line\">  <span class=\"comment\">//设置View的滚动模式</span></div><div class=\"line\">       setOverScrollMode(overScrollMode);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Cache start/end user padding as we cannot fully resolve padding here (we dont have yet</span></div><div class=\"line\">       <span class=\"comment\">// the resolved layout direction). Those cached values will be used later during padding</span></div><div class=\"line\">       <span class=\"comment\">// resolution.</span></div><div class=\"line\">       mUserPaddingStart = startPadding;</div><div class=\"line\">       mUserPaddingEnd = endPadding;</div><div class=\"line\">  <span class=\"comment\">//设置背景</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (background != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           setBackground(background);</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// setBackground above will record that padding is currently provided by the background.</span></div><div class=\"line\">       <span class=\"comment\">// If we have padding specified via xml, record that here instead and use it.</span></div><div class=\"line\">       mLeftPaddingDefined = leftPaddingDefined;</div><div class=\"line\">       mRightPaddingDefined = rightPaddingDefined;</div><div class=\"line\">​</div><div class=\"line\">       ...</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>对于View的构造方法而言，在其中只是做了相关参数的初始化以及传入参数attr的数据的获取的操作，相对来说，并没有什么特别需要注意的地方，那我们直接查看到onMeasure中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * Measure the view and its content to determine the measured width and the</div><div class=\"line\">    * measured height. This method is invoked by &#123;<span class=\"doctag\">@link</span> #measure(int, int)&#125; and</div><div class=\"line\">    * should be overridden by subclasses to provide accurate and efficient</div><div class=\"line\">    * measurement of their contents.</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you</div><div class=\"line\">    * &lt;em&gt;must&lt;/em&gt; call &#123;<span class=\"doctag\">@link</span> #setMeasuredDimension(int, int)&#125; to store the</div><div class=\"line\">    * measured width and height of this view. Failure to do so will trigger an</div><div class=\"line\">    * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by</div><div class=\"line\">    * &#123;<span class=\"doctag\">@link</span> #measure(int, int)&#125;. Calling the superclass'</div><div class=\"line\">    * &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125; is a valid use.</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * The base class implementation of measure defaults to the background size,</div><div class=\"line\">    * unless a larger size is allowed by the MeasureSpec. Subclasses should</div><div class=\"line\">    * override &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125; to provide better measurements of</div><div class=\"line\">    * their content.</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * If this method is overridden, it is the subclass's responsibility to make</div><div class=\"line\">    * sure the measured height and width are at least the view's minimum height</div><div class=\"line\">    * and width (&#123;<span class=\"doctag\">@link</span> #getSuggestedMinimumHeight()&#125; and</div><div class=\"line\">    * &#123;<span class=\"doctag\">@link</span> #getSuggestedMinimumWidth()&#125;).</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">  */</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class=\"line\">              getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>在View注释中已经把onMeasure()解释得相当的完善了，我们可以在注释中获取一些信息：</p>\n<ul>\n<li><p>onMeasure()方法中会测量其本身View以及包含内容的宽高</p>\n</li>\n<li><p>当我们在子类中重写onMeasure()方法时，我们需要调用setMeasuredDimension(int, int)为这个View进行保存宽高</p>\n</li>\n<li><p>View默认的是background的大小</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">     * Utility to return a default size. Uses the supplied size if the</div><div class=\"line\">     * MeasureSpec imposed no constraints. Will get larger if allowed</div><div class=\"line\">     * by the MeasureSpec.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> size Default size for this view</div><div class=\"line\">     * <span class=\"doctag\">@param</span> measureSpec Constraints imposed by the parent</div><div class=\"line\">     * <span class=\"doctag\">@return</span> The size this view should be.</div><div class=\"line\">     */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> measureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> result = size;</div><div class=\"line\">       <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class=\"line\">       <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">switch</span> (specMode) &#123;</div><div class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</div><div class=\"line\">           result = size;</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</div><div class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</div><div class=\"line\">           result = specSize;</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> result;</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getSuggestedMinimumWidth</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> (mBackground == <span class=\"keyword\">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getSuggestedMinimumHeight</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> (mBackground == <span class=\"keyword\">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class=\"line\">​</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在上述代码中，我们可以看到在getDefaultSize()方法中通过MeasureSpec来获得测量模式和大小(MeasureSpec代表一个32位的int值，高两位代表了specMode，低30位specSize)。specMode总共有三种()</p>\n<ul>\n<li><p>MeasureSpec.UNSPECIFIED:父容器不对View有任何的影响，要多大就给多大</p>\n</li>\n<li><p>MeasureSpec.EXACTLY:父容器检测出View所需要的精确大小，这是View的最终大小就是specSize的值，其对应了match_parent模式</p>\n</li>\n<li><p>MeasureSpec.AT_MOST:父容器制定了可用大小，即specSize，View的大小不能大于这个值，对应wrap_content模式</p>\n</li>\n</ul>\n<p>上述三种模式的说明来自于《android艺术开发探索》。在View的测量中，我们可以看到View的大小的测量跟设置的模式以及父布局是息息相关的，因此我们在进行自定义View的时候需要考虑到这两方面的因素。<br>我们重新回溯到setMeasuredDimension()方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasuredDimension</span><span class=\"params\">(<span class=\"keyword\">int</span> measuredWidth, <span class=\"keyword\">int</span> measuredHeight)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">boolean</span> optical = isLayoutModeOptical(<span class=\"keyword\">this</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class=\"line\">           Insets insets = getOpticalInsets();</div><div class=\"line\">           <span class=\"keyword\">int</span> opticalWidth = insets.left + insets.right;</div><div class=\"line\">           <span class=\"keyword\">int</span> opticalHeight = insets.top + insets.bottom;</div><div class=\"line\">​</div><div class=\"line\">           measuredWidth += optical ? opticalWidth : -opticalWidth;</div><div class=\"line\">           measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class=\"line\">       &#125;</div><div class=\"line\">       setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasuredDimensionRaw</span><span class=\"params\">(<span class=\"keyword\">int</span> measuredWidth, <span class=\"keyword\">int</span> measuredHeight)</span> </span>&#123;</div><div class=\"line\">       mMeasuredWidth = measuredWidth;</div><div class=\"line\">       mMeasuredHeight = measuredHeight;</div><div class=\"line\">​</div><div class=\"line\">       mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在其中我们看到最终会将计算得到的宽高传给mMeasuredHeight和mMeasuredWidth。<br>接下来在看看onLayout方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">    * Called from layout when this view should</div><div class=\"line\">    * assign a size and position to each of its children.</div><div class=\"line\">    *</div><div class=\"line\">    * Derived classes with children should override</div><div class=\"line\">    * this method and call layout on each of</div><div class=\"line\">    * their children.</div><div class=\"line\">    * <span class=\"doctag\">@param</span> changed This is a new size or position for this view</div><div class=\"line\">    * <span class=\"doctag\">@param</span> left Left position, relative to parent</div><div class=\"line\">    * <span class=\"doctag\">@param</span> top Top position, relative to parent</div><div class=\"line\">    * <span class=\"doctag\">@param</span> right Right position, relative to parent</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bottom Bottom position, relative to parent</div><div class=\"line\">    */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>onLayout()是一个空实现的方法，从注释当中我们可以看到此方法更适用于ViewGroup，只有View是一个ViewGroup才需要考虑到layout的位置的问题。</p>\n<p>往下走，onDraw():<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">     * Implement this to do your drawing.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> canvas the canvas on which the background will be drawn</div><div class=\"line\">     */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>同样是空实现，这里自定义View通过重写该方法来进行绘制的操作。</p>\n<p>ViewRootIpml<br>分析完上面的三个方法，我们更多地是看到一些赋值和空实现的方法，那么到底View的怎么开始绘制的过程的呢？这时候涉及到ViewRootIpml这个类了，它是连接View和WindowManager的桥梁，具体的作用是什么呢，我们从构建开始说起，一步步往下学习，首先我们找到其初始化的地方：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//WindowManagerGlobal</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></div><div class=\"line\"></div><div class=\"line\">           Display display, Window parentWindow) &#123;</div><div class=\"line\">           ...</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\"></div><div class=\"line\">           ViewRootImpl root;</div><div class=\"line\">           View panelParentView = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">           ...</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\"></div><div class=\"line\">           root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</div><div class=\"line\">​</div><div class=\"line\">           view.setLayoutParams(wparams);</div><div class=\"line\">​</div><div class=\"line\">           mViews.add(view);</div><div class=\"line\">           mRoots.add(root);</div><div class=\"line\">           mParams.add(wparams);</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">           root.setView(view, wparams, panelParentView);</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</div><div class=\"line\">           <span class=\"comment\">// BadTokenException or InvalidDisplayException, clean up.</span></div><div class=\"line\">           <span class=\"keyword\">synchronized</span> (mLock) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = findViewLocked(view, <span class=\"keyword\">false</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                   removeViewLocked(index, <span class=\"keyword\">true</span>);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">throw</span> e;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">       ...</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>我们在WindowManager的实现类WindowManagerGlobal找到了其ViewRootImpl初始化的地方(关于WindowManager在以后会进行深入探讨，现在主要知道它是window窗口的管理类即可)，从addView()方法中我们推测其是将View添加到window的一个过程(addView这个方法在ActivityThread的handleResumeActivity()中实现)，然后又调用了ViewRootImpl的setView()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//ViewRootImpl</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">                 ...</div><div class=\"line\"></div><div class=\"line\">               requestLayout();</div><div class=\"line\"></div><div class=\"line\">              ...</div><div class=\"line\"></div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</div><div class=\"line\">           checkThread();</div><div class=\"line\">           mLayoutRequested = <span class=\"keyword\">true</span>;</div><div class=\"line\">           scheduleTraversals();</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</div><div class=\"line\"></div><div class=\"line\">               mTraversalScheduled = <span class=\"keyword\">true</span>;</div><div class=\"line\">               mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class=\"line\">               mChoreographer.postCallback(</div><div class=\"line\">                       Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</div><div class=\"line\">                   scheduleConsumeBatchedInput();</div><div class=\"line\">               &#125;</div><div class=\"line\">               notifyRendererOfFramePending();</div><div class=\"line\">               pokeDrawLockIfNeeded();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               doTraversal();</div><div class=\"line\"></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</div><div class=\"line\">               mTraversalScheduled = <span class=\"keyword\">false</span>;</div><div class=\"line\">               mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">if</span> (mProfile) &#123;</div><div class=\"line\">                   Debug.startMethodTracing(<span class=\"string\">\"ViewAncestor\"</span>);</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               performTraversals();</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">if</span> (mProfile) &#123;</div><div class=\"line\">                   Debug.stopMethodTracing();</div><div class=\"line\">                   mProfile = <span class=\"keyword\">false</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\"></div><div class=\"line\">        performMeasure()；</div><div class=\"line\">       ...</div><div class=\"line\">       performLayout();</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\"></div><div class=\"line\">        performDraw();</div><div class=\"line\"></div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>在这里我们可以看到当第一次进来的时候会设置mView的值，在其中调用了requestLayout()进行布局，然后依次是scheduleTraversals()-&gt;doTraversal()-&gt;performTraversals()的过程，在performTraversals()方法中调用了performMeasure(),performLayout(),performDraw()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> childWidthMeasureSpec, <span class=\"keyword\">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">\"measure\"</span>);</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLayout</span><span class=\"params\">(WindowManager.LayoutParams lp, <span class=\"keyword\">int</span> desiredWindowWidth,</span></span></div><div class=\"line\">           <span class=\"keyword\">int</span> desiredWindowHeight) &#123;</div><div class=\"line\">         <span class=\"comment\">//当前mView是由WindowsManagerGlobal.addView传递过来，在ViewRootImpl中</span></div><div class=\"line\">         <span class=\"comment\">//通过setView()获得到的。</span></div><div class=\"line\">         <span class=\"keyword\">final</span> View host = mView;</div><div class=\"line\">         ...</div><div class=\"line\">           host.layout(<span class=\"number\">0</span>, <span class=\"number\">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div><div class=\"line\">   ...</div><div class=\"line\">           </div><div class=\"line\">        mInLayout = <span class=\"keyword\">false</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performDraw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</div><div class=\"line\">       mFullRedrawNeeded = <span class=\"keyword\">false</span>;</div><div class=\"line\">​</div><div class=\"line\">       mIsDrawing = <span class=\"keyword\">true</span>;</div><div class=\"line\">       Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">\"draw\"</span>);</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           draw(fullRedrawNeeded);</div><div class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">           mIsDrawing = <span class=\"keyword\">false</span>;</div><div class=\"line\">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">               mWindowSession.finishDrawing(mWindow);</div><div class=\"line\">           &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fullRedrawNeeded)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       </div><div class=\"line\"></div><div class=\"line\">       ....</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">               </div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (animating) &#123;</div><div class=\"line\">           mFullRedrawNeeded = <span class=\"keyword\">true</span>;</div><div class=\"line\">           scheduleTraversals();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">     * <span class=\"doctag\">@return</span> true if drawing was successful, false if an error occurred</div><div class=\"line\">     */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawSoftware</span><span class=\"params\">(Surface surface, AttachInfo attachInfo, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff,</span></span></div><div class=\"line\">           <span class=\"keyword\">boolean</span> scalingRequired, Rect dirty) &#123;</div><div class=\"line\">​</div><div class=\"line\">     </div><div class=\"line\"></div><div class=\"line\">       mView.draw(canvas);</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">         drawAccessibilityFocusedDrawableIfNeeded(canvas);</div><div class=\"line\"></div><div class=\"line\">           </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>在上面我们最终可以看到，measure-&gt;layout-&gt;draw的过程最终回调到了View中的对应的是三个方法,所以我们重新回到View中研究一下这些方法,从measure()看起：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">     * &lt;p&gt;</div><div class=\"line\">     * This is called to find out how big a view should be. The parent</div><div class=\"line\">     * supplies constraint information in the width and height parameters.</div><div class=\"line\">     * &lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;</div><div class=\"line\">     * The actual measurement work of a view is performed in</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</div><div class=\"line\">     * &lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</div><div class=\"line\">     *       parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</div><div class=\"line\">     *       parent</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@see</span> #onMeasure(int, int)</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">measure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">boolean</span> optical = isLayoutModeOptical(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">//是否采用视觉边界</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class=\"line\"></div><div class=\"line\">           Insets insets = getOpticalInsets();</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">int</span> oWidth = insets.left + insets.right;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">int</span> oHeight = insets.top + insets.bottom;</div><div class=\"line\">           widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);</div><div class=\"line\">           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        ···</div><div class=\"line\"></div><div class=\"line\">       onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">       ···     </div><div class=\"line\"></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从注释中我们可以了解到，其实该方法是计算View树的宽高的最终方法，宽高由父布局和子布局共同决定，且该方法不允许子类进行相关操作，因为其是final的，子类想要设置宽高需要通过onMeasure()方法来进行。</p>\n<p>接下来我们再看下layout()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">     * Assign a size and position to a view and all of its</div><div class=\"line\"></div><div class=\"line\">     * descendants</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;This is the second phase of the layout mechanism.</div><div class=\"line\">     * (The first is measuring). In this phase, each parent calls</div><div class=\"line\">     * layout on all of its children to position them.</div><div class=\"line\">     * This is typically done using the child measurements</div><div class=\"line\">     * that were stored in the measure pass().&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;Derived classes should not override this method.</div><div class=\"line\">     * Derived classes with children should override</div><div class=\"line\">     * onLayout. In that method, they should</div><div class=\"line\">     * call layout on each of their children.&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> l Left position, relative to parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> t Top position, relative to parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> r Right position, relative to parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> b Bottom position, relative to parent</div><div class=\"line\">     */</div><div class=\"line\">   <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>&#125;)</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class=\"line\">           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">int</span> oldL = mLeft;</div><div class=\"line\">       <span class=\"keyword\">int</span> oldT = mTop;</div><div class=\"line\">       <span class=\"keyword\">int</span> oldB = mBottom;</div><div class=\"line\">       <span class=\"keyword\">int</span> oldR = mRight;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class=\"line\">               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//setFrame会判断是否需要重新布局，即如果我们在完成一次View展示后，重新设置View的大小，那么</span></div><div class=\"line\">      <span class=\"comment\">//setFrame返回tru</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class=\"line\">           onLayout(changed, l, t, r, b);</div><div class=\"line\"></div><div class=\"line\">           mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class=\"line\">​</div><div class=\"line\">           ListenerInfo li = mListenerInfo;</div><div class=\"line\">           <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class=\"line\">                       (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class=\"line\">               <span class=\"keyword\">int</span> numListeners = listenersCopy.size();</div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numListeners; ++i) &#123;</div><div class=\"line\">                   listenersCopy.get(i).onLayoutChange(<span class=\"keyword\">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class=\"line\">       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>确认过大小后，我们需要定位View最终位置，在layout中会调用到onLayout()来获得我们需要展示的childrenView的效果。<br>draw()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"></div><div class=\"line\">     * Manually render this view (and all of its children) to the given Canvas.</div><div class=\"line\">     * The view must have already done a full layout before this function is</div><div class=\"line\">     * called. When implementing a view, implement</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #onDraw(android.graphics.Canvas)&#125; instead of overriding this method.</div><div class=\"line\">     * If you do need to override this method, call the superclass version.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> canvas The Canvas to which the View is rendered.</div><div class=\"line\">     */</div><div class=\"line\">   <span class=\"meta\">@CallSuper</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> privateFlags = mPrivateFlags;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class=\"line\">               (mAttachInfo == <span class=\"keyword\">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class=\"line\">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">/*</span></div><div class=\"line\">         * Draw traversal performs several drawing steps which must be executed</div><div class=\"line\">         * in the appropriate order:</div><div class=\"line\">         *</div><div class=\"line\">         *     1. Draw the background</div><div class=\"line\">         *     2. If necessary, save the canvas' layers to prepare for fading</div><div class=\"line\"></div><div class=\"line\">         *     3. Draw view's content</div><div class=\"line\"></div><div class=\"line\">         *     4. Draw children</div><div class=\"line\">         *     5. If necessary, draw the fading edges and restore layers</div><div class=\"line\">         *     6. Draw decorations (scrollbars for instance)</div><div class=\"line\">         */</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Step 1, draw the background, if needed</span></div><div class=\"line\">       <span class=\"keyword\">int</span> saveCount;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">if</span> (!dirtyOpaque) &#123;</div><div class=\"line\">           drawBackground(canvas);</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// skip step 2 &amp; 5 if possible (common case)</span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> viewFlags = mViewFlags;</div><div class=\"line\">       <span class=\"keyword\">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class=\"line\">           <span class=\"comment\">// Step 3, draw the content</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Step 4, draw the children</span></div><div class=\"line\">          <span class=\"comment\">//递归draw</span></div><div class=\"line\"></div><div class=\"line\">           dispatchDraw(canvas);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Overlay is part of the content and draws beneath Foreground</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mOverlay != <span class=\"keyword\">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class=\"line\">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class=\"line\">           onDrawForeground(canvas);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// we're done...</span></div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>看代码注释就可以很轻松知道draw中的步骤，这里就不详细解释了。</p>\n<p>看到这里就对我们对View从哪里开始，并且如何一步步从测量绘制完成有了一个稍微深入的认识，画一个图先总结一下吧：</p>\n<img src=\"/2016/12/09/android-View的探索-二-View的形成过程/one.png\" alt=\"one\" title=\"one\">\n<p>但是我们只看到了绘制完成的部分，并没有看到View是怎么展示在我们面前的，想要知道View如何被调用再到绘制完成显示出来，这就牵扯到atcivity的启动的过程了，这里不对这方面进行讲解，详细的过程可以大概看下：<br><a href=\"http://www.jianshu.com/p/93c66b3f08d6\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/93c66b3f08d6</a><br>我写的这篇文章(写的比较乱，有时间整理一下=￣ω￣=)，本身我们就知道activity启动完成显示到手机上会执行到onResume()这个方法，这个方法可硬对应在ActivityThread中的handleResumeActivity():<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(...)</span></span>&#123;</div><div class=\"line\">          ....</div><div class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!willBeVisible) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (localLOGV) Slog.v(</div><div class=\"line\">                   TAG, <span class=\"string\">\"Launch \"</span> + r + <span class=\"string\">\" mStartedActivity set\"</span>);</div><div class=\"line\">               r.hideForNow = <span class=\"keyword\">true</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Get rid of anything left hanging around.</span></div><div class=\"line\">           cleanUpPendingRemoveWindows(r);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// The window is now visible if it has been added, we are not</span></div><div class=\"line\">           <span class=\"comment\">// simply finishing, and we are not starting another activity.</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class=\"line\">                   &amp;&amp; r.activity.mDecor != <span class=\"keyword\">null</span> &amp;&amp; !r.hideForNow) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (r.newConfig != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   r.tmpConfig.setTo(r.newConfig);</div><div class=\"line\">                   <span class=\"keyword\">if</span> (r.overrideConfig != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                       r.tmpConfig.updateFrom(r.overrideConfig);</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class=\"string\">\"Resuming activity \"</span></div><div class=\"line\">                           + r.activityInfo.name + <span class=\"string\">\" with newConfig \"</span> + r.tmpConfig);</div><div class=\"line\">                   performConfigurationChanged(r.activity, r.tmpConfig);</div><div class=\"line\">                   freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</div><div class=\"line\">                   r.newConfig = <span class=\"keyword\">null</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">if</span> (localLOGV) Slog.v(TAG, <span class=\"string\">\"Resuming \"</span> + r + <span class=\"string\">\" with isForward=\"</span></div><div class=\"line\">                       + isForward);</div><div class=\"line\">               WindowManager.LayoutParams l = r.window.getAttributes();</div><div class=\"line\">               <span class=\"keyword\">if</span> ((l.softInputMode</div><div class=\"line\">                       &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</div><div class=\"line\">                       != forwardBit) &#123;</div><div class=\"line\">                   l.softInputMode = (l.softInputMode</div><div class=\"line\">                           &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</div><div class=\"line\">                           | forwardBit;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                       ViewManager wm = a.getWindowManager();</div><div class=\"line\">                       View decor = r.window.getDecorView();</div><div class=\"line\">                       wm.updateViewLayout(decor, l);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">               r.activity.mVisibleFromServer = <span class=\"keyword\">true</span>;</div><div class=\"line\">               mNumVisibleActivities++;</div><div class=\"line\">               <span class=\"keyword\">if</span> (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                   r.activity.makeVisible();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"keyword\">if</span> (!r.onlyLocalRequest) &#123;</div><div class=\"line\">               r.nextIdle = mNewActivities;</div><div class=\"line\">               mNewActivities = r;</div><div class=\"line\">               <span class=\"keyword\">if</span> (localLOGV) Slog.v(</div><div class=\"line\">                   TAG, <span class=\"string\">\"Scheduling idle handler for \"</span> + r);</div><div class=\"line\">               Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> Idler());</div><div class=\"line\">           &#125;</div><div class=\"line\">           r.onlyLocalRequest = <span class=\"keyword\">false</span>;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Tell the activity manager we have resumed.</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (reallyResume) &#123;</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   ActivityManagerNative.getDefault().activityResumed(token);</div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"comment\">// If an exception was thrown when trying to resume, then</span></div><div class=\"line\">           <span class=\"comment\">// just end this activity.</span></div><div class=\"line\">           <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">               ActivityManagerNative.getDefault()</div><div class=\"line\">                   .finishActivity(token, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">           &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>代码中有句 r.activity.makeVisible()就是展示的关键的代码，他会让DecorView变为Visibile状态，最终展示出来。</p>\n<hr>\n<p>####ViewGrop<br>上面通过一系列的讲解只是从最简单的角度上而言——当页面中只有一个View的时候，但是绝大部分情况下是不可能的，往往项目中VIew树的层级是很深的(<strong>这里建议使用RelativeLayout作为初始布局容器</strong>)，那就涉及到ViewGroup了，其实ViewGroup也很简单，只不过多了一些递归的过程而已。</p>\n<p>这里选择FrameLayout来进行大概的讲述吧(因为好多文章用了LinearLayout，RelativeLayout我又嫌麻烦。。)，从onMeasure()开始看：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//获取子View的数量</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">int</span> count = getChildCount();</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">//当前布局宽高否是match_parent</span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> measureMatchParentChildren =</div><div class=\"line\">               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class=\"line\">               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class=\"line\">       mMatchParentChildren.clear();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">int</span> maxHeight = <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">int</span> maxWidth = <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">int</span> childState = <span class=\"number\">0</span>;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> View child = getChildAt(i);</div><div class=\"line\">          <span class=\"comment\">//GONE的布局不会进行测量</span></div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class=\"line\">              <span class=\"comment\">//测量时加上margin参数</span></div><div class=\"line\"></div><div class=\"line\">               measureChildWithMargins(child, widthMeasureSpec, <span class=\"number\">0</span>, heightMeasureSpec, <span class=\"number\">0</span>);</div><div class=\"line\">               <span class=\"keyword\">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">               maxWidth = Math.max(maxWidth,</div><div class=\"line\">                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class=\"line\">               maxHeight = Math.max(maxHeight,</div><div class=\"line\">                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class=\"line\">               childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class=\"line\">               <span class=\"keyword\">if</span> (measureMatchParentChildren) &#123;</div><div class=\"line\">                   <span class=\"comment\">//子布局中是否由含match_parent的布局，有则添加到mMatchParentChildren中</span></div><div class=\"line\">                   <span class=\"keyword\">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class=\"line\">                           lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                       mMatchParentChildren.add(child);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Account for padding too</span></div><div class=\"line\">       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class=\"line\">       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Check against our minimum height and width</span></div><div class=\"line\">       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class=\"line\">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Check against our foreground's minimum height and width</span></div><div class=\"line\">      <span class=\"comment\">//计算图片宽度，取图片宽高和最大宽高两者之间最大值</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> Drawable drawable = getForeground();</div><div class=\"line\">       <span class=\"keyword\">if</span> (drawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class=\"line\">           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class=\"line\">               resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class=\"line\">                       childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));​</div><div class=\"line\">       count = mMatchParentChildren.size();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//这里对于子布局是match_parent的进行重新测量得到准确值</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> View child = mMatchParentChildren.get(i);</div><div class=\"line\">               <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec;</div><div class=\"line\">               <span class=\"keyword\">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> width = Math.max(<span class=\"number\">0</span>, getMeasuredWidth()</div><div class=\"line\">                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</div><div class=\"line\">                           - lp.leftMargin - lp.rightMargin);</div><div class=\"line\">                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class=\"line\">                           width, MeasureSpec.EXACTLY);</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class=\"line\">                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</div><div class=\"line\">                           lp.leftMargin + lp.rightMargin,</div><div class=\"line\">                           lp.width);</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec;</div><div class=\"line\">               <span class=\"keyword\">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height = Math.max(<span class=\"number\">0</span>, getMeasuredHeight()</div><div class=\"line\">                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</div><div class=\"line\">                           - lp.topMargin - lp.bottomMargin);</div><div class=\"line\">                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class=\"line\">                           height, MeasureSpec.EXACTLY);</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</div><div class=\"line\">                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</div><div class=\"line\">                           lp.topMargin + lp.bottomMargin,</div><div class=\"line\">                           lp.height);</div><div class=\"line\">               &#125;</div><div class=\"line\">                <span class=\"comment\">//调用子布局的measure()方法</span></div><div class=\"line\">               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildWithMargins</span><span class=\"params\">(View child,</span></span></div><div class=\"line\">           <span class=\"keyword\">int</span> parentWidthMeasureSpec, <span class=\"keyword\">int</span> widthUsed,</div><div class=\"line\">           <span class=\"keyword\">int</span> parentHeightMeasureSpec, <span class=\"keyword\">int</span> heightUsed) &#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class=\"line\">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class=\"line\">                       + widthUsed, lp.width);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class=\"line\">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class=\"line\">                       + heightUsed, lp.height);</div><div class=\"line\">​            <span class=\"comment\">//调用子布局的measure()方法</span></div><div class=\"line\">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从onMeasure()可以看到主要的方法就是child.measure()的调用，他会调用到View的measure()，measure()又会重新调用onMeasure()由此形成依次递归直到获取到正确的测量结果。</p>\n<p>onLayout()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">       layoutChildren(left, top, right, bottom, <span class=\"keyword\">false</span> <span class=\"comment\">/* no force left gravity */</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">layoutChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom,</span></span></div><div class=\"line\">                                 <span class=\"keyword\">boolean</span> forceLeftGravity) &#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = getChildCount();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentLeft = getPaddingLeftWithForeground();</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentRight = right - left - getPaddingRightWithForeground();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentTop = getPaddingTopWithForeground();</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> View child = getChildAt(i);</div><div class=\"line\">           <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> width = child.getMeasuredWidth();</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height = child.getMeasuredHeight();</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">int</span> childLeft;</div><div class=\"line\">               <span class=\"keyword\">int</span> childTop;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">int</span> gravity = lp.gravity;</div><div class=\"line\">               <span class=\"keyword\">if</span> (gravity == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">                   gravity = DEFAULT_CHILD_GRAVITY;</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> layoutDirection = getLayoutDirection();</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.CENTER_HORIZONTAL:</div><div class=\"line\">                       childLeft = parentLeft + (parentRight - parentLeft - width) / <span class=\"number\">2</span> +</div><div class=\"line\">                       lp.leftMargin - lp.rightMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.RIGHT:</div><div class=\"line\">                       <span class=\"keyword\">if</span> (!forceLeftGravity) &#123;</div><div class=\"line\">                           childLeft = parentRight - width - lp.rightMargin;</div><div class=\"line\">                           <span class=\"keyword\">break</span>;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.LEFT:</div><div class=\"line\">                   <span class=\"keyword\">default</span>:</div><div class=\"line\">                       childLeft = parentLeft + lp.leftMargin;</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">switch</span> (verticalGravity) &#123;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.TOP:</div><div class=\"line\">                       childTop = parentTop + lp.topMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.CENTER_VERTICAL:</div><div class=\"line\">                       childTop = parentTop + (parentBottom - parentTop - height) / <span class=\"number\">2</span> +</div><div class=\"line\">                       lp.topMargin - lp.bottomMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.BOTTOM:</div><div class=\"line\">                       childTop = parentBottom - height - lp.bottomMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">default</span>:</div><div class=\"line\">                       childTop = parentTop + lp.topMargin;</div><div class=\"line\">               &#125;</div><div class=\"line\">​              <span class=\"comment\">//调用子View的layout</span></div><div class=\"line\">               child.layout(childLeft, childTop, childLeft + width, childTop + height);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>可以看到layout也是一个递归调用的过程，这里就不详细讲述了，而由于ViewGroup没有onDraw()方法，这里就不需要讲了。</p>\n<p>附上一张View的生命周期:<br><img src=\"/2016/12/09/android-View的探索-二-View的形成过程/two.jpg\" alt=\"cyclelife\" title=\"cyclelife\"></p>\n<hr>\n<p>终于写完了，脑袋都要爆炸了，View形成的过程大概就是这样的，谢谢阅读，如果觉得哪写的不对或者不好的地方欢迎留言交流，希望能够一起进步~</p>\n","excerpt":"<p>我们在设计项目的时候，经常会遇到一些奇奇怪怪的需求，在这些需求中，对于UI的需求更是占了大半部分，这时候我们就避免不了与View打交道，熟悉自定义View的旁友应该会将onMeasure()-&gt;onLayout-&gt;onDraw的调用过程烂熟于心。因此，为了在撸代码的时候更加的对VIew得心应手，我们有必要对其进行一个深入的了解，下面就从构造方法看起吧。<br>","more":"</p>\n<p>View的构造方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">View</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       mContext = context;</div><div class=\"line\">       mResources = context != <span class=\"keyword\">null</span> ? context.getResources() : <span class=\"keyword\">null</span>;</div><div class=\"line\">       mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED;</div><div class=\"line\">       ....</div><div class=\"line\"></div><div class=\"line\">           sCompatibilityDone = <span class=\"keyword\">true</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">View</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr, <span class=\"keyword\">int</span> defStyleRes)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">this</span>(context);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> TypedArray a = context.obtainStyledAttributes(</div><div class=\"line\">               attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">if</span> (mDebugViewAttributes) &#123;</div><div class=\"line\">           saveAttributeData(attrs, a);</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       Drawable background = <span class=\"keyword\">null</span>;</div><div class=\"line\">​</div><div class=\"line\">       ...</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = a.getIndexCount();</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">int</span> attr = a.getIndex(i);</div><div class=\"line\">           <span class=\"keyword\">switch</span> (attr) &#123;</div><div class=\"line\">               <span class=\"comment\">//读取attr的参数</span></div><div class=\"line\">               ...</div><div class=\"line\">           &#125;</div><div class=\"line\">  <span class=\"comment\">//设置View的滚动模式</span></div><div class=\"line\">       setOverScrollMode(overScrollMode);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Cache start/end user padding as we cannot fully resolve padding here (we dont have yet</span></div><div class=\"line\">       <span class=\"comment\">// the resolved layout direction). Those cached values will be used later during padding</span></div><div class=\"line\">       <span class=\"comment\">// resolution.</span></div><div class=\"line\">       mUserPaddingStart = startPadding;</div><div class=\"line\">       mUserPaddingEnd = endPadding;</div><div class=\"line\">  <span class=\"comment\">//设置背景</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (background != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           setBackground(background);</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// setBackground above will record that padding is currently provided by the background.</span></div><div class=\"line\">       <span class=\"comment\">// If we have padding specified via xml, record that here instead and use it.</span></div><div class=\"line\">       mLeftPaddingDefined = leftPaddingDefined;</div><div class=\"line\">       mRightPaddingDefined = rightPaddingDefined;</div><div class=\"line\">​</div><div class=\"line\">       ...</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>对于View的构造方法而言，在其中只是做了相关参数的初始化以及传入参数attr的数据的获取的操作，相对来说，并没有什么特别需要注意的地方，那我们直接查看到onMeasure中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * Measure the view and its content to determine the measured width and the</div><div class=\"line\">    * measured height. This method is invoked by &#123;<span class=\"doctag\">@link</span> #measure(int, int)&#125; and</div><div class=\"line\">    * should be overridden by subclasses to provide accurate and efficient</div><div class=\"line\">    * measurement of their contents.</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you</div><div class=\"line\">    * &lt;em&gt;must&lt;/em&gt; call &#123;<span class=\"doctag\">@link</span> #setMeasuredDimension(int, int)&#125; to store the</div><div class=\"line\">    * measured width and height of this view. Failure to do so will trigger an</div><div class=\"line\">    * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by</div><div class=\"line\">    * &#123;<span class=\"doctag\">@link</span> #measure(int, int)&#125;. Calling the superclass'</div><div class=\"line\">    * &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125; is a valid use.</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * The base class implementation of measure defaults to the background size,</div><div class=\"line\">    * unless a larger size is allowed by the MeasureSpec. Subclasses should</div><div class=\"line\">    * override &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125; to provide better measurements of</div><div class=\"line\">    * their content.</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * If this method is overridden, it is the subclass's responsibility to make</div><div class=\"line\">    * sure the measured height and width are at least the view's minimum height</div><div class=\"line\">    * and width (&#123;<span class=\"doctag\">@link</span> #getSuggestedMinimumHeight()&#125; and</div><div class=\"line\">    * &#123;<span class=\"doctag\">@link</span> #getSuggestedMinimumWidth()&#125;).</div><div class=\"line\">    * &lt;/p&gt;</div><div class=\"line\">    *</div><div class=\"line\">  */</span></div><div class=\"line\">    </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class=\"line\">              getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>在View注释中已经把onMeasure()解释得相当的完善了，我们可以在注释中获取一些信息：</p>\n<ul>\n<li><p>onMeasure()方法中会测量其本身View以及包含内容的宽高</p>\n</li>\n<li><p>当我们在子类中重写onMeasure()方法时，我们需要调用setMeasuredDimension(int, int)为这个View进行保存宽高</p>\n</li>\n<li><p>View默认的是background的大小</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">     * Utility to return a default size. Uses the supplied size if the</div><div class=\"line\">     * MeasureSpec imposed no constraints. Will get larger if allowed</div><div class=\"line\">     * by the MeasureSpec.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> size Default size for this view</div><div class=\"line\">     * <span class=\"doctag\">@param</span> measureSpec Constraints imposed by the parent</div><div class=\"line\">     * <span class=\"doctag\">@return</span> The size this view should be.</div><div class=\"line\">     */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> measureSpec)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> result = size;</div><div class=\"line\">       <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class=\"line\">       <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">switch</span> (specMode) &#123;</div><div class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</div><div class=\"line\">           result = size;</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</div><div class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</div><div class=\"line\">           result = specSize;</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> result;</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getSuggestedMinimumWidth</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> (mBackground == <span class=\"keyword\">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getSuggestedMinimumHeight</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> (mBackground == <span class=\"keyword\">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class=\"line\">​</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在上述代码中，我们可以看到在getDefaultSize()方法中通过MeasureSpec来获得测量模式和大小(MeasureSpec代表一个32位的int值，高两位代表了specMode，低30位specSize)。specMode总共有三种()</p>\n<ul>\n<li><p>MeasureSpec.UNSPECIFIED:父容器不对View有任何的影响，要多大就给多大</p>\n</li>\n<li><p>MeasureSpec.EXACTLY:父容器检测出View所需要的精确大小，这是View的最终大小就是specSize的值，其对应了match_parent模式</p>\n</li>\n<li><p>MeasureSpec.AT_MOST:父容器制定了可用大小，即specSize，View的大小不能大于这个值，对应wrap_content模式</p>\n</li>\n</ul>\n<p>上述三种模式的说明来自于《android艺术开发探索》。在View的测量中，我们可以看到View的大小的测量跟设置的模式以及父布局是息息相关的，因此我们在进行自定义View的时候需要考虑到这两方面的因素。<br>我们重新回溯到setMeasuredDimension()方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasuredDimension</span><span class=\"params\">(<span class=\"keyword\">int</span> measuredWidth, <span class=\"keyword\">int</span> measuredHeight)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">boolean</span> optical = isLayoutModeOptical(<span class=\"keyword\">this</span>);</div><div class=\"line\">       <span class=\"keyword\">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class=\"line\">           Insets insets = getOpticalInsets();</div><div class=\"line\">           <span class=\"keyword\">int</span> opticalWidth = insets.left + insets.right;</div><div class=\"line\">           <span class=\"keyword\">int</span> opticalHeight = insets.top + insets.bottom;</div><div class=\"line\">​</div><div class=\"line\">           measuredWidth += optical ? opticalWidth : -opticalWidth;</div><div class=\"line\">           measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class=\"line\">       &#125;</div><div class=\"line\">       setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasuredDimensionRaw</span><span class=\"params\">(<span class=\"keyword\">int</span> measuredWidth, <span class=\"keyword\">int</span> measuredHeight)</span> </span>&#123;</div><div class=\"line\">       mMeasuredWidth = measuredWidth;</div><div class=\"line\">       mMeasuredHeight = measuredHeight;</div><div class=\"line\">​</div><div class=\"line\">       mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在其中我们看到最终会将计算得到的宽高传给mMeasuredHeight和mMeasuredWidth。<br>接下来在看看onLayout方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">    * Called from layout when this view should</div><div class=\"line\">    * assign a size and position to each of its children.</div><div class=\"line\">    *</div><div class=\"line\">    * Derived classes with children should override</div><div class=\"line\">    * this method and call layout on each of</div><div class=\"line\">    * their children.</div><div class=\"line\">    * <span class=\"doctag\">@param</span> changed This is a new size or position for this view</div><div class=\"line\">    * <span class=\"doctag\">@param</span> left Left position, relative to parent</div><div class=\"line\">    * <span class=\"doctag\">@param</span> top Top position, relative to parent</div><div class=\"line\">    * <span class=\"doctag\">@param</span> right Right position, relative to parent</div><div class=\"line\">    * <span class=\"doctag\">@param</span> bottom Bottom position, relative to parent</div><div class=\"line\">    */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>onLayout()是一个空实现的方法，从注释当中我们可以看到此方法更适用于ViewGroup，只有View是一个ViewGroup才需要考虑到layout的位置的问题。</p>\n<p>往下走，onDraw():<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">     * Implement this to do your drawing.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> canvas the canvas on which the background will be drawn</div><div class=\"line\">     */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>同样是空实现，这里自定义View通过重写该方法来进行绘制的操作。</p>\n<p>ViewRootIpml<br>分析完上面的三个方法，我们更多地是看到一些赋值和空实现的方法，那么到底View的怎么开始绘制的过程的呢？这时候涉及到ViewRootIpml这个类了，它是连接View和WindowManager的桥梁，具体的作用是什么呢，我们从构建开始说起，一步步往下学习，首先我们找到其初始化的地方：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//WindowManagerGlobal</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</div><div class=\"line\"></div><div class=\"line\">           Display display, Window parentWindow)</span> </span>&#123;</div><div class=\"line\">           ...</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\"></div><div class=\"line\">           ViewRootImpl root;</div><div class=\"line\">           View panelParentView = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">           ...</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\"></div><div class=\"line\">           root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</div><div class=\"line\">​</div><div class=\"line\">           view.setLayoutParams(wparams);</div><div class=\"line\">​</div><div class=\"line\">           mViews.add(view);</div><div class=\"line\">           mRoots.add(root);</div><div class=\"line\">           mParams.add(wparams);</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"></div><div class=\"line\">           root.setView(view, wparams, panelParentView);</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</div><div class=\"line\">           <span class=\"comment\">// BadTokenException or InvalidDisplayException, clean up.</span></div><div class=\"line\">           <span class=\"keyword\">synchronized</span> (mLock) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = findViewLocked(view, <span class=\"keyword\">false</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                   removeViewLocked(index, <span class=\"keyword\">true</span>);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">throw</span> e;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">       ...</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>我们在WindowManager的实现类WindowManagerGlobal找到了其ViewRootImpl初始化的地方(关于WindowManager在以后会进行深入探讨，现在主要知道它是window窗口的管理类即可)，从addView()方法中我们推测其是将View添加到window的一个过程(addView这个方法在ActivityThread的handleResumeActivity()中实现)，然后又调用了ViewRootImpl的setView()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//ViewRootImpl</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">                 ...</div><div class=\"line\"></div><div class=\"line\">               requestLayout();</div><div class=\"line\"></div><div class=\"line\">              ...</div><div class=\"line\"></div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</div><div class=\"line\">           checkThread();</div><div class=\"line\">           mLayoutRequested = <span class=\"keyword\">true</span>;</div><div class=\"line\">           scheduleTraversals();</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</div><div class=\"line\"></div><div class=\"line\">               mTraversalScheduled = <span class=\"keyword\">true</span>;</div><div class=\"line\">               mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class=\"line\">               mChoreographer.postCallback(</div><div class=\"line\">                       Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (!mUnbufferedInputDispatch) &#123;</div><div class=\"line\">                   scheduleConsumeBatchedInput();</div><div class=\"line\">               &#125;</div><div class=\"line\">               notifyRendererOfFramePending();</div><div class=\"line\">               pokeDrawLockIfNeeded();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               doTraversal();</div><div class=\"line\"></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</div><div class=\"line\">               mTraversalScheduled = <span class=\"keyword\">false</span>;</div><div class=\"line\">               mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">if</span> (mProfile) &#123;</div><div class=\"line\">                   Debug.startMethodTracing(<span class=\"string\">\"ViewAncestor\"</span>);</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               performTraversals();</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">if</span> (mProfile) &#123;</div><div class=\"line\">                   Debug.stopMethodTracing();</div><div class=\"line\">                   mProfile = <span class=\"keyword\">false</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\"></div><div class=\"line\">        performMeasure()；</div><div class=\"line\">       ...</div><div class=\"line\">       performLayout();</div><div class=\"line\"></div><div class=\"line\">        ...</div><div class=\"line\"></div><div class=\"line\">        performDraw();</div><div class=\"line\"></div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>在这里我们可以看到当第一次进来的时候会设置mView的值，在其中调用了requestLayout()进行布局，然后依次是scheduleTraversals()-&gt;doTraversal()-&gt;performTraversals()的过程，在performTraversals()方法中调用了performMeasure(),performLayout(),performDraw()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> childWidthMeasureSpec, <span class=\"keyword\">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">\"measure\"</span>);</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLayout</span><span class=\"params\">(WindowManager.LayoutParams lp, <span class=\"keyword\">int</span> desiredWindowWidth,</div><div class=\"line\">           <span class=\"keyword\">int</span> desiredWindowHeight)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">//当前mView是由WindowsManagerGlobal.addView传递过来，在ViewRootImpl中</span></div><div class=\"line\">         <span class=\"comment\">//通过setView()获得到的。</span></div><div class=\"line\">         <span class=\"keyword\">final</span> View host = mView;</div><div class=\"line\">         ...</div><div class=\"line\">           host.layout(<span class=\"number\">0</span>, <span class=\"number\">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</div><div class=\"line\">   ...</div><div class=\"line\">           </div><div class=\"line\">        mInLayout = <span class=\"keyword\">false</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performDraw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</div><div class=\"line\">       mFullRedrawNeeded = <span class=\"keyword\">false</span>;</div><div class=\"line\">​</div><div class=\"line\">       mIsDrawing = <span class=\"keyword\">true</span>;</div><div class=\"line\">       Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">\"draw\"</span>);</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           draw(fullRedrawNeeded);</div><div class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">           mIsDrawing = <span class=\"keyword\">false</span>;</div><div class=\"line\">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">               mWindowSession.finishDrawing(mWindow);</div><div class=\"line\">           &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fullRedrawNeeded)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       </div><div class=\"line\"></div><div class=\"line\">       ....</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">               </div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (animating) &#123;</div><div class=\"line\">           mFullRedrawNeeded = <span class=\"keyword\">true</span>;</div><div class=\"line\">           scheduleTraversals();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">     * <span class=\"doctag\">@return</span> true if drawing was successful, false if an error occurred</div><div class=\"line\">     */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawSoftware</span><span class=\"params\">(Surface surface, AttachInfo attachInfo, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff,</div><div class=\"line\">           <span class=\"keyword\">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</div><div class=\"line\">​</div><div class=\"line\">     </div><div class=\"line\"></div><div class=\"line\">       mView.draw(canvas);</div><div class=\"line\"></div><div class=\"line\">​</div><div class=\"line\">         drawAccessibilityFocusedDrawableIfNeeded(canvas);</div><div class=\"line\"></div><div class=\"line\">           </div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>在上面我们最终可以看到，measure-&gt;layout-&gt;draw的过程最终回调到了View中的对应的是三个方法,所以我们重新回到View中研究一下这些方法,从measure()看起：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">     * &lt;p&gt;</div><div class=\"line\">     * This is called to find out how big a view should be. The parent</div><div class=\"line\">     * supplies constraint information in the width and height parameters.</div><div class=\"line\">     * &lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;</div><div class=\"line\">     * The actual measurement work of a view is performed in</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</div><div class=\"line\">     * &lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</div><div class=\"line\">     *       parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</div><div class=\"line\">     *       parent</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@see</span> #onMeasure(int, int)</div><div class=\"line\">     */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">measure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">boolean</span> optical = isLayoutModeOptical(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">//是否采用视觉边界</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class=\"line\"></div><div class=\"line\">           Insets insets = getOpticalInsets();</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">int</span> oWidth = insets.left + insets.right;</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">int</span> oHeight = insets.top + insets.bottom;</div><div class=\"line\">           widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);</div><div class=\"line\">           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        ···</div><div class=\"line\"></div><div class=\"line\">       onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">       ···     </div><div class=\"line\"></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从注释中我们可以了解到，其实该方法是计算View树的宽高的最终方法，宽高由父布局和子布局共同决定，且该方法不允许子类进行相关操作，因为其是final的，子类想要设置宽高需要通过onMeasure()方法来进行。</p>\n<p>接下来我们再看下layout()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">     * Assign a size and position to a view and all of its</div><div class=\"line\"></div><div class=\"line\">     * descendants</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;This is the second phase of the layout mechanism.</div><div class=\"line\">     * (The first is measuring). In this phase, each parent calls</div><div class=\"line\">     * layout on all of its children to position them.</div><div class=\"line\">     * This is typically done using the child measurements</div><div class=\"line\">     * that were stored in the measure pass().&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;Derived classes should not override this method.</div><div class=\"line\">     * Derived classes with children should override</div><div class=\"line\">     * onLayout. In that method, they should</div><div class=\"line\">     * call layout on each of their children.&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> l Left position, relative to parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> t Top position, relative to parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> r Right position, relative to parent</div><div class=\"line\">     * <span class=\"doctag\">@param</span> b Bottom position, relative to parent</div><div class=\"line\">     */</span></div><div class=\"line\">   <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>&#125;)</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class=\"line\">           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">int</span> oldL = mLeft;</div><div class=\"line\">       <span class=\"keyword\">int</span> oldT = mTop;</div><div class=\"line\">       <span class=\"keyword\">int</span> oldB = mBottom;</div><div class=\"line\">       <span class=\"keyword\">int</span> oldR = mRight;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class=\"line\">               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//setFrame会判断是否需要重新布局，即如果我们在完成一次View展示后，重新设置View的大小，那么</span></div><div class=\"line\">      <span class=\"comment\">//setFrame返回tru</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class=\"line\">           onLayout(changed, l, t, r, b);</div><div class=\"line\"></div><div class=\"line\">           mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class=\"line\">​</div><div class=\"line\">           ListenerInfo li = mListenerInfo;</div><div class=\"line\">           <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class=\"line\">                       (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class=\"line\">               <span class=\"keyword\">int</span> numListeners = listenersCopy.size();</div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numListeners; ++i) &#123;</div><div class=\"line\">                   listenersCopy.get(i).onLayoutChange(<span class=\"keyword\">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class=\"line\">       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>确认过大小后，我们需要定位View最终位置，在layout中会调用到onLayout()来获得我们需要展示的childrenView的效果。<br>draw()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"></div><div class=\"line\">     * Manually render this view (and all of its children) to the given Canvas.</div><div class=\"line\">     * The view must have already done a full layout before this function is</div><div class=\"line\">     * called. When implementing a view, implement</div><div class=\"line\">     * &#123;<span class=\"doctag\">@link</span> #onDraw(android.graphics.Canvas)&#125; instead of overriding this method.</div><div class=\"line\">     * If you do need to override this method, call the superclass version.</div><div class=\"line\">     *</div><div class=\"line\">     * <span class=\"doctag\">@param</span> canvas The Canvas to which the View is rendered.</div><div class=\"line\">     */</span></div><div class=\"line\">   <span class=\"meta\">@CallSuper</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> privateFlags = mPrivateFlags;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class=\"line\">               (mAttachInfo == <span class=\"keyword\">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class=\"line\">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">/*</div><div class=\"line\">         * Draw traversal performs several drawing steps which must be executed</div><div class=\"line\">         * in the appropriate order:</div><div class=\"line\">         *</div><div class=\"line\">         *     1. Draw the background</div><div class=\"line\">         *     2. If necessary, save the canvas' layers to prepare for fading</div><div class=\"line\"></div><div class=\"line\">         *     3. Draw view's content</div><div class=\"line\"></div><div class=\"line\">         *     4. Draw children</div><div class=\"line\">         *     5. If necessary, draw the fading edges and restore layers</div><div class=\"line\">         *     6. Draw decorations (scrollbars for instance)</div><div class=\"line\">         */</span></div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Step 1, draw the background, if needed</span></div><div class=\"line\">       <span class=\"keyword\">int</span> saveCount;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">if</span> (!dirtyOpaque) &#123;</div><div class=\"line\">           drawBackground(canvas);</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// skip step 2 &amp; 5 if possible (common case)</span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> viewFlags = mViewFlags;</div><div class=\"line\">       <span class=\"keyword\">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class=\"line\">           <span class=\"comment\">// Step 3, draw the content</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Step 4, draw the children</span></div><div class=\"line\">          <span class=\"comment\">//递归draw</span></div><div class=\"line\"></div><div class=\"line\">           dispatchDraw(canvas);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Overlay is part of the content and draws beneath Foreground</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mOverlay != <span class=\"keyword\">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class=\"line\">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class=\"line\">           onDrawForeground(canvas);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// we're done...</span></div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>看代码注释就可以很轻松知道draw中的步骤，这里就不详细解释了。</p>\n<p>看到这里就对我们对View从哪里开始，并且如何一步步从测量绘制完成有了一个稍微深入的认识，画一个图先总结一下吧：</p>\n<img src=\"/2016/12/09/android-View的探索-二-View的形成过程/one.png\" alt=\"one\" title=\"one\">\n<p>但是我们只看到了绘制完成的部分，并没有看到View是怎么展示在我们面前的，想要知道View如何被调用再到绘制完成显示出来，这就牵扯到atcivity的启动的过程了，这里不对这方面进行讲解，详细的过程可以大概看下：<br><a href=\"http://www.jianshu.com/p/93c66b3f08d6\">http://www.jianshu.com/p/93c66b3f08d6</a><br>我写的这篇文章(写的比较乱，有时间整理一下=￣ω￣=)，本身我们就知道activity启动完成显示到手机上会执行到onResume()这个方法，这个方法可硬对应在ActivityThread中的handleResumeActivity():<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(...)</span></span>&#123;</div><div class=\"line\">          ....</div><div class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!willBeVisible) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (localLOGV) Slog.v(</div><div class=\"line\">                   TAG, <span class=\"string\">\"Launch \"</span> + r + <span class=\"string\">\" mStartedActivity set\"</span>);</div><div class=\"line\">               r.hideForNow = <span class=\"keyword\">true</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Get rid of anything left hanging around.</span></div><div class=\"line\">           cleanUpPendingRemoveWindows(r);</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// The window is now visible if it has been added, we are not</span></div><div class=\"line\">           <span class=\"comment\">// simply finishing, and we are not starting another activity.</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class=\"line\">                   &amp;&amp; r.activity.mDecor != <span class=\"keyword\">null</span> &amp;&amp; !r.hideForNow) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span> (r.newConfig != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   r.tmpConfig.setTo(r.newConfig);</div><div class=\"line\">                   <span class=\"keyword\">if</span> (r.overrideConfig != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                       r.tmpConfig.updateFrom(r.overrideConfig);</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class=\"string\">\"Resuming activity \"</span></div><div class=\"line\">                           + r.activityInfo.name + <span class=\"string\">\" with newConfig \"</span> + r.tmpConfig);</div><div class=\"line\">                   performConfigurationChanged(r.activity, r.tmpConfig);</div><div class=\"line\">                   freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</div><div class=\"line\">                   r.newConfig = <span class=\"keyword\">null</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"keyword\">if</span> (localLOGV) Slog.v(TAG, <span class=\"string\">\"Resuming \"</span> + r + <span class=\"string\">\" with isForward=\"</span></div><div class=\"line\">                       + isForward);</div><div class=\"line\">               WindowManager.LayoutParams l = r.window.getAttributes();</div><div class=\"line\">               <span class=\"keyword\">if</span> ((l.softInputMode</div><div class=\"line\">                       &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</div><div class=\"line\">                       != forwardBit) &#123;</div><div class=\"line\">                   l.softInputMode = (l.softInputMode</div><div class=\"line\">                           &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</div><div class=\"line\">                           | forwardBit;</div><div class=\"line\">                   <span class=\"keyword\">if</span> (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                       ViewManager wm = a.getWindowManager();</div><div class=\"line\">                       View decor = r.window.getDecorView();</div><div class=\"line\">                       wm.updateViewLayout(decor, l);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">               r.activity.mVisibleFromServer = <span class=\"keyword\">true</span>;</div><div class=\"line\">               mNumVisibleActivities++;</div><div class=\"line\">               <span class=\"keyword\">if</span> (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                   r.activity.makeVisible();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"keyword\">if</span> (!r.onlyLocalRequest) &#123;</div><div class=\"line\">               r.nextIdle = mNewActivities;</div><div class=\"line\">               mNewActivities = r;</div><div class=\"line\">               <span class=\"keyword\">if</span> (localLOGV) Slog.v(</div><div class=\"line\">                   TAG, <span class=\"string\">\"Scheduling idle handler for \"</span> + r);</div><div class=\"line\">               Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> Idler());</div><div class=\"line\">           &#125;</div><div class=\"line\">           r.onlyLocalRequest = <span class=\"keyword\">false</span>;</div><div class=\"line\">​</div><div class=\"line\">           <span class=\"comment\">// Tell the activity manager we have resumed.</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (reallyResume) &#123;</div><div class=\"line\">               <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                   ActivityManagerNative.getDefault().activityResumed(token);</div><div class=\"line\">               &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">​</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"comment\">// If an exception was thrown when trying to resume, then</span></div><div class=\"line\">           <span class=\"comment\">// just end this activity.</span></div><div class=\"line\">           <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">               ActivityManagerNative.getDefault()</div><div class=\"line\">                   .finishActivity(token, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">           &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>代码中有句 r.activity.makeVisible()就是展示的关键的代码，他会让DecorView变为Visibile状态，最终展示出来。</p>\n<hr>\n<p>####ViewGrop<br>上面通过一系列的讲解只是从最简单的角度上而言——当页面中只有一个View的时候，但是绝大部分情况下是不可能的，往往项目中VIew树的层级是很深的(<strong>这里建议使用RelativeLayout作为初始布局容器</strong>)，那就涉及到ViewGroup了，其实ViewGroup也很简单，只不过多了一些递归的过程而已。</p>\n<p>这里选择FrameLayout来进行大概的讲述吧(因为好多文章用了LinearLayout，RelativeLayout我又嫌麻烦。。)，从onMeasure()开始看：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//获取子View的数量</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">int</span> count = getChildCount();</div><div class=\"line\">  </div><div class=\"line\">      <span class=\"comment\">//当前布局宽高否是match_parent</span></div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> measureMatchParentChildren =</div><div class=\"line\">               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</div><div class=\"line\">               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</div><div class=\"line\">       mMatchParentChildren.clear();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">int</span> maxHeight = <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">int</span> maxWidth = <span class=\"number\">0</span>;</div><div class=\"line\">       <span class=\"keyword\">int</span> childState = <span class=\"number\">0</span>;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> View child = getChildAt(i);</div><div class=\"line\">          <span class=\"comment\">//GONE的布局不会进行测量</span></div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</div><div class=\"line\">              <span class=\"comment\">//测量时加上margin参数</span></div><div class=\"line\"></div><div class=\"line\">               measureChildWithMargins(child, widthMeasureSpec, <span class=\"number\">0</span>, heightMeasureSpec, <span class=\"number\">0</span>);</div><div class=\"line\">               <span class=\"keyword\">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">               maxWidth = Math.max(maxWidth,</div><div class=\"line\">                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</div><div class=\"line\">               maxHeight = Math.max(maxHeight,</div><div class=\"line\">                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</div><div class=\"line\">               childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class=\"line\">               <span class=\"keyword\">if</span> (measureMatchParentChildren) &#123;</div><div class=\"line\">                   <span class=\"comment\">//子布局中是否由含match_parent的布局，有则添加到mMatchParentChildren中</span></div><div class=\"line\">                   <span class=\"keyword\">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</div><div class=\"line\">                           lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                       mMatchParentChildren.add(child);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Account for padding too</span></div><div class=\"line\">       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</div><div class=\"line\">       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Check against our minimum height and width</span></div><div class=\"line\">       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</div><div class=\"line\">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"comment\">// Check against our foreground's minimum height and width</span></div><div class=\"line\">      <span class=\"comment\">//计算图片宽度，取图片宽高和最大宽高两者之间最大值</span></div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">final</span> Drawable drawable = getForeground();</div><div class=\"line\">       <span class=\"keyword\">if</span> (drawable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</div><div class=\"line\">           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</div><div class=\"line\">       &#125;</div><div class=\"line\">​</div><div class=\"line\">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</div><div class=\"line\">               resolveSizeAndState(maxHeight, heightMeasureSpec,</div><div class=\"line\">                       childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));​</div><div class=\"line\">       count = mMatchParentChildren.size();</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//这里对于子布局是match_parent的进行重新测量得到准确值</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> View child = mMatchParentChildren.get(i);</div><div class=\"line\">               <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec;</div><div class=\"line\">               <span class=\"keyword\">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> width = Math.max(<span class=\"number\">0</span>, getMeasuredWidth()</div><div class=\"line\">                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</div><div class=\"line\">                           - lp.leftMargin - lp.rightMargin);</div><div class=\"line\">                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class=\"line\">                           width, MeasureSpec.EXACTLY);</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</div><div class=\"line\">                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</div><div class=\"line\">                           lp.leftMargin + lp.rightMargin,</div><div class=\"line\">                           lp.width);</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec;</div><div class=\"line\">               <span class=\"keyword\">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height = Math.max(<span class=\"number\">0</span>, getMeasuredHeight()</div><div class=\"line\">                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</div><div class=\"line\">                           - lp.topMargin - lp.bottomMargin);</div><div class=\"line\">                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class=\"line\">                           height, MeasureSpec.EXACTLY);</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</div><div class=\"line\">                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</div><div class=\"line\">                           lp.topMargin + lp.bottomMargin,</div><div class=\"line\">                           lp.height);</div><div class=\"line\">               &#125;</div><div class=\"line\">                <span class=\"comment\">//调用子布局的measure()方法</span></div><div class=\"line\">               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\"></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildWithMargins</span><span class=\"params\">(View child,</div><div class=\"line\">           <span class=\"keyword\">int</span> parentWidthMeasureSpec, <span class=\"keyword\">int</span> widthUsed,</div><div class=\"line\">           <span class=\"keyword\">int</span> parentHeightMeasureSpec, <span class=\"keyword\">int</span> heightUsed)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class=\"line\">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class=\"line\">                       + widthUsed, lp.width);</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class=\"line\">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class=\"line\">                       + heightUsed, lp.height);</div><div class=\"line\">​            <span class=\"comment\">//调用子布局的measure()方法</span></div><div class=\"line\">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>从onMeasure()可以看到主要的方法就是child.measure()的调用，他会调用到View的measure()，measure()又会重新调用onMeasure()由此形成依次递归直到获取到正确的测量结果。</p>\n<p>onLayout()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">       layoutChildren(left, top, right, bottom, <span class=\"keyword\">false</span> <span class=\"comment\">/* no force left gravity */</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">layoutChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom,</div><div class=\"line\">                                 <span class=\"keyword\">boolean</span> forceLeftGravity)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = getChildCount();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentLeft = getPaddingLeftWithForeground();</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentRight = right - left - getPaddingRightWithForeground();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentTop = getPaddingTopWithForeground();</div><div class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</div><div class=\"line\">​</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> View child = getChildAt(i);</div><div class=\"line\">           <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</div><div class=\"line\">               <span class=\"keyword\">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> width = child.getMeasuredWidth();</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> height = child.getMeasuredHeight();</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">int</span> childLeft;</div><div class=\"line\">               <span class=\"keyword\">int</span> childTop;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">int</span> gravity = lp.gravity;</div><div class=\"line\">               <span class=\"keyword\">if</span> (gravity == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">                   gravity = DEFAULT_CHILD_GRAVITY;</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> layoutDirection = getLayoutDirection();</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.CENTER_HORIZONTAL:</div><div class=\"line\">                       childLeft = parentLeft + (parentRight - parentLeft - width) / <span class=\"number\">2</span> +</div><div class=\"line\">                       lp.leftMargin - lp.rightMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.RIGHT:</div><div class=\"line\">                       <span class=\"keyword\">if</span> (!forceLeftGravity) &#123;</div><div class=\"line\">                           childLeft = parentRight - width - lp.rightMargin;</div><div class=\"line\">                           <span class=\"keyword\">break</span>;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.LEFT:</div><div class=\"line\">                   <span class=\"keyword\">default</span>:</div><div class=\"line\">                       childLeft = parentLeft + lp.leftMargin;</div><div class=\"line\">               &#125;</div><div class=\"line\">​</div><div class=\"line\">               <span class=\"keyword\">switch</span> (verticalGravity) &#123;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.TOP:</div><div class=\"line\">                       childTop = parentTop + lp.topMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.CENTER_VERTICAL:</div><div class=\"line\">                       childTop = parentTop + (parentBottom - parentTop - height) / <span class=\"number\">2</span> +</div><div class=\"line\">                       lp.topMargin - lp.bottomMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">case</span> Gravity.BOTTOM:</div><div class=\"line\">                       childTop = parentBottom - height - lp.bottomMargin;</div><div class=\"line\">                       <span class=\"keyword\">break</span>;</div><div class=\"line\">                   <span class=\"keyword\">default</span>:</div><div class=\"line\">                       childTop = parentTop + lp.topMargin;</div><div class=\"line\">               &#125;</div><div class=\"line\">​              <span class=\"comment\">//调用子View的layout</span></div><div class=\"line\">               child.layout(childLeft, childTop, childLeft + width, childTop + height);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>可以看到layout也是一个递归调用的过程，这里就不详细讲述了，而由于ViewGroup没有onDraw()方法，这里就不需要讲了。</p>\n<p>附上一张View的生命周期:<br><img src=\"/2016/12/09/android-View的探索-二-View的形成过程/two.jpg\" alt=\"cyclelife\" title=\"cyclelife\"></p>\n<hr>\n<p>终于写完了，脑袋都要爆炸了，View形成的过程大概就是这样的，谢谢阅读，如果觉得哪写的不对或者不好的地方欢迎留言交流，希望能够一起进步~</p>"},{"title":"volley源码学习","date":"2016-12-09T04:52:19.000Z","_content":"\n----\n\nVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布的，现在连android系统中内部也是使用了Volley作为其网络的请求框架，谷歌出品，必属精品，所以有必要进行一次梳理其实现的总体过程，学习其设计框架的思路也是必要的(文章适合知道基本使用Volley的同学观看)。\n<!--more-->\n-------\n\n<h3>Volley</h3>\n\n一般我们都会在app初始化的时候调用如下代码进行初始化Volley，下面就从该方法当做阅读入口进行逐一跟踪：\n\n```java\nmRequestQueue =  Volley.newRequestQueue(this); \n```\n\n在调用Volley.newRequestQueue(this)时，最终调用到如下代码:\n\n```java\n /**\n     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.\n     * You may set a maximum size of the disk cache in bytes.\n     *HttpStack是用来进行网络请求封装的类，传入null代表默认\n     *maxDiskCacheBytes为最大磁盘缓存，传入-1使用默认大小\n     */\n    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n      //构造缓存区域\n        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n        String userAgent = \"volley/0\";\n        try {\n            String packageName = context.getPackageName();\n            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n            userAgent = packageName + \"/\" + info.versionCode;\n        } catch (NameNotFoundException e) {\n        }\n\t\t//我们可以传入okttp来充当我们的httpStack\n        if (stack == null) {\n          //使用Volley默认封装的stack，依靠android版本来决定使用不同的connection来进行网络请求\n            if (Build.VERSION.SDK_INT >= 9) {\n                stack = new HurlStack();\n            } else {\n                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n            }\n        }\n\n        Network network = new BasicNetwork(stack);\n        \n        RequestQueue queue;\n        if (maxDiskCacheBytes <= -1)\n        {\n        \t// No maximum size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir), network);\n        }\n        else\n        {\n        \t// Disk cache size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);\n        }\n\n        queue.start();\n\n        return queue;\n    }\n```\n\n在newRequestQueue\b方法中进行了相关必要参数的初始化的工作，其中包括:\n\n- 缓存区域的初始化\n- HttpStack的初始化\n- Network的初始化\n- RequestQueue的初始化，最终调用其start()方法\n\n------\n\n#### Stack 详解\n\n在Volley中如果没有传递任何HttpStack则会使用了两种stack来进行不同android版本(SDK_INT >= 9?HurlStack:HttpClientStack)的适配工作：HurlStack和HttpClientStack，两种stack都实现了HttpStack接口，接口定义如下：\n\n```java\npublic interface HttpStack {\n    //请求处理方法\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n        throws IOException, AuthFailureError;\n\n}\n```\n\n在接口中定义performRequest方法，在其子类中实现了对于http请求的封装的操作，以此来查看对应实现子类的performRequest方法。\n\n在HurlStack中关于performRequest(…)的实现：\n\n```java\n@Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n        String url = request.getUrl();\n      //存放请求头\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.putAll(request.getHeaders());\n        map.putAll(additionalHeaders);\n      //是否重写url\n        if (mUrlRewriter != null) {\n            String rewritten = mUrlRewriter.rewriteUrl(url);\n            if (rewritten == null) {\n                throw new IOException(\"URL blocked by rewriter: \" + url);\n            }\n            url = rewritten;\n        }\n        URL parsedUrl = new URL(url);\n      //使用后HttpURLConnection进行网络请求\n        HttpURLConnection connection = openConnection(parsedUrl, request);\n        for (String headerName : map.keySet()) {\n            connection.addRequestProperty(headerName, map.get(headerName));\n        }\n      //设置请求方法：GET ,POST, ect\n        setConnectionParametersForRequest(connection, request);\n        // Initialize HttpResponse with data from the HttpURLConnection.\n        ProtocolVersion protocolVersion = new ProtocolVersion(\"HTTP\", 1, 1);\n        int responseCode = connection.getResponseCode();\n        if (responseCode == -1) {\n            // -1 is returned by getResponseCode() if the response code could not be retrieved.\n            // Signal to the caller that something was wrong with the connection.\n            throw new IOException(\"Could not retrieve response code from HttpUrlConnection.\");\n        }\n        StatusLine responseStatus = new BasicStatusLine(protocolVersion,\n                connection.getResponseCode(), connection.getResponseMessage());\n        BasicHttpResponse response = new BasicHttpResponse(responseStatus);\n      \t//将返回的数据流写入response\n        response.setEntity(entityFromConnection(connection));\n      \t//获取返回的请求头\n        for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));\n                response.addHeader(h);\n            }\n        }\n        return response;\n    }\n```\n\nHurlStack使用HttpURLConnection进行Http请求的过程，步骤是基本的网络请求的过程，设置请求头->包装Url->打开连接->设置请求方法->获取数据已经请求状态->将数据流存入HttpResponse，最终返回一个HttpResponse。\n\nHttpClientStack中关于performRequest(…)的实现：\n\n```java\n@Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n      \t//构造请求参数\n        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);\n      \t//添加请求头\n        addHeaders(httpRequest, additionalHeaders);\n        addHeaders(httpRequest, request.getHeaders());\n        onPrepareRequest(httpRequest);\n        HttpParams httpParams = httpRequest.getParams();\n        int timeoutMs = request.getTimeoutMs();\n        // TODO: Reevaluate this connection timeout based on more wide-scale\n        // data collection and possibly different for wifi vs. 3G.\n        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);\n        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);\n        return mClient.execute(httpRequest);\n    }\n```\n\nHttpClientStack\b执行的大体过程与HurlStack基本上一致，通过一系列操作最终调用AndroidHttpClient.execute(httpRequest)返回一个HttpResponse。\n\n\n\nHttpStack封装了http请求的过程，并且只管http请求，满足设计模式中单一责任的原则，并且向外提供接口HttpStack方便使用者定制自身的HttpStack类来进行请求的过程，如：可以用OkhttpClient来进行http请求的过程，这对于Volley的整个流程是不受影响。\n\n-----\n\n#### Network\n\n```java\npublic interface Network {\n    /**\n     * Performs the specified request.\n     * @param request Request to process\n     * @return A {@link NetworkResponse} with data and caching metadata; will never be null\n     * @throws VolleyError on errors\n     */\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError;\n}\n```\n\nNetwork接口中定义了performRequest用于接收一个具体的Request请求，其实现类是BasicNetwork，我们直接查看performRequest方法：\n\n```java\n@Override\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError {\n        long requestStart = SystemClock.elapsedRealtime();\n      \t//死循环\n        while (true) {\n            HttpResponse httpResponse = null;\n            byte[] responseContents = null;\n            Map<String, String> responseHeaders = Collections.emptyMap();\n            try {\n                // Gather headers.\n                Map<String, String> headers = new HashMap<String, String>();\n                addCacheHeaders(headers, request.getCacheEntry());\n              \t//通过HttpStack获得HttpResponse\n                httpResponse = mHttpStack.performRequest(request, headers);\n                StatusLine statusLine = httpResponse.getStatusLine();\n                int statusCode = statusLine.getStatusCode();\n\t\t\t\t//返回的请求头\n                responseHeaders = convertHeaders(httpResponse.getAllHeaders());\n                //请求返回的状态码处理\n                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {\n                    Entry entry = request.getCacheEntry();\n                    if (entry == null) {\n                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,\n                                responseHeaders, true,\n                                SystemClock.elapsedRealtime() - requestStart);\n                    }\n\n                    entry.responseHeaders.putAll(responseHeaders);\n                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,\n                            entry.responseHeaders, true,\n                            SystemClock.elapsedRealtime() - requestStart);\n                }\n                \n                // Handle moved resources\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                \tString newUrl = responseHeaders.get(\"Location\");\n                \trequest.setRedirectUrl(newUrl);\n                }\n\n                // Some responses such as 204s do not have content.  We must check.\n                if (httpResponse.getEntity() != null) {\n                  responseContents = entityToBytes(httpResponse.getEntity());\n                } else {\n                  // Add 0 byte response as a way of honestly representing a\n                  // no-content request.\n                  responseContents = new byte[0];\n                }\n\n                // if the request is slow, log it.\n                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;\n                logSlowRequests(requestLifetime, request, responseContents, statusLine);\n\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new IOException();\n                }\n                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,\n                        SystemClock.elapsedRealtime() - requestStart);\n            \t...\n                int statusCode = 0;\n                NetworkResponse networkResponse = null;\n                if (httpResponse != null) {\n                    statusCode = httpResponse.getStatusLine().getStatusCode();\n                } else {\n                    throw new NoConnectionError(e);\n                }\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                \t\tstatusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                \tVolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl());\n                } else {\n                \tVolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl());\n                }\n                if (responseContents != null) {\n                    networkResponse = new NetworkResponse(statusCode, responseContents,\n                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);\n                    ...\n            }\n        }\n    }\n```\n\n在BasicNetwork中，我们可以看到其通过写了一个死循环来保证重复请求的操作直到报错或者返回结果，在其中他会调用mHttpStack.performRequest(request, headers)来获得一个HttpResponse，调用entityToBytes()将entity转换成一个字节数组，并且获取相关参数(header,statusCode .etc)去进一步的构造出一个NetworkResponse，并且返回：\n\n```java\n    public NetworkResponse(int statusCode, byte[] data, Map<String, String> headers,\n            boolean notModified, long networkTimeMs) {\n        this.statusCode = statusCode;\n        this.data = data;\n        this.headers = headers;\n        this.notModified = notModified;\n        this.networkTimeMs = networkTimeMs;\n    }\n\n    public NetworkResponse(int statusCode, byte[] data, Map<String, String> headers,\n            boolean notModified) {\n        this(statusCode, data, headers, notModified, 0);\n    }\n\n    public NetworkResponse(byte[] data) {\n        this(HttpStatus.SC_OK, data, Collections.<String, String>emptyMap(), false, 0);\n    }\n\n    public NetworkResponse(byte[] data, Map<String, String> headers) {\n        this(HttpStatus.SC_OK, data, headers, false, 0);\n    }\n\n    /**Http状态码 */\n    public final int statusCode;\n\n    /**网络请求返回的字节数据 */\n    public final byte[] data;\n\n    /**返回的请求头 */\n    public final Map<String, String> headers;\n\n    /** 是否返回的304的状态码*/\n    public final boolean notModified;\n\n    /** 请求耗时. */\n    public final long networkTimeMs;\n```\n\n\n\n------\n\n#### RequestQueue\n\nRequestQueue是一个请求队列，Volley将所有Request请求维护在此请求对列当中，内部有两个对应缓存和网络的请求阻塞队列来对Request进行维护，并且通过不同的Dispatcher(extends Thread)进行进一步的请求结果的处理，主要代码如下：\n\n```java\npublic class RequestQueue {\n\n    /** 所有请求完成后的回调 */\n    public static interface RequestFinishedListener<T> {\n        /** Called when a request has finished processing. */\n        public void onRequestFinished(Request<T> request);\n    }\n\t...\n  \t//等待请求的Request，如果一个请求可以进行缓存，则后续的相同CacheKey的请求，将进入此等待队列。\n    private final Map<String, Queue<Request<?>>> mWaitingRequests =\n            new HashMap<String, Queue<Request<?>>>();\n  \t//当前请求以及未完成的请求\n    private final Set<Request<?>> mCurrentRequests = new HashSet<Request<?>>();\n    /** 缓存请求阻塞队列 */\n    private final PriorityBlockingQueue<Request<?>> mCacheQueue =\n        new PriorityBlockingQueue<Request<?>>();\n    /** 网络请求阻塞队列 */\n    private final PriorityBlockingQueue<Request<?>> mNetworkQueue =\n        new PriorityBlockingQueue<Request<?>>();\n  \t//网络请求线程池大小\n    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;\n\t...\n      \n  \t//网络dispatcher数组\n    private NetworkDispatcher[] mDispatchers;\n\n    //缓存dispatcher\n    private CacheDispatcher mCacheDispatcher;\n\t//Request完成listener\n    private List<RequestFinishedListener> mFinishedListeners =\n            new ArrayList<RequestFinishedListener>();\n\n    public RequestQueue(Cache cache, Network network, int threadPoolSize,\n            ResponseDelivery delivery) {\n        mCache = cache;\n        mNetwork = network;\n      \t//初始化网络Dispatcher\n        mDispatchers = new NetworkDispatcher[threadPoolSize];\n        mDelivery = delivery;\n    }\n    /**\n     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，\n     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。\n     */\n    public void start() {\n        stop();  // Make sure any currently running dispatchers are stopped.\n        // 启动缓存请求队列\n        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n        mCacheDispatcher.start();\n\n        // Create network dispatchers (and corresponding threads) up to the pool size.\n      \t//创造网络请求队列\n        for (int i = 0; i < mDispatchers.length; i++) {\n            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                    mCache, mDelivery);\n            mDispatchers[i] = networkDispatcher;\n            networkDispatcher.start();\n        }\n    }\n\t...\n\n    /**\n     * 添加新的请求到请求对列当中\n     */\n    public <T> Request<T> add(Request<T> request) {\n        ...\n    }\n\n    ...\n    <T> void finish(Request<T> request) {\n        // Remove from the set of requests currently being processed.\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.remove(request);\n        }\n        synchronized (mFinishedListeners) {\n          for (RequestFinishedListener<T> listener : mFinishedListeners) {\n            listener.onRequestFinished(request);\n          }\n        }\n\n        if (request.shouldCache()) {\n            synchronized (mWaitingRequests) {\n                String cacheKey = request.getCacheKey();\n                Queue<Request<?>> waitingRequests = mWaitingRequests.remove(cacheKey);\n                if (waitingRequests != null) {\n                    mCacheQueue.addAll(waitingRequests);\n                }\n            }\n        }\n    }\n\n  \t....\n}\n```\n\nRequestQueue是Volley中最核心的类，掌管着所有request的请求和调度的过程，可以说是一个中转器的作用，我们从刚开始的start()方法看起：\n\n```java\n/**\n     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，\n     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。\n     */\n    public void start() {\n        stop();  // Make sure any currently running dispatchers are stopped.\n        // 启动缓存请求队列\n        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n        mCacheDispatcher.start();\n\n      \t//创造网络请求队列\n        for (int i = 0; i < mDispatchers.length; i++) {\n            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                    mCache, mDelivery);\n            mDispatchers[i] = networkDispatcher;\n            networkDispatcher.start();\n        }\n    }\n\n```\n\n在调用start()时候，主要做了两件事情:\n\n- 调用stop()终止所有的dispatcher\n- 初始化所有的dispatcher，并且start(),dispatcher都是继承于Thread的类\n\n一般我们进行请求时候，都是使用的add(Request)方法来进行，所以接下来就查看一下这个方法的实现过程：\n\n```java\n /**\n     * 添加新的请求到请求对列当中\n     */\n    public <T> Request<T> add(Request<T> request) {\n        // 设置对应关联\n        request.setRequestQueue(this);\n      \t//添加到CurrentRequests中\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.add(request);\n        }\n\n        // 按添加到请求队列的顺序请求数据\n        request.setSequence(getSequenceNumber());\n      \t//添加标志\n        request.addMarker(\"add-to-queue\");\n      \t//当前request是否有缓存过，没有直接加入到网络请求队列中\n        if (!request.shouldCache()) {\n            mNetworkQueue.add(request);\n            return request;\n        }\n\n        synchronized (mWaitingRequests) {\n          \t//得到缓存key(该key为medthod+url的单一key)\n            String cacheKey = request.getCacheKey();\n          \t//是否包含该缓存key\n            if (mWaitingRequests.containsKey(cacheKey)) {\n                // There is already a request in flight. Queue up.\n                Queue<Request<?>> stagedRequests = mWaitingRequests.get(cacheKey);\n                if (stagedRequests == null) {\n                    stagedRequests = new LinkedList<Request<?>>();\n                }\n                stagedRequests.add(request);\n                mWaitingRequests.put(cacheKey, stagedRequests);\n                if (VolleyLog.DEBUG) {\n                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n                }\n            } else {\n                // Insert 'null' queue for this cacheKey, indicating there is now a request in\n                // flight.\n                mWaitingRequests.put(cacheKey, null);\n                mCacheQueue.add(request);\n            }\n            return request;\n        }\n    }\n```\n\n在add()方法中主要的过程如图所示:\n\n{% asset_img reuqestqueue_add.png reuqestqueue.add() %}\n\n主要实现思路如下：\n\n1. 添加到mCurrentRequests中，mCurrentRequests当前请求以及未完成的请求的set，所有通过add()进来的都会加入到\b此set的当中。\n2. 通过request.shouldCache()来判断是否需要缓存request，如果不需要则直接加入到网络请求队列当中，return；如果需要缓存当前request则判断mWaitingRequests是否包含了该request的CacheKey的setKey，如果有，则加入相同的队列当中，则put到mWaitingRequests当中，如果没有包含了该request的CacheKey的setKey，置空与当前request的相同的queue(mWaitingRequests.put(cacheKey, null))，然后把request加入到缓存请求对列当中。\n\nadd()方法中主要是为了找到request的存放地，是网络请求队列还是缓存请求队列，在判断是否加入到缓存请求队列时维护了一个mWaitingRequests集合来管理相同的请求，如果cacheKey相同，则不会加入到任何请对队列当中，然后加入到mWaitingRequests存有相同SetKey的SetValue中，挂起。\n\n\n\n-------\n\n<h4>Dispatcher</h4>\n\n返回RequestQueue.start()中，这里会将CacheDispatcher和NetworkDispatchers启动，两种Dispatcher共同继承于Thread来处理延时操作--网络请求和缓存请求的过程，这里只详细讲述CacheDispatcher的run()过程，NetworkDispatchers只以简述的形式讲述。\n\nCacheDispatcher在run方法中写死一个无限循环，可以类比成handler机制中的Looper.loop()的设计思路，不断的轮训缓存队列(mCacheQueue)，从中取出request将其传递给mDelivery来进行处理。\n\n```java\n@Override\n    public void run() {\n\t\t//设置线程优先级\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        // 初始化缓存相关参数\n        mCache.initialize();\n\n        while (true) {\n            try {\n                //从mCacheQueue取缓存\n                final Request<?> request = mCacheQueue.take();\n              \t//添加缓存过的标记\n                request.addMarker(\"cache-queue-take\");\n\n                // 当前request是否取消了\n                if (request.isCanceled()) {\n                    request.finish(\"cache-discard-canceled\");\n                    continue;\n                }\n\n                // Attempt to retrieve this item from cache.\n                Cache.Entry entry = mCache.get(request.getCacheKey());\n                if (entry == null) {\n                    request.addMarker(\"cache-miss\");\n                    // Cache miss; send off to the network dispatcher.\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                // If it is completely expired, just send it to the network.\n                if (entry.isExpired()) {\n                    request.addMarker(\"cache-hit-expired\");\n                    request.setCacheEntry(entry);\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                // We have a cache hit; parse its data for delivery back to the request.\n                request.addMarker(\"cache-hit\");\n                Response<?> response = request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n                request.addMarker(\"cache-hit-parsed\");\n\t\t\t\t//缓存数据是否需要更新\n                if (!entry.refreshNeeded()) {\n                    // Completely unexpired cache hit. Just deliver the response.\n                    mDelivery.postResponse(request, response);\n                } else {\n                    // Soft-expired cache hit. We can deliver the cached response,\n                    // but we need to also send the request to the network for\n                    // refreshing.\n                    request.addMarker(\"cache-hit-refresh-needed\");\n                    request.setCacheEntry(entry);\n\n                    // Mark the response as intermediate.\n                    response.intermediate = true;\n\n                    // Post the intermediate response back to the user and have\n                    // the delivery then forward the request along to the network.\n                    mDelivery.postResponse(request, response, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                mNetworkQueue.put(request);\n                            } catch (InterruptedException e) {\n                                // Not much we can do about this.\n                            }\n                        }\n                    });\n                }\n\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n        }\n    }\n```\n\nrun方法内循环的过程中每次从mCacheQueue拿出一个request请求，对其添加已经访问过的marker，如果在期间request被取消了，最终会调用RequestQueue.finish()方法从mCurrentRequests中remove掉，一次循环完成；如果request没被取消则从缓存中获取数据，并且判断是否为空，如果为空则加入网络队列中重新请求，一次循环完成；如果不为空判断是否过期，过期了则加入网络队列中重新请求，一次循环完成；如果不过期判断是否需要更新缓存，需要则加入网络队列中重新请求，否则调用mDelivery.postResponse()完成数据传递的过程，执行图如下：\n\n{% asset_img CacheDispatcher_run.png CacheDispatcher.run() %}\n\nNetworkDispatcher也继承自Thread接口，run方法实现代码如下：\n\n```java\n@Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        while (true) {\n            long startTimeMs = SystemClock.elapsedRealtime();\n            Request<?> request;\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                //获取到请求结果\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                // Parse the response here on the worker thread.\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n              \t//是否缓存结果\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n                // Post the response back.\n                request.markDelivered();\n              \t//交付给mDelivery\n                mDelivery.postResponse(request, response);\n            } catch (VolleyError volleyError) {\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                parseAndDeliverNetworkError(request, volleyError);\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n```\n\n在NetworkDispatcher中主要通过Network接口performRequest()方法获得一个NetworkResponse,进而在转换成Delivery.postResponse()可接受的Request对象进行传递，其中会判断是否需要缓存该request以及相关error的捕获并且传递给Delivery.postError()。\n\n-----\n\n<h3>ResponseDelivery</h3>\n\n无论是CacheDispatcher还是NetworkDispatcher，最终的结果都是交付由ResponseDelivery接口实现类来进行实现:\n\n```java\npublic interface ResponseDelivery {\n    /**\n     * Parses a response from the network or cache and delivers it.\n     */\n    public void postResponse(Request<?> request, Response<?> response);\n\n    /**\n     * 处理从缓存和网络上获取的数据\n     */\n    public void postResponse(Request<?> request, Response<?> response, Runnable runnable);\n\n    /**\n     *处理错误的情况\n     */\n    public void postError(Request<?> request, VolleyError error);\n}\n```\n\n其具体实现类为ExecutorDelivery中，其代码如下：\n\n```java\n/**\n * 将请求结果传递给回调接口\n */\npublic class ExecutorDelivery implements ResponseDelivery {\n    /** Used for posting responses, typically to the main thread. */\n    private final Executor mResponsePoster;\n\n    /**\n     * 传入Handler的原因，目的是为了与主线程进行交互\n     * @param handler {@link Handler} to post responses on\n     */\n    public ExecutorDelivery(final Handler handler) {\n        // Make an Executor that just wraps the handler.\n        mResponsePoster = new Executor() {\n            @Override\n            public void execute(Runnable command) {\n                handler.post(command);\n            }\n        };\n    }\n\t...\n      \n    @Override\n    public void postResponse(Request<?> request, Response<?> response, Runnable runnable) {\n      \t//request传递标记\n        request.markDelivered();\n        request.addMarker(\"post-response\");\n        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));\n    }\n\n    @Override\n    public void postError(Request<?> request, VolleyError error) {\n        request.addMarker(\"post-error\");\n        Response<?> response = Response.error(error);\n        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));\n    }\n\n    /**\n     * A Runnable used for delivering network responses to a listener on the\n     * main thread.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    private class ResponseDeliveryRunnable implements Runnable {\n        private final Request mRequest;\n        private final Response mResponse;\n        private final Runnable mRunnable;\n\n        public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {\n            mRequest = request;\n            mResponse = response;\n            mRunnable = runnable;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public void run() {\n            // If this request has canceled, finish it and don't deliver.\n            if (mRequest.isCanceled()) {\n                mRequest.finish(\"canceled-at-delivery\");\n                return;\n            }\n\n            // 传递请求的结果，对应调用相应的回调接口，看mRequest对应实现类\n          \t//如果是StringRequest，则回调对应接口。\n            if (mResponse.isSuccess()) {\n                mRequest.deliverResponse(mResponse.result);\n            } else {\n                mRequest.deliverError(mResponse.error);\n            }\n\n            // If this is an intermediate response, add a marker, otherwise we're done\n            // and the request can be finished.\n            if (mResponse.intermediate) {\n                mRequest.addMarker(\"intermediate-response\");\n            } else {\n                mRequest.finish(\"done\");\n            }\n\n            // If we have been provided a post-delivery runnable, run it.\n            if (mRunnable != null) {\n                mRunnable.run();\n            }\n       }\n    }\n}\n```\n\n从Dispatcher那边获取到request和response最终传递到内部类ResponseDeliveryRunnable中进行处理，如果request是被finish的则丢弃传递，否则调用Request的对应的deliverResponse或者deliverError方法。这里要注意以下，该方法中传递了handler变量进来，这个变量是主线程的handler，也就保证了request的回调从工作线程切换回了主线程，其初始化代码如下：\n\n```java\npublic RequestQueue(Cache cache, Network network, int threadPoolSize) {\n        this(cache, network, threadPoolSize,\n                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n    }\n```\n\n\n\n-------\n\n<h4>Request</h4>\n\nRequest类是一个抽象方法，其子类实现主要有：StringRequest，JsonRequest，ImageRequest .etc ，为了简单查看后续步骤，我们拿StringRequest来查看：\n\n```java\n /**\n     * Delivers error message to the ErrorListener that the Request was\n     * initialized with.\n     *\n     * @param error Error details\n     */\n    public void deliverError(VolleyError error) {\n        if (mErrorListener != null) {\n            mErrorListener.onErrorResponse(error);\n        }\n    }\n  @Override\n    protected void deliverResponse(String response) {\n        if (mListener != null) {\n            mListener.onResponse(response);\n        }\n    }\n```\n\n到这里就执行到了最终的回调，所有的过程也就完成了。\n\n------\n\n<h4>个人总结</h4>\n\n个人认为volley的精髓在于面向接口编程，具有非常广阔的拓展性，开发者完全可以自主写一套自己的volley逻辑，充分解耦了各个模块，使用组合的方式进行编程，是我们学习设计代码的一个非常好的库吧。\n\n\n\n附上Volley过程图：\n{% asset_img volley_flowchart.png volley流程图 %}\n","source":"_posts/volley源码学习.md","raw":"---\ntitle: volley源码学习\ndate: 2016-12-09 12:52:19\ncategories: \n- Android开源库源码分析\ntags: \n- android\n---\n\n----\n\nVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布的，现在连android系统中内部也是使用了Volley作为其网络的请求框架，谷歌出品，必属精品，所以有必要进行一次梳理其实现的总体过程，学习其设计框架的思路也是必要的(文章适合知道基本使用Volley的同学观看)。\n<!--more-->\n-------\n\n<h3>Volley</h3>\n\n一般我们都会在app初始化的时候调用如下代码进行初始化Volley，下面就从该方法当做阅读入口进行逐一跟踪：\n\n```java\nmRequestQueue =  Volley.newRequestQueue(this); \n```\n\n在调用Volley.newRequestQueue(this)时，最终调用到如下代码:\n\n```java\n /**\n     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.\n     * You may set a maximum size of the disk cache in bytes.\n     *HttpStack是用来进行网络请求封装的类，传入null代表默认\n     *maxDiskCacheBytes为最大磁盘缓存，传入-1使用默认大小\n     */\n    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n      //构造缓存区域\n        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n        String userAgent = \"volley/0\";\n        try {\n            String packageName = context.getPackageName();\n            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n            userAgent = packageName + \"/\" + info.versionCode;\n        } catch (NameNotFoundException e) {\n        }\n\t\t//我们可以传入okttp来充当我们的httpStack\n        if (stack == null) {\n          //使用Volley默认封装的stack，依靠android版本来决定使用不同的connection来进行网络请求\n            if (Build.VERSION.SDK_INT >= 9) {\n                stack = new HurlStack();\n            } else {\n                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n            }\n        }\n\n        Network network = new BasicNetwork(stack);\n        \n        RequestQueue queue;\n        if (maxDiskCacheBytes <= -1)\n        {\n        \t// No maximum size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir), network);\n        }\n        else\n        {\n        \t// Disk cache size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);\n        }\n\n        queue.start();\n\n        return queue;\n    }\n```\n\n在newRequestQueue\b方法中进行了相关必要参数的初始化的工作，其中包括:\n\n- 缓存区域的初始化\n- HttpStack的初始化\n- Network的初始化\n- RequestQueue的初始化，最终调用其start()方法\n\n------\n\n#### Stack 详解\n\n在Volley中如果没有传递任何HttpStack则会使用了两种stack来进行不同android版本(SDK_INT >= 9?HurlStack:HttpClientStack)的适配工作：HurlStack和HttpClientStack，两种stack都实现了HttpStack接口，接口定义如下：\n\n```java\npublic interface HttpStack {\n    //请求处理方法\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n        throws IOException, AuthFailureError;\n\n}\n```\n\n在接口中定义performRequest方法，在其子类中实现了对于http请求的封装的操作，以此来查看对应实现子类的performRequest方法。\n\n在HurlStack中关于performRequest(…)的实现：\n\n```java\n@Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n        String url = request.getUrl();\n      //存放请求头\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.putAll(request.getHeaders());\n        map.putAll(additionalHeaders);\n      //是否重写url\n        if (mUrlRewriter != null) {\n            String rewritten = mUrlRewriter.rewriteUrl(url);\n            if (rewritten == null) {\n                throw new IOException(\"URL blocked by rewriter: \" + url);\n            }\n            url = rewritten;\n        }\n        URL parsedUrl = new URL(url);\n      //使用后HttpURLConnection进行网络请求\n        HttpURLConnection connection = openConnection(parsedUrl, request);\n        for (String headerName : map.keySet()) {\n            connection.addRequestProperty(headerName, map.get(headerName));\n        }\n      //设置请求方法：GET ,POST, ect\n        setConnectionParametersForRequest(connection, request);\n        // Initialize HttpResponse with data from the HttpURLConnection.\n        ProtocolVersion protocolVersion = new ProtocolVersion(\"HTTP\", 1, 1);\n        int responseCode = connection.getResponseCode();\n        if (responseCode == -1) {\n            // -1 is returned by getResponseCode() if the response code could not be retrieved.\n            // Signal to the caller that something was wrong with the connection.\n            throw new IOException(\"Could not retrieve response code from HttpUrlConnection.\");\n        }\n        StatusLine responseStatus = new BasicStatusLine(protocolVersion,\n                connection.getResponseCode(), connection.getResponseMessage());\n        BasicHttpResponse response = new BasicHttpResponse(responseStatus);\n      \t//将返回的数据流写入response\n        response.setEntity(entityFromConnection(connection));\n      \t//获取返回的请求头\n        for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));\n                response.addHeader(h);\n            }\n        }\n        return response;\n    }\n```\n\nHurlStack使用HttpURLConnection进行Http请求的过程，步骤是基本的网络请求的过程，设置请求头->包装Url->打开连接->设置请求方法->获取数据已经请求状态->将数据流存入HttpResponse，最终返回一个HttpResponse。\n\nHttpClientStack中关于performRequest(…)的实现：\n\n```java\n@Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n      \t//构造请求参数\n        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);\n      \t//添加请求头\n        addHeaders(httpRequest, additionalHeaders);\n        addHeaders(httpRequest, request.getHeaders());\n        onPrepareRequest(httpRequest);\n        HttpParams httpParams = httpRequest.getParams();\n        int timeoutMs = request.getTimeoutMs();\n        // TODO: Reevaluate this connection timeout based on more wide-scale\n        // data collection and possibly different for wifi vs. 3G.\n        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);\n        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);\n        return mClient.execute(httpRequest);\n    }\n```\n\nHttpClientStack\b执行的大体过程与HurlStack基本上一致，通过一系列操作最终调用AndroidHttpClient.execute(httpRequest)返回一个HttpResponse。\n\n\n\nHttpStack封装了http请求的过程，并且只管http请求，满足设计模式中单一责任的原则，并且向外提供接口HttpStack方便使用者定制自身的HttpStack类来进行请求的过程，如：可以用OkhttpClient来进行http请求的过程，这对于Volley的整个流程是不受影响。\n\n-----\n\n#### Network\n\n```java\npublic interface Network {\n    /**\n     * Performs the specified request.\n     * @param request Request to process\n     * @return A {@link NetworkResponse} with data and caching metadata; will never be null\n     * @throws VolleyError on errors\n     */\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError;\n}\n```\n\nNetwork接口中定义了performRequest用于接收一个具体的Request请求，其实现类是BasicNetwork，我们直接查看performRequest方法：\n\n```java\n@Override\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError {\n        long requestStart = SystemClock.elapsedRealtime();\n      \t//死循环\n        while (true) {\n            HttpResponse httpResponse = null;\n            byte[] responseContents = null;\n            Map<String, String> responseHeaders = Collections.emptyMap();\n            try {\n                // Gather headers.\n                Map<String, String> headers = new HashMap<String, String>();\n                addCacheHeaders(headers, request.getCacheEntry());\n              \t//通过HttpStack获得HttpResponse\n                httpResponse = mHttpStack.performRequest(request, headers);\n                StatusLine statusLine = httpResponse.getStatusLine();\n                int statusCode = statusLine.getStatusCode();\n\t\t\t\t//返回的请求头\n                responseHeaders = convertHeaders(httpResponse.getAllHeaders());\n                //请求返回的状态码处理\n                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {\n                    Entry entry = request.getCacheEntry();\n                    if (entry == null) {\n                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,\n                                responseHeaders, true,\n                                SystemClock.elapsedRealtime() - requestStart);\n                    }\n\n                    entry.responseHeaders.putAll(responseHeaders);\n                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,\n                            entry.responseHeaders, true,\n                            SystemClock.elapsedRealtime() - requestStart);\n                }\n                \n                // Handle moved resources\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                \tString newUrl = responseHeaders.get(\"Location\");\n                \trequest.setRedirectUrl(newUrl);\n                }\n\n                // Some responses such as 204s do not have content.  We must check.\n                if (httpResponse.getEntity() != null) {\n                  responseContents = entityToBytes(httpResponse.getEntity());\n                } else {\n                  // Add 0 byte response as a way of honestly representing a\n                  // no-content request.\n                  responseContents = new byte[0];\n                }\n\n                // if the request is slow, log it.\n                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;\n                logSlowRequests(requestLifetime, request, responseContents, statusLine);\n\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new IOException();\n                }\n                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,\n                        SystemClock.elapsedRealtime() - requestStart);\n            \t...\n                int statusCode = 0;\n                NetworkResponse networkResponse = null;\n                if (httpResponse != null) {\n                    statusCode = httpResponse.getStatusLine().getStatusCode();\n                } else {\n                    throw new NoConnectionError(e);\n                }\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                \t\tstatusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                \tVolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl());\n                } else {\n                \tVolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl());\n                }\n                if (responseContents != null) {\n                    networkResponse = new NetworkResponse(statusCode, responseContents,\n                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);\n                    ...\n            }\n        }\n    }\n```\n\n在BasicNetwork中，我们可以看到其通过写了一个死循环来保证重复请求的操作直到报错或者返回结果，在其中他会调用mHttpStack.performRequest(request, headers)来获得一个HttpResponse，调用entityToBytes()将entity转换成一个字节数组，并且获取相关参数(header,statusCode .etc)去进一步的构造出一个NetworkResponse，并且返回：\n\n```java\n    public NetworkResponse(int statusCode, byte[] data, Map<String, String> headers,\n            boolean notModified, long networkTimeMs) {\n        this.statusCode = statusCode;\n        this.data = data;\n        this.headers = headers;\n        this.notModified = notModified;\n        this.networkTimeMs = networkTimeMs;\n    }\n\n    public NetworkResponse(int statusCode, byte[] data, Map<String, String> headers,\n            boolean notModified) {\n        this(statusCode, data, headers, notModified, 0);\n    }\n\n    public NetworkResponse(byte[] data) {\n        this(HttpStatus.SC_OK, data, Collections.<String, String>emptyMap(), false, 0);\n    }\n\n    public NetworkResponse(byte[] data, Map<String, String> headers) {\n        this(HttpStatus.SC_OK, data, headers, false, 0);\n    }\n\n    /**Http状态码 */\n    public final int statusCode;\n\n    /**网络请求返回的字节数据 */\n    public final byte[] data;\n\n    /**返回的请求头 */\n    public final Map<String, String> headers;\n\n    /** 是否返回的304的状态码*/\n    public final boolean notModified;\n\n    /** 请求耗时. */\n    public final long networkTimeMs;\n```\n\n\n\n------\n\n#### RequestQueue\n\nRequestQueue是一个请求队列，Volley将所有Request请求维护在此请求对列当中，内部有两个对应缓存和网络的请求阻塞队列来对Request进行维护，并且通过不同的Dispatcher(extends Thread)进行进一步的请求结果的处理，主要代码如下：\n\n```java\npublic class RequestQueue {\n\n    /** 所有请求完成后的回调 */\n    public static interface RequestFinishedListener<T> {\n        /** Called when a request has finished processing. */\n        public void onRequestFinished(Request<T> request);\n    }\n\t...\n  \t//等待请求的Request，如果一个请求可以进行缓存，则后续的相同CacheKey的请求，将进入此等待队列。\n    private final Map<String, Queue<Request<?>>> mWaitingRequests =\n            new HashMap<String, Queue<Request<?>>>();\n  \t//当前请求以及未完成的请求\n    private final Set<Request<?>> mCurrentRequests = new HashSet<Request<?>>();\n    /** 缓存请求阻塞队列 */\n    private final PriorityBlockingQueue<Request<?>> mCacheQueue =\n        new PriorityBlockingQueue<Request<?>>();\n    /** 网络请求阻塞队列 */\n    private final PriorityBlockingQueue<Request<?>> mNetworkQueue =\n        new PriorityBlockingQueue<Request<?>>();\n  \t//网络请求线程池大小\n    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;\n\t...\n      \n  \t//网络dispatcher数组\n    private NetworkDispatcher[] mDispatchers;\n\n    //缓存dispatcher\n    private CacheDispatcher mCacheDispatcher;\n\t//Request完成listener\n    private List<RequestFinishedListener> mFinishedListeners =\n            new ArrayList<RequestFinishedListener>();\n\n    public RequestQueue(Cache cache, Network network, int threadPoolSize,\n            ResponseDelivery delivery) {\n        mCache = cache;\n        mNetwork = network;\n      \t//初始化网络Dispatcher\n        mDispatchers = new NetworkDispatcher[threadPoolSize];\n        mDelivery = delivery;\n    }\n    /**\n     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，\n     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。\n     */\n    public void start() {\n        stop();  // Make sure any currently running dispatchers are stopped.\n        // 启动缓存请求队列\n        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n        mCacheDispatcher.start();\n\n        // Create network dispatchers (and corresponding threads) up to the pool size.\n      \t//创造网络请求队列\n        for (int i = 0; i < mDispatchers.length; i++) {\n            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                    mCache, mDelivery);\n            mDispatchers[i] = networkDispatcher;\n            networkDispatcher.start();\n        }\n    }\n\t...\n\n    /**\n     * 添加新的请求到请求对列当中\n     */\n    public <T> Request<T> add(Request<T> request) {\n        ...\n    }\n\n    ...\n    <T> void finish(Request<T> request) {\n        // Remove from the set of requests currently being processed.\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.remove(request);\n        }\n        synchronized (mFinishedListeners) {\n          for (RequestFinishedListener<T> listener : mFinishedListeners) {\n            listener.onRequestFinished(request);\n          }\n        }\n\n        if (request.shouldCache()) {\n            synchronized (mWaitingRequests) {\n                String cacheKey = request.getCacheKey();\n                Queue<Request<?>> waitingRequests = mWaitingRequests.remove(cacheKey);\n                if (waitingRequests != null) {\n                    mCacheQueue.addAll(waitingRequests);\n                }\n            }\n        }\n    }\n\n  \t....\n}\n```\n\nRequestQueue是Volley中最核心的类，掌管着所有request的请求和调度的过程，可以说是一个中转器的作用，我们从刚开始的start()方法看起：\n\n```java\n/**\n     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，\n     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。\n     */\n    public void start() {\n        stop();  // Make sure any currently running dispatchers are stopped.\n        // 启动缓存请求队列\n        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n        mCacheDispatcher.start();\n\n      \t//创造网络请求队列\n        for (int i = 0; i < mDispatchers.length; i++) {\n            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                    mCache, mDelivery);\n            mDispatchers[i] = networkDispatcher;\n            networkDispatcher.start();\n        }\n    }\n\n```\n\n在调用start()时候，主要做了两件事情:\n\n- 调用stop()终止所有的dispatcher\n- 初始化所有的dispatcher，并且start(),dispatcher都是继承于Thread的类\n\n一般我们进行请求时候，都是使用的add(Request)方法来进行，所以接下来就查看一下这个方法的实现过程：\n\n```java\n /**\n     * 添加新的请求到请求对列当中\n     */\n    public <T> Request<T> add(Request<T> request) {\n        // 设置对应关联\n        request.setRequestQueue(this);\n      \t//添加到CurrentRequests中\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.add(request);\n        }\n\n        // 按添加到请求队列的顺序请求数据\n        request.setSequence(getSequenceNumber());\n      \t//添加标志\n        request.addMarker(\"add-to-queue\");\n      \t//当前request是否有缓存过，没有直接加入到网络请求队列中\n        if (!request.shouldCache()) {\n            mNetworkQueue.add(request);\n            return request;\n        }\n\n        synchronized (mWaitingRequests) {\n          \t//得到缓存key(该key为medthod+url的单一key)\n            String cacheKey = request.getCacheKey();\n          \t//是否包含该缓存key\n            if (mWaitingRequests.containsKey(cacheKey)) {\n                // There is already a request in flight. Queue up.\n                Queue<Request<?>> stagedRequests = mWaitingRequests.get(cacheKey);\n                if (stagedRequests == null) {\n                    stagedRequests = new LinkedList<Request<?>>();\n                }\n                stagedRequests.add(request);\n                mWaitingRequests.put(cacheKey, stagedRequests);\n                if (VolleyLog.DEBUG) {\n                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n                }\n            } else {\n                // Insert 'null' queue for this cacheKey, indicating there is now a request in\n                // flight.\n                mWaitingRequests.put(cacheKey, null);\n                mCacheQueue.add(request);\n            }\n            return request;\n        }\n    }\n```\n\n在add()方法中主要的过程如图所示:\n\n{% asset_img reuqestqueue_add.png reuqestqueue.add() %}\n\n主要实现思路如下：\n\n1. 添加到mCurrentRequests中，mCurrentRequests当前请求以及未完成的请求的set，所有通过add()进来的都会加入到\b此set的当中。\n2. 通过request.shouldCache()来判断是否需要缓存request，如果不需要则直接加入到网络请求队列当中，return；如果需要缓存当前request则判断mWaitingRequests是否包含了该request的CacheKey的setKey，如果有，则加入相同的队列当中，则put到mWaitingRequests当中，如果没有包含了该request的CacheKey的setKey，置空与当前request的相同的queue(mWaitingRequests.put(cacheKey, null))，然后把request加入到缓存请求对列当中。\n\nadd()方法中主要是为了找到request的存放地，是网络请求队列还是缓存请求队列，在判断是否加入到缓存请求队列时维护了一个mWaitingRequests集合来管理相同的请求，如果cacheKey相同，则不会加入到任何请对队列当中，然后加入到mWaitingRequests存有相同SetKey的SetValue中，挂起。\n\n\n\n-------\n\n<h4>Dispatcher</h4>\n\n返回RequestQueue.start()中，这里会将CacheDispatcher和NetworkDispatchers启动，两种Dispatcher共同继承于Thread来处理延时操作--网络请求和缓存请求的过程，这里只详细讲述CacheDispatcher的run()过程，NetworkDispatchers只以简述的形式讲述。\n\nCacheDispatcher在run方法中写死一个无限循环，可以类比成handler机制中的Looper.loop()的设计思路，不断的轮训缓存队列(mCacheQueue)，从中取出request将其传递给mDelivery来进行处理。\n\n```java\n@Override\n    public void run() {\n\t\t//设置线程优先级\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        // 初始化缓存相关参数\n        mCache.initialize();\n\n        while (true) {\n            try {\n                //从mCacheQueue取缓存\n                final Request<?> request = mCacheQueue.take();\n              \t//添加缓存过的标记\n                request.addMarker(\"cache-queue-take\");\n\n                // 当前request是否取消了\n                if (request.isCanceled()) {\n                    request.finish(\"cache-discard-canceled\");\n                    continue;\n                }\n\n                // Attempt to retrieve this item from cache.\n                Cache.Entry entry = mCache.get(request.getCacheKey());\n                if (entry == null) {\n                    request.addMarker(\"cache-miss\");\n                    // Cache miss; send off to the network dispatcher.\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                // If it is completely expired, just send it to the network.\n                if (entry.isExpired()) {\n                    request.addMarker(\"cache-hit-expired\");\n                    request.setCacheEntry(entry);\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                // We have a cache hit; parse its data for delivery back to the request.\n                request.addMarker(\"cache-hit\");\n                Response<?> response = request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n                request.addMarker(\"cache-hit-parsed\");\n\t\t\t\t//缓存数据是否需要更新\n                if (!entry.refreshNeeded()) {\n                    // Completely unexpired cache hit. Just deliver the response.\n                    mDelivery.postResponse(request, response);\n                } else {\n                    // Soft-expired cache hit. We can deliver the cached response,\n                    // but we need to also send the request to the network for\n                    // refreshing.\n                    request.addMarker(\"cache-hit-refresh-needed\");\n                    request.setCacheEntry(entry);\n\n                    // Mark the response as intermediate.\n                    response.intermediate = true;\n\n                    // Post the intermediate response back to the user and have\n                    // the delivery then forward the request along to the network.\n                    mDelivery.postResponse(request, response, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                mNetworkQueue.put(request);\n                            } catch (InterruptedException e) {\n                                // Not much we can do about this.\n                            }\n                        }\n                    });\n                }\n\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n        }\n    }\n```\n\nrun方法内循环的过程中每次从mCacheQueue拿出一个request请求，对其添加已经访问过的marker，如果在期间request被取消了，最终会调用RequestQueue.finish()方法从mCurrentRequests中remove掉，一次循环完成；如果request没被取消则从缓存中获取数据，并且判断是否为空，如果为空则加入网络队列中重新请求，一次循环完成；如果不为空判断是否过期，过期了则加入网络队列中重新请求，一次循环完成；如果不过期判断是否需要更新缓存，需要则加入网络队列中重新请求，否则调用mDelivery.postResponse()完成数据传递的过程，执行图如下：\n\n{% asset_img CacheDispatcher_run.png CacheDispatcher.run() %}\n\nNetworkDispatcher也继承自Thread接口，run方法实现代码如下：\n\n```java\n@Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        while (true) {\n            long startTimeMs = SystemClock.elapsedRealtime();\n            Request<?> request;\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                //获取到请求结果\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                // Parse the response here on the worker thread.\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n              \t//是否缓存结果\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n                // Post the response back.\n                request.markDelivered();\n              \t//交付给mDelivery\n                mDelivery.postResponse(request, response);\n            } catch (VolleyError volleyError) {\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                parseAndDeliverNetworkError(request, volleyError);\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n```\n\n在NetworkDispatcher中主要通过Network接口performRequest()方法获得一个NetworkResponse,进而在转换成Delivery.postResponse()可接受的Request对象进行传递，其中会判断是否需要缓存该request以及相关error的捕获并且传递给Delivery.postError()。\n\n-----\n\n<h3>ResponseDelivery</h3>\n\n无论是CacheDispatcher还是NetworkDispatcher，最终的结果都是交付由ResponseDelivery接口实现类来进行实现:\n\n```java\npublic interface ResponseDelivery {\n    /**\n     * Parses a response from the network or cache and delivers it.\n     */\n    public void postResponse(Request<?> request, Response<?> response);\n\n    /**\n     * 处理从缓存和网络上获取的数据\n     */\n    public void postResponse(Request<?> request, Response<?> response, Runnable runnable);\n\n    /**\n     *处理错误的情况\n     */\n    public void postError(Request<?> request, VolleyError error);\n}\n```\n\n其具体实现类为ExecutorDelivery中，其代码如下：\n\n```java\n/**\n * 将请求结果传递给回调接口\n */\npublic class ExecutorDelivery implements ResponseDelivery {\n    /** Used for posting responses, typically to the main thread. */\n    private final Executor mResponsePoster;\n\n    /**\n     * 传入Handler的原因，目的是为了与主线程进行交互\n     * @param handler {@link Handler} to post responses on\n     */\n    public ExecutorDelivery(final Handler handler) {\n        // Make an Executor that just wraps the handler.\n        mResponsePoster = new Executor() {\n            @Override\n            public void execute(Runnable command) {\n                handler.post(command);\n            }\n        };\n    }\n\t...\n      \n    @Override\n    public void postResponse(Request<?> request, Response<?> response, Runnable runnable) {\n      \t//request传递标记\n        request.markDelivered();\n        request.addMarker(\"post-response\");\n        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));\n    }\n\n    @Override\n    public void postError(Request<?> request, VolleyError error) {\n        request.addMarker(\"post-error\");\n        Response<?> response = Response.error(error);\n        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));\n    }\n\n    /**\n     * A Runnable used for delivering network responses to a listener on the\n     * main thread.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    private class ResponseDeliveryRunnable implements Runnable {\n        private final Request mRequest;\n        private final Response mResponse;\n        private final Runnable mRunnable;\n\n        public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {\n            mRequest = request;\n            mResponse = response;\n            mRunnable = runnable;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public void run() {\n            // If this request has canceled, finish it and don't deliver.\n            if (mRequest.isCanceled()) {\n                mRequest.finish(\"canceled-at-delivery\");\n                return;\n            }\n\n            // 传递请求的结果，对应调用相应的回调接口，看mRequest对应实现类\n          \t//如果是StringRequest，则回调对应接口。\n            if (mResponse.isSuccess()) {\n                mRequest.deliverResponse(mResponse.result);\n            } else {\n                mRequest.deliverError(mResponse.error);\n            }\n\n            // If this is an intermediate response, add a marker, otherwise we're done\n            // and the request can be finished.\n            if (mResponse.intermediate) {\n                mRequest.addMarker(\"intermediate-response\");\n            } else {\n                mRequest.finish(\"done\");\n            }\n\n            // If we have been provided a post-delivery runnable, run it.\n            if (mRunnable != null) {\n                mRunnable.run();\n            }\n       }\n    }\n}\n```\n\n从Dispatcher那边获取到request和response最终传递到内部类ResponseDeliveryRunnable中进行处理，如果request是被finish的则丢弃传递，否则调用Request的对应的deliverResponse或者deliverError方法。这里要注意以下，该方法中传递了handler变量进来，这个变量是主线程的handler，也就保证了request的回调从工作线程切换回了主线程，其初始化代码如下：\n\n```java\npublic RequestQueue(Cache cache, Network network, int threadPoolSize) {\n        this(cache, network, threadPoolSize,\n                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n    }\n```\n\n\n\n-------\n\n<h4>Request</h4>\n\nRequest类是一个抽象方法，其子类实现主要有：StringRequest，JsonRequest，ImageRequest .etc ，为了简单查看后续步骤，我们拿StringRequest来查看：\n\n```java\n /**\n     * Delivers error message to the ErrorListener that the Request was\n     * initialized with.\n     *\n     * @param error Error details\n     */\n    public void deliverError(VolleyError error) {\n        if (mErrorListener != null) {\n            mErrorListener.onErrorResponse(error);\n        }\n    }\n  @Override\n    protected void deliverResponse(String response) {\n        if (mListener != null) {\n            mListener.onResponse(response);\n        }\n    }\n```\n\n到这里就执行到了最终的回调，所有的过程也就完成了。\n\n------\n\n<h4>个人总结</h4>\n\n个人认为volley的精髓在于面向接口编程，具有非常广阔的拓展性，开发者完全可以自主写一套自己的volley逻辑，充分解耦了各个模块，使用组合的方式进行编程，是我们学习设计代码的一个非常好的库吧。\n\n\n\n附上Volley过程图：\n{% asset_img volley_flowchart.png volley流程图 %}\n","slug":"volley源码学习","published":1,"updated":"2016-12-13T02:42:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwmz2w8p0008dgs6j9je3qtb","content":"<hr>\n<p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布的，现在连android系统中内部也是使用了Volley作为其网络的请求框架，谷歌出品，必属精品，所以有必要进行一次梳理其实现的总体过程，学习其设计框架的思路也是必要的(文章适合知道基本使用Volley的同学观看)。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h3>Volley</h3>\n\n<p>一般我们都会在app初始化的时候调用如下代码进行初始化Volley，下面就从该方法当做阅读入口进行逐一跟踪：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mRequestQueue =  Volley.newRequestQueue(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>在调用Volley.newRequestQueue(this)时，最终调用到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">    * Creates a default instance of the worker pool and calls &#123;<span class=\"doctag\">@link</span> RequestQueue#start()&#125; on it.</div><div class=\"line\">    * You may set a maximum size of the disk cache in bytes.</div><div class=\"line\">    *HttpStack是用来进行网络请求封装的类，传入null代表默认</div><div class=\"line\">    *maxDiskCacheBytes为最大磁盘缓存，传入-1使用默认大小</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestQueue <span class=\"title\">newRequestQueue</span><span class=\"params\">(Context context, HttpStack stack, <span class=\"keyword\">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">//构造缓存区域</span></div><div class=\"line\">       File cacheDir = <span class=\"keyword\">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\"></div><div class=\"line\">       String userAgent = <span class=\"string\">\"volley/0\"</span>;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           String packageName = context.getPackageName();</div><div class=\"line\">           PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class=\"number\">0</span>);</div><div class=\"line\">           userAgent = packageName + <span class=\"string\">\"/\"</span> + info.versionCode;</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NameNotFoundException e) &#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">\t<span class=\"comment\">//我们可以传入okttp来充当我们的httpStack</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (stack == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//使用Volley默认封装的stack，依靠android版本来决定使用不同的connection来进行网络请求</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">9</span>) &#123;</div><div class=\"line\">               stack = <span class=\"keyword\">new</span> HurlStack();</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               <span class=\"comment\">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></div><div class=\"line\">               <span class=\"comment\">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></div><div class=\"line\">               stack = <span class=\"keyword\">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       Network network = <span class=\"keyword\">new</span> BasicNetwork(stack);</div><div class=\"line\">       </div><div class=\"line\">       RequestQueue queue;</div><div class=\"line\">       <span class=\"keyword\">if</span> (maxDiskCacheBytes &lt;= -<span class=\"number\">1</span>)</div><div class=\"line\">       &#123;</div><div class=\"line\">       \t<span class=\"comment\">// No maximum size specified</span></div><div class=\"line\">       \tqueue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir), network);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">else</span></div><div class=\"line\">       &#123;</div><div class=\"line\">       \t<span class=\"comment\">// Disk cache size specified</span></div><div class=\"line\">       \tqueue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       queue.start();</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> queue;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在newRequestQueue\b方法中进行了相关必要参数的初始化的工作，其中包括:</p>\n<ul>\n<li>缓存区域的初始化</li>\n<li>HttpStack的初始化</li>\n<li>Network的初始化</li>\n<li>RequestQueue的初始化，最终调用其start()方法</li>\n</ul>\n<hr>\n<h4 id=\"Stack-详解\"><a href=\"#Stack-详解\" class=\"headerlink\" title=\"Stack 详解\"></a>Stack 详解</h4><p>在Volley中如果没有传递任何HttpStack则会使用了两种stack来进行不同android版本(SDK_INT &gt;= 9?HurlStack:HttpClientStack)的适配工作：HurlStack和HttpClientStack，两种stack都实现了HttpStack接口，接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HttpStack</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//请求处理方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class=\"line\">        <span class=\"keyword\">throws</span> IOException, AuthFailureError;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在接口中定义performRequest方法，在其子类中实现了对于http请求的封装的操作，以此来查看对应实现子类的performRequest方法。</p>\n<p>在HurlStack中关于performRequest(…)的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class=\"line\">            <span class=\"keyword\">throws</span> IOException, AuthFailureError &#123;</div><div class=\"line\">        String url = request.getUrl();</div><div class=\"line\">      <span class=\"comment\">//存放请求头</span></div><div class=\"line\">        HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">        map.putAll(request.getHeaders());</div><div class=\"line\">        map.putAll(additionalHeaders);</div><div class=\"line\">      <span class=\"comment\">//是否重写url</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mUrlRewriter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class=\"line\">            <span class=\"keyword\">if</span> (rewritten == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"URL blocked by rewriter: \"</span> + url);</div><div class=\"line\">            &#125;</div><div class=\"line\">            url = rewritten;</div><div class=\"line\">        &#125;</div><div class=\"line\">        URL parsedUrl = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\">      <span class=\"comment\">//使用后HttpURLConnection进行网络请求</span></div><div class=\"line\">        HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class=\"line\">        <span class=\"keyword\">for</span> (String headerName : map.keySet()) &#123;</div><div class=\"line\">            connection.addRequestProperty(headerName, map.get(headerName));</div><div class=\"line\">        &#125;</div><div class=\"line\">      <span class=\"comment\">//设置请求方法：GET ,POST, ect</span></div><div class=\"line\">        setConnectionParametersForRequest(connection, request);</div><div class=\"line\">        <span class=\"comment\">// Initialize HttpResponse with data from the HttpURLConnection.</span></div><div class=\"line\">        ProtocolVersion protocolVersion = <span class=\"keyword\">new</span> ProtocolVersion(<span class=\"string\">\"HTTP\"</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> responseCode = connection.getResponseCode();</div><div class=\"line\">        <span class=\"keyword\">if</span> (responseCode == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></div><div class=\"line\">            <span class=\"comment\">// Signal to the caller that something was wrong with the connection.</span></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Could not retrieve response code from HttpUrlConnection.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        StatusLine responseStatus = <span class=\"keyword\">new</span> BasicStatusLine(protocolVersion,</div><div class=\"line\">                connection.getResponseCode(), connection.getResponseMessage());</div><div class=\"line\">        BasicHttpResponse response = <span class=\"keyword\">new</span> BasicHttpResponse(responseStatus);</div><div class=\"line\">      \t<span class=\"comment\">//将返回的数据流写入response</span></div><div class=\"line\">        response.setEntity(entityFromConnection(connection));</div><div class=\"line\">      \t<span class=\"comment\">//获取返回的请求头</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (header.getKey() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                Header h = <span class=\"keyword\">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class=\"number\">0</span>));</div><div class=\"line\">                response.addHeader(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> response;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>HurlStack使用HttpURLConnection进行Http请求的过程，步骤是基本的网络请求的过程，设置请求头-&gt;包装Url-&gt;打开连接-&gt;设置请求方法-&gt;获取数据已经请求状态-&gt;将数据流存入HttpResponse，最终返回一个HttpResponse。</p>\n<p>HttpClientStack中关于performRequest(…)的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class=\"line\">            <span class=\"keyword\">throws</span> IOException, AuthFailureError &#123;</div><div class=\"line\">      \t<span class=\"comment\">//构造请求参数</span></div><div class=\"line\">        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</div><div class=\"line\">      \t<span class=\"comment\">//添加请求头</span></div><div class=\"line\">        addHeaders(httpRequest, additionalHeaders);</div><div class=\"line\">        addHeaders(httpRequest, request.getHeaders());</div><div class=\"line\">        onPrepareRequest(httpRequest);</div><div class=\"line\">        HttpParams httpParams = httpRequest.getParams();</div><div class=\"line\">        <span class=\"keyword\">int</span> timeoutMs = request.getTimeoutMs();</div><div class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></div><div class=\"line\">        <span class=\"comment\">// data collection and possibly different for wifi vs. 3G.</span></div><div class=\"line\">        HttpConnectionParams.setConnectionTimeout(httpParams, <span class=\"number\">5000</span>);</div><div class=\"line\">        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</div><div class=\"line\">        <span class=\"keyword\">return</span> mClient.execute(httpRequest);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>HttpClientStack\b执行的大体过程与HurlStack基本上一致，通过一系列操作最终调用AndroidHttpClient.execute(httpRequest)返回一个HttpResponse。</p>\n<p>HttpStack封装了http请求的过程，并且只管http请求，满足设计模式中单一责任的原则，并且向外提供接口HttpStack方便使用者定制自身的HttpStack类来进行请求的过程，如：可以用OkhttpClient来进行http请求的过程，这对于Volley的整个流程是不受影响。</p>\n<hr>\n<h4 id=\"Network\"><a href=\"#Network\" class=\"headerlink\" title=\"Network\"></a>Network</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Network</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Performs the specified request.</div><div class=\"line\">     * <span class=\"doctag\">@param</span> request Request to process</div><div class=\"line\">     * <span class=\"doctag\">@return</span> A &#123;<span class=\"doctag\">@link</span> NetworkResponse&#125; with data and caching metadata; will never be null</div><div class=\"line\">     * <span class=\"doctag\">@throws</span> VolleyError on errors</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NetworkResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request)</span> <span class=\"keyword\">throws</span> VolleyError</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Network接口中定义了performRequest用于接收一个具体的Request请求，其实现类是BasicNetwork，我们直接查看performRequest方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NetworkResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request)</span> <span class=\"keyword\">throws</span> VolleyError </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class=\"line\">      \t<span class=\"comment\">//死循环</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            HttpResponse httpResponse = <span class=\"keyword\">null</span>;</div><div class=\"line\">            <span class=\"keyword\">byte</span>[] responseContents = <span class=\"keyword\">null</span>;</div><div class=\"line\">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// Gather headers.</span></div><div class=\"line\">                Map&lt;String, String&gt; headers = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">                addCacheHeaders(headers, request.getCacheEntry());</div><div class=\"line\">              \t<span class=\"comment\">//通过HttpStack获得HttpResponse</span></div><div class=\"line\">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class=\"line\">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class=\"line\">                <span class=\"keyword\">int</span> statusCode = statusLine.getStatusCode();</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//返回的请求头</span></div><div class=\"line\">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class=\"line\">                <span class=\"comment\">//请求返回的状态码处理</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class=\"line\">                    Entry entry = request.getCacheEntry();</div><div class=\"line\">                    <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class=\"keyword\">null</span>,</div><div class=\"line\">                                responseHeaders, <span class=\"keyword\">true</span>,</div><div class=\"line\">                                SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    entry.responseHeaders.putAll(responseHeaders);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class=\"line\">                            entry.responseHeaders, <span class=\"keyword\">true</span>,</div><div class=\"line\">                            SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// Handle moved resources</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                \tString newUrl = responseHeaders.get(<span class=\"string\">\"Location\"</span>);</div><div class=\"line\">                \trequest.setRedirectUrl(newUrl);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Some responses such as 204s do not have content.  We must check.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (httpResponse.getEntity() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  <span class=\"comment\">// Add 0 byte response as a way of honestly representing a</span></div><div class=\"line\">                  <span class=\"comment\">// no-content request.</span></div><div class=\"line\">                  responseContents = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// if the request is slow, log it.</span></div><div class=\"line\">                <span class=\"keyword\">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class=\"line\">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode &lt; <span class=\"number\">200</span> || statusCode &gt; <span class=\"number\">299</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException();</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">            \t...</div><div class=\"line\">                <span class=\"keyword\">int</span> statusCode = <span class=\"number\">0</span>;</div><div class=\"line\">                NetworkResponse networkResponse = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (httpResponse != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoConnectionError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                \t\tstatusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                \tVolleyLog.e(<span class=\"string\">\"Request at %s has been redirected to %s\"</span>, request.getOriginUrl(), request.getUrl());</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                \tVolleyLog.e(<span class=\"string\">\"Unexpected response code %d for %s\"</span>, statusCode, request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (responseContents != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    networkResponse = <span class=\"keyword\">new</span> NetworkResponse(statusCode, responseContents,</div><div class=\"line\">                            responseHeaders, <span class=\"keyword\">false</span>, SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    ...</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在BasicNetwork中，我们可以看到其通过写了一个死循环来保证重复请求的操作直到报错或者返回结果，在其中他会调用mHttpStack.performRequest(request, headers)来获得一个HttpResponse，调用entityToBytes()将entity转换成一个字节数组，并且获取相关参数(header,statusCode .etc)去进一步的构造出一个NetworkResponse，并且返回：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">int</span> statusCode, <span class=\"keyword\">byte</span>[] data, Map&lt;String, String&gt; headers,</span></span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> notModified, <span class=\"keyword\">long</span> networkTimeMs) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.statusCode = statusCode;</div><div class=\"line\">    <span class=\"keyword\">this</span>.data = data;</div><div class=\"line\">    <span class=\"keyword\">this</span>.headers = headers;</div><div class=\"line\">    <span class=\"keyword\">this</span>.notModified = notModified;</div><div class=\"line\">    <span class=\"keyword\">this</span>.networkTimeMs = networkTimeMs;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">int</span> statusCode, <span class=\"keyword\">byte</span>[] data, Map&lt;String, String&gt; headers,</span></span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> notModified) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(statusCode, data, headers, notModified, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(HttpStatus.SC_OK, data, Collections.&lt;String, String&gt;emptyMap(), <span class=\"keyword\">false</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data, Map&lt;String, String&gt; headers)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(HttpStatus.SC_OK, data, headers, <span class=\"keyword\">false</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**Http状态码 */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> statusCode;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**网络请求返回的字节数据 */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] data;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**返回的请求头 */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Map&lt;String, String&gt; headers;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** 是否返回的304的状态码*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> notModified;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** 请求耗时. */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> networkTimeMs;</div></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"RequestQueue\"><a href=\"#RequestQueue\" class=\"headerlink\" title=\"RequestQueue\"></a>RequestQueue</h4><p>RequestQueue是一个请求队列，Volley将所有Request请求维护在此请求对列当中，内部有两个对应缓存和网络的请求阻塞队列来对Request进行维护，并且通过不同的Dispatcher(extends Thread)进行进一步的请求结果的处理，主要代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestQueue</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 所有请求完成后的回调 */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RequestFinishedListener</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"comment\">/** Called when a request has finished processing. */</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestFinished</span><span class=\"params\">(Request&lt;T&gt; request)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\">  \t<span class=\"comment\">//等待请求的Request，如果一个请求可以进行缓存，则后续的相同CacheKey的请求，将进入此等待队列。</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</div><div class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//当前请求以及未完成的请求</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class=\"keyword\">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">    <span class=\"comment\">/** 缓存请求阻塞队列 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</div><div class=\"line\">        <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">    <span class=\"comment\">/** 网络请求阻塞队列 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</div><div class=\"line\">        <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//网络请求线程池大小</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class=\"number\">4</span>;</div><div class=\"line\">\t...</div><div class=\"line\">      </div><div class=\"line\">  \t<span class=\"comment\">//网络dispatcher数组</span></div><div class=\"line\">    <span class=\"keyword\">private</span> NetworkDispatcher[] mDispatchers;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//缓存dispatcher</span></div><div class=\"line\">    <span class=\"keyword\">private</span> CacheDispatcher mCacheDispatcher;</div><div class=\"line\">\t<span class=\"comment\">//Request完成listener</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;RequestFinishedListener&gt; mFinishedListeners =</div><div class=\"line\">            <span class=\"keyword\">new</span> ArrayList&lt;RequestFinishedListener&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize,</span></span></div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">      \t<span class=\"comment\">//初始化网络Dispatcher</span></div><div class=\"line\">        mDispatchers = <span class=\"keyword\">new</span> NetworkDispatcher[threadPoolSize];</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，</div><div class=\"line\">     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stop();  <span class=\"comment\">// Make sure any currently running dispatchers are stopped.</span></div><div class=\"line\">        <span class=\"comment\">// 启动缓存请求队列</span></div><div class=\"line\">        mCacheDispatcher = <span class=\"keyword\">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Create network dispatchers (and corresponding threads) up to the pool size.</span></div><div class=\"line\">      \t<span class=\"comment\">//创造网络请求队列</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = <span class=\"keyword\">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 添加新的请求到请求对列当中</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Request&lt;T&gt; <span class=\"title\">add</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\">    &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Remove from the set of requests currently being processed.</span></div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.remove(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (mFinishedListeners) &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class=\"line\">            listener.onRequestFinished(request);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (request.shouldCache()) &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</div><div class=\"line\">                String cacheKey = request.getCacheKey();</div><div class=\"line\">                Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">                <span class=\"keyword\">if</span> (waitingRequests != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  \t....</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RequestQueue是Volley中最核心的类，掌管着所有request的请求和调度的过程，可以说是一个中转器的作用，我们从刚开始的start()方法看起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，</div><div class=\"line\">     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stop();  <span class=\"comment\">// Make sure any currently running dispatchers are stopped.</span></div><div class=\"line\">        <span class=\"comment\">// 启动缓存请求队列</span></div><div class=\"line\">        mCacheDispatcher = <span class=\"keyword\">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">      \t<span class=\"comment\">//创造网络请求队列</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = <span class=\"keyword\">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在调用start()时候，主要做了两件事情:</p>\n<ul>\n<li>调用stop()终止所有的dispatcher</li>\n<li>初始化所有的dispatcher，并且start(),dispatcher都是继承于Thread的类</li>\n</ul>\n<p>一般我们进行请求时候，都是使用的add(Request)方法来进行，所以接下来就查看一下这个方法的实现过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">    * 添加新的请求到请求对列当中</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Request&lt;T&gt; <span class=\"title\">add</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// 设置对应关联</span></div><div class=\"line\">       request.setRequestQueue(<span class=\"keyword\">this</span>);</div><div class=\"line\">     \t<span class=\"comment\">//添加到CurrentRequests中</span></div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">           mCurrentRequests.add(request);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// 按添加到请求队列的顺序请求数据</span></div><div class=\"line\">       request.setSequence(getSequenceNumber());</div><div class=\"line\">     \t<span class=\"comment\">//添加标志</span></div><div class=\"line\">       request.addMarker(<span class=\"string\">\"add-to-queue\"</span>);</div><div class=\"line\">     \t<span class=\"comment\">//当前request是否有缓存过，没有直接加入到网络请求队列中</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (!request.shouldCache()) &#123;</div><div class=\"line\">           mNetworkQueue.add(request);</div><div class=\"line\">           <span class=\"keyword\">return</span> request;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</div><div class=\"line\">         \t<span class=\"comment\">//得到缓存key(该key为medthod+url的单一key)</span></div><div class=\"line\">           String cacheKey = request.getCacheKey();</div><div class=\"line\">         \t<span class=\"comment\">//是否包含该缓存key</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\">               <span class=\"comment\">// There is already a request in flight. Queue up.</span></div><div class=\"line\">               Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">               <span class=\"keyword\">if</span> (stagedRequests == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   stagedRequests = <span class=\"keyword\">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">               &#125;</div><div class=\"line\">               stagedRequests.add(request);</div><div class=\"line\">               mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">               <span class=\"keyword\">if</span> (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                   VolleyLog.v(<span class=\"string\">\"Request for cacheKey=%s is in flight, putting on hold.\"</span>, cacheKey);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               <span class=\"comment\">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></div><div class=\"line\">               <span class=\"comment\">// flight.</span></div><div class=\"line\">               mWaitingRequests.put(cacheKey, <span class=\"keyword\">null</span>);</div><div class=\"line\">               mCacheQueue.add(request);</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> request;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在add()方法中主要的过程如图所示:</p>\n<img src=\"/2016/12/09/volley源码学习/reuqestqueue_add.png\" alt=\"reuqestqueue.add()\" title=\"reuqestqueue.add()\">\n<p>主要实现思路如下：</p>\n<ol>\n<li>添加到mCurrentRequests中，mCurrentRequests当前请求以及未完成的请求的set，所有通过add()进来的都会加入到\b此set的当中。</li>\n<li>通过request.shouldCache()来判断是否需要缓存request，如果不需要则直接加入到网络请求队列当中，return；如果需要缓存当前request则判断mWaitingRequests是否包含了该request的CacheKey的setKey，如果有，则加入相同的队列当中，则put到mWaitingRequests当中，如果没有包含了该request的CacheKey的setKey，置空与当前request的相同的queue(mWaitingRequests.put(cacheKey, null))，然后把request加入到缓存请求对列当中。</li>\n</ol>\n<p>add()方法中主要是为了找到request的存放地，是网络请求队列还是缓存请求队列，在判断是否加入到缓存请求队列时维护了一个mWaitingRequests集合来管理相同的请求，如果cacheKey相同，则不会加入到任何请对队列当中，然后加入到mWaitingRequests存有相同SetKey的SetValue中，挂起。</p>\n<hr>\n<h4>Dispatcher</h4>\n\n<p>返回RequestQueue.start()中，这里会将CacheDispatcher和NetworkDispatchers启动，两种Dispatcher共同继承于Thread来处理延时操作–网络请求和缓存请求的过程，这里只详细讲述CacheDispatcher的run()过程，NetworkDispatchers只以简述的形式讲述。</p>\n<p>CacheDispatcher在run方法中写死一个无限循环，可以类比成handler机制中的Looper.loop()的设计思路，不断的轮训缓存队列(mCacheQueue)，从中取出request将其传递给mDelivery来进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//设置线程优先级</span></div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 初始化缓存相关参数</span></div><div class=\"line\">        mCache.initialize();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//从mCacheQueue取缓存</span></div><div class=\"line\">                <span class=\"keyword\">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\">              \t<span class=\"comment\">//添加缓存过的标记</span></div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-queue-take\"</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 当前request是否取消了</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(<span class=\"string\">\"cache-discard-canceled\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Attempt to retrieve this item from cache.</span></div><div class=\"line\">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">                <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"cache-miss\"</span>);</div><div class=\"line\">                    <span class=\"comment\">// Cache miss; send off to the network dispatcher.</span></div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If it is completely expired, just send it to the network.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (entry.isExpired()) &#123;</div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"cache-hit-expired\"</span>);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// We have a cache hit; parse its data for delivery back to the request.</span></div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-hit\"</span>);</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                        <span class=\"keyword\">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-hit-parsed\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//缓存数据是否需要更新</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                    <span class=\"comment\">// Completely unexpired cache hit. Just deliver the response.</span></div><div class=\"line\">                    mDelivery.postResponse(request, response);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Soft-expired cache hit. We can deliver the cached response,</span></div><div class=\"line\">                    <span class=\"comment\">// but we need to also send the request to the network for</span></div><div class=\"line\">                    <span class=\"comment\">// refreshing.</span></div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"cache-hit-refresh-needed\"</span>);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"comment\">// Mark the response as intermediate.</span></div><div class=\"line\">                    response.intermediate = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"comment\">// Post the intermediate response back to the user and have</span></div><div class=\"line\">                    <span class=\"comment\">// the delivery then forward the request along to the network.</span></div><div class=\"line\">                    mDelivery.postResponse(request, response, <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                        <span class=\"meta\">@Override</span></div><div class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                                mNetworkQueue.put(request);</div><div class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                <span class=\"comment\">// Not much we can do about this.</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                <span class=\"comment\">// We may have been interrupted because it was time to quit.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (mQuit) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>run方法内循环的过程中每次从mCacheQueue拿出一个request请求，对其添加已经访问过的marker，如果在期间request被取消了，最终会调用RequestQueue.finish()方法从mCurrentRequests中remove掉，一次循环完成；如果request没被取消则从缓存中获取数据，并且判断是否为空，如果为空则加入网络队列中重新请求，一次循环完成；如果不为空判断是否过期，过期了则加入网络队列中重新请求，一次循环完成；如果不过期判断是否需要更新缓存，需要则加入网络队列中重新请求，否则调用mDelivery.postResponse()完成数据传递的过程，执行图如下：</p>\n<img src=\"/2016/12/09/volley源码学习/CacheDispatcher_run.png\" alt=\"CacheDispatcher.run()\" title=\"CacheDispatcher.run()\">\n<p>NetworkDispatcher也继承自Thread接口，run方法实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">            Request&lt;?&gt; request;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// Take a request from the queue.</span></div><div class=\"line\">                request = mQueue.take();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                <span class=\"comment\">// We may have been interrupted because it was time to quit.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (mQuit) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-queue-take\"</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If the request was cancelled already, do not perform the</span></div><div class=\"line\">                <span class=\"comment\">// network request.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(<span class=\"string\">\"network-discard-cancelled\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//获取到请求结果</span></div><div class=\"line\">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-http-complete\"</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If the server returned 304 AND we delivered a response already,</span></div><div class=\"line\">                <span class=\"comment\">// we're done -- don't deliver a second identical response.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                    request.finish(<span class=\"string\">\"not-modified\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Parse the response here on the worker thread.</span></div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-parse-complete\"</span>);</div><div class=\"line\">              \t<span class=\"comment\">//是否缓存结果</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"network-cache-written\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Post the response back.</span></div><div class=\"line\">                request.markDelivered();</div><div class=\"line\">              \t<span class=\"comment\">//交付给mDelivery</span></div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (VolleyError volleyError) &#123;</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                VolleyLog.e(e, <span class=\"string\">\"Unhandled exception %s\"</span>, e.toString());</div><div class=\"line\">                VolleyError volleyError = <span class=\"keyword\">new</span> VolleyError(e);</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                mDelivery.postError(request, volleyError);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在NetworkDispatcher中主要通过Network接口performRequest()方法获得一个NetworkResponse,进而在转换成Delivery.postResponse()可接受的Request对象进行传递，其中会判断是否需要缓存该request以及相关error的捕获并且传递给Delivery.postError()。</p>\n<hr>\n<h3>ResponseDelivery</h3>\n\n<p>无论是CacheDispatcher还是NetworkDispatcher，最终的结果都是交付由ResponseDelivery接口实现类来进行实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ResponseDelivery</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Parses a response from the network or cache and delivers it.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 处理从缓存和网络上获取的数据</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     *处理错误的情况</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postError</span><span class=\"params\">(Request&lt;?&gt; request, VolleyError error)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其具体实现类为ExecutorDelivery中，其代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 将请求结果传递给回调接口</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorDelivery</span> <span class=\"keyword\">implements</span> <span class=\"title\">ResponseDelivery</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/** Used for posting responses, typically to the main thread. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Executor mResponsePoster;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 传入Handler的原因，目的是为了与主线程进行交互</div><div class=\"line\">     * <span class=\"doctag\">@param</span> handler &#123;<span class=\"doctag\">@link</span> Handler&#125; to post responses on</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorDelivery</span><span class=\"params\">(<span class=\"keyword\">final</span> Handler handler)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Make an Executor that just wraps the handler.</span></div><div class=\"line\">        mResponsePoster = <span class=\"keyword\">new</span> Executor() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">                handler.post(command);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class=\"line\">      \t<span class=\"comment\">//request传递标记</span></div><div class=\"line\">        request.markDelivered();</div><div class=\"line\">        request.addMarker(<span class=\"string\">\"post-response\"</span>);</div><div class=\"line\">        mResponsePoster.execute(<span class=\"keyword\">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postError</span><span class=\"params\">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</div><div class=\"line\">        request.addMarker(<span class=\"string\">\"post-error\"</span>);</div><div class=\"line\">        Response&lt;?&gt; response = Response.error(error);</div><div class=\"line\">        mResponsePoster.execute(<span class=\"keyword\">new</span> ResponseDeliveryRunnable(request, response, <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * A Runnable used for delivering network responses to a listener on the</div><div class=\"line\">     * main thread.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"rawtypes\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseDeliveryRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Request mRequest;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Response mResponse;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mRunnable;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResponseDeliveryRunnable</span><span class=\"params\">(Request request, Response response, Runnable runnable)</span> </span>&#123;</div><div class=\"line\">            mRequest = request;</div><div class=\"line\">            mResponse = response;</div><div class=\"line\">            mRunnable = runnable;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// If this request has canceled, finish it and don't deliver.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mRequest.isCanceled()) &#123;</div><div class=\"line\">                mRequest.finish(<span class=\"string\">\"canceled-at-delivery\"</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 传递请求的结果，对应调用相应的回调接口，看mRequest对应实现类</span></div><div class=\"line\">          \t<span class=\"comment\">//如果是StringRequest，则回调对应接口。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mResponse.isSuccess()) &#123;</div><div class=\"line\">                mRequest.deliverResponse(mResponse.result);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                mRequest.deliverError(mResponse.error);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class=\"line\">            <span class=\"comment\">// and the request can be finished.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mResponse.intermediate) &#123;</div><div class=\"line\">                mRequest.addMarker(<span class=\"string\">\"intermediate-response\"</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                mRequest.finish(<span class=\"string\">\"done\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If we have been provided a post-delivery runnable, run it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                mRunnable.run();</div><div class=\"line\">            &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从Dispatcher那边获取到request和response最终传递到内部类ResponseDeliveryRunnable中进行处理，如果request是被finish的则丢弃传递，否则调用Request的对应的deliverResponse或者deliverError方法。这里要注意以下，该方法中传递了handler变量进来，这个变量是主线程的handler，也就保证了request的回调从工作线程切换回了主线程，其初始化代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(cache, network, threadPoolSize,</div><div class=\"line\">                <span class=\"keyword\">new</span> ExecutorDelivery(<span class=\"keyword\">new</span> Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h4>Request</h4>\n\n<p>Request类是一个抽象方法，其子类实现主要有：StringRequest，JsonRequest，ImageRequest .etc ，为了简单查看后续步骤，我们拿StringRequest来查看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">    * Delivers error message to the ErrorListener that the Request was</div><div class=\"line\">    * initialized with.</div><div class=\"line\">    *</div><div class=\"line\">    * <span class=\"doctag\">@param</span> error Error details</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverError</span><span class=\"params\">(VolleyError error)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mErrorListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           mErrorListener.onErrorResponse(error);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(String response)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           mListener.onResponse(response);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>到这里就执行到了最终的回调，所有的过程也就完成了。</p>\n<hr>\n<h4>个人总结</h4>\n\n<p>个人认为volley的精髓在于面向接口编程，具有非常广阔的拓展性，开发者完全可以自主写一套自己的volley逻辑，充分解耦了各个模块，使用组合的方式进行编程，是我们学习设计代码的一个非常好的库吧。</p>\n<p>附上Volley过程图：<br><img src=\"/2016/12/09/volley源码学习/volley_flowchart.png\" alt=\"volley流程图\" title=\"volley流程图\"></p>\n","excerpt":"<hr>\n<p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布的，现在连android系统中内部也是使用了Volley作为其网络的请求框架，谷歌出品，必属精品，所以有必要进行一次梳理其实现的总体过程，学习其设计框架的思路也是必要的(文章适合知道基本使用Volley的同学观看)。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h2><h3>Volley</h3>\n\n<p>一般我们都会在app初始化的时候调用如下代码进行初始化Volley，下面就从该方法当做阅读入口进行逐一跟踪：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mRequestQueue =  Volley.newRequestQueue(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>在调用Volley.newRequestQueue(this)时，最终调用到如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * Creates a default instance of the worker pool and calls &#123;<span class=\"doctag\">@link</span> RequestQueue#start()&#125; on it.</div><div class=\"line\">    * You may set a maximum size of the disk cache in bytes.</div><div class=\"line\">    *HttpStack是用来进行网络请求封装的类，传入null代表默认</div><div class=\"line\">    *maxDiskCacheBytes为最大磁盘缓存，传入-1使用默认大小</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestQueue <span class=\"title\">newRequestQueue</span><span class=\"params\">(Context context, HttpStack stack, <span class=\"keyword\">int</span> maxDiskCacheBytes)</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">//构造缓存区域</span></div><div class=\"line\">       File cacheDir = <span class=\"keyword\">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\"></div><div class=\"line\">       String userAgent = <span class=\"string\">\"volley/0\"</span>;</div><div class=\"line\">       <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">           String packageName = context.getPackageName();</div><div class=\"line\">           PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class=\"number\">0</span>);</div><div class=\"line\">           userAgent = packageName + <span class=\"string\">\"/\"</span> + info.versionCode;</div><div class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NameNotFoundException e) &#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">\t<span class=\"comment\">//我们可以传入okttp来充当我们的httpStack</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (stack == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         <span class=\"comment\">//使用Volley默认封装的stack，依靠android版本来决定使用不同的connection来进行网络请求</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">9</span>) &#123;</div><div class=\"line\">               stack = <span class=\"keyword\">new</span> HurlStack();</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               <span class=\"comment\">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></div><div class=\"line\">               <span class=\"comment\">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></div><div class=\"line\">               stack = <span class=\"keyword\">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       Network network = <span class=\"keyword\">new</span> BasicNetwork(stack);</div><div class=\"line\">       </div><div class=\"line\">       RequestQueue queue;</div><div class=\"line\">       <span class=\"keyword\">if</span> (maxDiskCacheBytes &lt;= -<span class=\"number\">1</span>)</div><div class=\"line\">       &#123;</div><div class=\"line\">       \t<span class=\"comment\">// No maximum size specified</span></div><div class=\"line\">       \tqueue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir), network);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">else</span></div><div class=\"line\">       &#123;</div><div class=\"line\">       \t<span class=\"comment\">// Disk cache size specified</span></div><div class=\"line\">       \tqueue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       queue.start();</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">return</span> queue;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在newRequestQueue\b方法中进行了相关必要参数的初始化的工作，其中包括:</p>\n<ul>\n<li>缓存区域的初始化</li>\n<li>HttpStack的初始化</li>\n<li>Network的初始化</li>\n<li>RequestQueue的初始化，最终调用其start()方法</li>\n</ul>\n<hr>\n<h4 id=\"Stack-详解\"><a href=\"#Stack-详解\" class=\"headerlink\" title=\"Stack 详解\"></a>Stack 详解</h4><p>在Volley中如果没有传递任何HttpStack则会使用了两种stack来进行不同android版本(SDK_INT &gt;= 9?HurlStack:HttpClientStack)的适配工作：HurlStack和HttpClientStack，两种stack都实现了HttpStack接口，接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HttpStack</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//请求处理方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></div><div class=\"line\">        <span class=\"keyword\">throws</span> IOException, AuthFailureError</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在接口中定义performRequest方法，在其子类中实现了对于http请求的封装的操作，以此来查看对应实现子类的performRequest方法。</p>\n<p>在HurlStack中关于performRequest(…)的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></div><div class=\"line\">            <span class=\"keyword\">throws</span> IOException, AuthFailureError </span>&#123;</div><div class=\"line\">        String url = request.getUrl();</div><div class=\"line\">      <span class=\"comment\">//存放请求头</span></div><div class=\"line\">        HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">        map.putAll(request.getHeaders());</div><div class=\"line\">        map.putAll(additionalHeaders);</div><div class=\"line\">      <span class=\"comment\">//是否重写url</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mUrlRewriter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class=\"line\">            <span class=\"keyword\">if</span> (rewritten == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"URL blocked by rewriter: \"</span> + url);</div><div class=\"line\">            &#125;</div><div class=\"line\">            url = rewritten;</div><div class=\"line\">        &#125;</div><div class=\"line\">        URL parsedUrl = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\">      <span class=\"comment\">//使用后HttpURLConnection进行网络请求</span></div><div class=\"line\">        HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class=\"line\">        <span class=\"keyword\">for</span> (String headerName : map.keySet()) &#123;</div><div class=\"line\">            connection.addRequestProperty(headerName, map.get(headerName));</div><div class=\"line\">        &#125;</div><div class=\"line\">      <span class=\"comment\">//设置请求方法：GET ,POST, ect</span></div><div class=\"line\">        setConnectionParametersForRequest(connection, request);</div><div class=\"line\">        <span class=\"comment\">// Initialize HttpResponse with data from the HttpURLConnection.</span></div><div class=\"line\">        ProtocolVersion protocolVersion = <span class=\"keyword\">new</span> ProtocolVersion(<span class=\"string\">\"HTTP\"</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> responseCode = connection.getResponseCode();</div><div class=\"line\">        <span class=\"keyword\">if</span> (responseCode == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></div><div class=\"line\">            <span class=\"comment\">// Signal to the caller that something was wrong with the connection.</span></div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Could not retrieve response code from HttpUrlConnection.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        StatusLine responseStatus = <span class=\"keyword\">new</span> BasicStatusLine(protocolVersion,</div><div class=\"line\">                connection.getResponseCode(), connection.getResponseMessage());</div><div class=\"line\">        BasicHttpResponse response = <span class=\"keyword\">new</span> BasicHttpResponse(responseStatus);</div><div class=\"line\">      \t<span class=\"comment\">//将返回的数据流写入response</span></div><div class=\"line\">        response.setEntity(entityFromConnection(connection));</div><div class=\"line\">      \t<span class=\"comment\">//获取返回的请求头</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (header.getKey() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                Header h = <span class=\"keyword\">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class=\"number\">0</span>));</div><div class=\"line\">                response.addHeader(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> response;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>HurlStack使用HttpURLConnection进行Http请求的过程，步骤是基本的网络请求的过程，设置请求头-&gt;包装Url-&gt;打开连接-&gt;设置请求方法-&gt;获取数据已经请求状态-&gt;将数据流存入HttpResponse，最终返回一个HttpResponse。</p>\n<p>HttpClientStack中关于performRequest(…)的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></div><div class=\"line\">            <span class=\"keyword\">throws</span> IOException, AuthFailureError </span>&#123;</div><div class=\"line\">      \t<span class=\"comment\">//构造请求参数</span></div><div class=\"line\">        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</div><div class=\"line\">      \t<span class=\"comment\">//添加请求头</span></div><div class=\"line\">        addHeaders(httpRequest, additionalHeaders);</div><div class=\"line\">        addHeaders(httpRequest, request.getHeaders());</div><div class=\"line\">        onPrepareRequest(httpRequest);</div><div class=\"line\">        HttpParams httpParams = httpRequest.getParams();</div><div class=\"line\">        <span class=\"keyword\">int</span> timeoutMs = request.getTimeoutMs();</div><div class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></div><div class=\"line\">        <span class=\"comment\">// data collection and possibly different for wifi vs. 3G.</span></div><div class=\"line\">        HttpConnectionParams.setConnectionTimeout(httpParams, <span class=\"number\">5000</span>);</div><div class=\"line\">        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</div><div class=\"line\">        <span class=\"keyword\">return</span> mClient.execute(httpRequest);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>HttpClientStack\b执行的大体过程与HurlStack基本上一致，通过一系列操作最终调用AndroidHttpClient.execute(httpRequest)返回一个HttpResponse。</p>\n<p>HttpStack封装了http请求的过程，并且只管http请求，满足设计模式中单一责任的原则，并且向外提供接口HttpStack方便使用者定制自身的HttpStack类来进行请求的过程，如：可以用OkhttpClient来进行http请求的过程，这对于Volley的整个流程是不受影响。</p>\n<hr>\n<h4 id=\"Network\"><a href=\"#Network\" class=\"headerlink\" title=\"Network\"></a>Network</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Network</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Performs the specified request.</div><div class=\"line\">     * <span class=\"doctag\">@param</span> request Request to process</div><div class=\"line\">     * <span class=\"doctag\">@return</span> A &#123;<span class=\"doctag\">@link</span> NetworkResponse&#125; with data and caching metadata; will never be null</div><div class=\"line\">     * <span class=\"doctag\">@throws</span> VolleyError on errors</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NetworkResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request)</span> <span class=\"keyword\">throws</span> VolleyError</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Network接口中定义了performRequest用于接收一个具体的Request请求，其实现类是BasicNetwork，我们直接查看performRequest方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NetworkResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request)</span> <span class=\"keyword\">throws</span> VolleyError </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> requestStart = SystemClock.elapsedRealtime();</div><div class=\"line\">      \t<span class=\"comment\">//死循环</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            HttpResponse httpResponse = <span class=\"keyword\">null</span>;</div><div class=\"line\">            <span class=\"keyword\">byte</span>[] responseContents = <span class=\"keyword\">null</span>;</div><div class=\"line\">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// Gather headers.</span></div><div class=\"line\">                Map&lt;String, String&gt; headers = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">                addCacheHeaders(headers, request.getCacheEntry());</div><div class=\"line\">              \t<span class=\"comment\">//通过HttpStack获得HttpResponse</span></div><div class=\"line\">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class=\"line\">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class=\"line\">                <span class=\"keyword\">int</span> statusCode = statusLine.getStatusCode();</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//返回的请求头</span></div><div class=\"line\">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class=\"line\">                <span class=\"comment\">//请求返回的状态码处理</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class=\"line\">                    Entry entry = request.getCacheEntry();</div><div class=\"line\">                    <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class=\"keyword\">null</span>,</div><div class=\"line\">                                responseHeaders, <span class=\"keyword\">true</span>,</div><div class=\"line\">                                SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    entry.responseHeaders.putAll(responseHeaders);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class=\"line\">                            entry.responseHeaders, <span class=\"keyword\">true</span>,</div><div class=\"line\">                            SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// Handle moved resources</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                \tString newUrl = responseHeaders.get(<span class=\"string\">\"Location\"</span>);</div><div class=\"line\">                \trequest.setRedirectUrl(newUrl);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Some responses such as 204s do not have content.  We must check.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (httpResponse.getEntity() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  <span class=\"comment\">// Add 0 byte response as a way of honestly representing a</span></div><div class=\"line\">                  <span class=\"comment\">// no-content request.</span></div><div class=\"line\">                  responseContents = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// if the request is slow, log it.</span></div><div class=\"line\">                <span class=\"keyword\">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class=\"line\">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode &lt; <span class=\"number\">200</span> || statusCode &gt; <span class=\"number\">299</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException();</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class=\"keyword\">false</span>,</div><div class=\"line\">                        SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">            \t...</div><div class=\"line\">                <span class=\"keyword\">int</span> statusCode = <span class=\"number\">0</span>;</div><div class=\"line\">                NetworkResponse networkResponse = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (httpResponse != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoConnectionError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                \t\tstatusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                \tVolleyLog.e(<span class=\"string\">\"Request at %s has been redirected to %s\"</span>, request.getOriginUrl(), request.getUrl());</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                \tVolleyLog.e(<span class=\"string\">\"Unexpected response code %d for %s\"</span>, statusCode, request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (responseContents != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    networkResponse = <span class=\"keyword\">new</span> NetworkResponse(statusCode, responseContents,</div><div class=\"line\">                            responseHeaders, <span class=\"keyword\">false</span>, SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    ...</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在BasicNetwork中，我们可以看到其通过写了一个死循环来保证重复请求的操作直到报错或者返回结果，在其中他会调用mHttpStack.performRequest(request, headers)来获得一个HttpResponse，调用entityToBytes()将entity转换成一个字节数组，并且获取相关参数(header,statusCode .etc)去进一步的构造出一个NetworkResponse，并且返回：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">int</span> statusCode, <span class=\"keyword\">byte</span>[] data, Map&lt;String, String&gt; headers,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> notModified, <span class=\"keyword\">long</span> networkTimeMs)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.statusCode = statusCode;</div><div class=\"line\">    <span class=\"keyword\">this</span>.data = data;</div><div class=\"line\">    <span class=\"keyword\">this</span>.headers = headers;</div><div class=\"line\">    <span class=\"keyword\">this</span>.notModified = notModified;</div><div class=\"line\">    <span class=\"keyword\">this</span>.networkTimeMs = networkTimeMs;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">int</span> statusCode, <span class=\"keyword\">byte</span>[] data, Map&lt;String, String&gt; headers,</div><div class=\"line\">        <span class=\"keyword\">boolean</span> notModified)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(statusCode, data, headers, notModified, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(HttpStatus.SC_OK, data, Collections.&lt;String, String&gt;emptyMap(), <span class=\"keyword\">false</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkResponse</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data, Map&lt;String, String&gt; headers)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(HttpStatus.SC_OK, data, headers, <span class=\"keyword\">false</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**Http状态码 */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> statusCode;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**网络请求返回的字节数据 */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] data;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**返回的请求头 */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Map&lt;String, String&gt; headers;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** 是否返回的304的状态码*/</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> notModified;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** 请求耗时. */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> networkTimeMs;</div></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"RequestQueue\"><a href=\"#RequestQueue\" class=\"headerlink\" title=\"RequestQueue\"></a>RequestQueue</h4><p>RequestQueue是一个请求队列，Volley将所有Request请求维护在此请求对列当中，内部有两个对应缓存和网络的请求阻塞队列来对Request进行维护，并且通过不同的Dispatcher(extends Thread)进行进一步的请求结果的处理，主要代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestQueue</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** 所有请求完成后的回调 */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RequestFinishedListener</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"comment\">/** Called when a request has finished processing. */</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestFinished</span><span class=\"params\">(Request&lt;T&gt; request)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\">  \t<span class=\"comment\">//等待请求的Request，如果一个请求可以进行缓存，则后续的相同CacheKey的请求，将进入此等待队列。</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</div><div class=\"line\">            <span class=\"keyword\">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//当前请求以及未完成的请求</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class=\"keyword\">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">    <span class=\"comment\">/** 缓存请求阻塞队列 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</div><div class=\"line\">        <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">    <span class=\"comment\">/** 网络请求阻塞队列 */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</div><div class=\"line\">        <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">  \t<span class=\"comment\">//网络请求线程池大小</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class=\"number\">4</span>;</div><div class=\"line\">\t...</div><div class=\"line\">      </div><div class=\"line\">  \t<span class=\"comment\">//网络dispatcher数组</span></div><div class=\"line\">    <span class=\"keyword\">private</span> NetworkDispatcher[] mDispatchers;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//缓存dispatcher</span></div><div class=\"line\">    <span class=\"keyword\">private</span> CacheDispatcher mCacheDispatcher;</div><div class=\"line\">\t<span class=\"comment\">//Request完成listener</span></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;RequestFinishedListener&gt; mFinishedListeners =</div><div class=\"line\">            <span class=\"keyword\">new</span> ArrayList&lt;RequestFinishedListener&gt;();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize,</div><div class=\"line\">            ResponseDelivery delivery)</span> </span>&#123;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">      \t<span class=\"comment\">//初始化网络Dispatcher</span></div><div class=\"line\">        mDispatchers = <span class=\"keyword\">new</span> NetworkDispatcher[threadPoolSize];</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，</div><div class=\"line\">     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stop();  <span class=\"comment\">// Make sure any currently running dispatchers are stopped.</span></div><div class=\"line\">        <span class=\"comment\">// 启动缓存请求队列</span></div><div class=\"line\">        mCacheDispatcher = <span class=\"keyword\">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Create network dispatchers (and corresponding threads) up to the pool size.</span></div><div class=\"line\">      \t<span class=\"comment\">//创造网络请求队列</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = <span class=\"keyword\">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 添加新的请求到请求对列当中</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Request&lt;T&gt; <span class=\"title\">add</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\">    &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Remove from the set of requests currently being processed.</span></div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.remove(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (mFinishedListeners) &#123;</div><div class=\"line\">          <span class=\"keyword\">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class=\"line\">            listener.onRequestFinished(request);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (request.shouldCache()) &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</div><div class=\"line\">                String cacheKey = request.getCacheKey();</div><div class=\"line\">                Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">                <span class=\"keyword\">if</span> (waitingRequests != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  \t....</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RequestQueue是Volley中最核心的类，掌管着所有request的请求和调度的过程，可以说是一个中转器的作用，我们从刚开始的start()方法看起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     * start()方法中启动了缓存dispatcher跟网络请求dispatcher，用来处理数据请求，</div><div class=\"line\">     * 如果缓存中有数据，则直接在缓存中获取数据，缓存中没有数据则从网络中获取数据。</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stop();  <span class=\"comment\">// Make sure any currently running dispatchers are stopped.</span></div><div class=\"line\">        <span class=\"comment\">// 启动缓存请求队列</span></div><div class=\"line\">        mCacheDispatcher = <span class=\"keyword\">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">      \t<span class=\"comment\">//创造网络请求队列</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = <span class=\"keyword\">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在调用start()时候，主要做了两件事情:</p>\n<ul>\n<li>调用stop()终止所有的dispatcher</li>\n<li>初始化所有的dispatcher，并且start(),dispatcher都是继承于Thread的类</li>\n</ul>\n<p>一般我们进行请求时候，都是使用的add(Request)方法来进行，所以接下来就查看一下这个方法的实现过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * 添加新的请求到请求对列当中</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Request&lt;T&gt; <span class=\"title\">add</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// 设置对应关联</span></div><div class=\"line\">       request.setRequestQueue(<span class=\"keyword\">this</span>);</div><div class=\"line\">     \t<span class=\"comment\">//添加到CurrentRequests中</span></div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">           mCurrentRequests.add(request);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"comment\">// 按添加到请求队列的顺序请求数据</span></div><div class=\"line\">       request.setSequence(getSequenceNumber());</div><div class=\"line\">     \t<span class=\"comment\">//添加标志</span></div><div class=\"line\">       request.addMarker(<span class=\"string\">\"add-to-queue\"</span>);</div><div class=\"line\">     \t<span class=\"comment\">//当前request是否有缓存过，没有直接加入到网络请求队列中</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (!request.shouldCache()) &#123;</div><div class=\"line\">           mNetworkQueue.add(request);</div><div class=\"line\">           <span class=\"keyword\">return</span> request;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</div><div class=\"line\">         \t<span class=\"comment\">//得到缓存key(该key为medthod+url的单一key)</span></div><div class=\"line\">           String cacheKey = request.getCacheKey();</div><div class=\"line\">         \t<span class=\"comment\">//是否包含该缓存key</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\">               <span class=\"comment\">// There is already a request in flight. Queue up.</span></div><div class=\"line\">               Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">               <span class=\"keyword\">if</span> (stagedRequests == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                   stagedRequests = <span class=\"keyword\">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">               &#125;</div><div class=\"line\">               stagedRequests.add(request);</div><div class=\"line\">               mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">               <span class=\"keyword\">if</span> (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                   VolleyLog.v(<span class=\"string\">\"Request for cacheKey=%s is in flight, putting on hold.\"</span>, cacheKey);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               <span class=\"comment\">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></div><div class=\"line\">               <span class=\"comment\">// flight.</span></div><div class=\"line\">               mWaitingRequests.put(cacheKey, <span class=\"keyword\">null</span>);</div><div class=\"line\">               mCacheQueue.add(request);</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"keyword\">return</span> request;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在add()方法中主要的过程如图所示:</p>\n<img src=\"/2016/12/09/volley源码学习/reuqestqueue_add.png\" alt=\"reuqestqueue.add()\" title=\"reuqestqueue.add()\">\n<p>主要实现思路如下：</p>\n<ol>\n<li>添加到mCurrentRequests中，mCurrentRequests当前请求以及未完成的请求的set，所有通过add()进来的都会加入到\b此set的当中。</li>\n<li>通过request.shouldCache()来判断是否需要缓存request，如果不需要则直接加入到网络请求队列当中，return；如果需要缓存当前request则判断mWaitingRequests是否包含了该request的CacheKey的setKey，如果有，则加入相同的队列当中，则put到mWaitingRequests当中，如果没有包含了该request的CacheKey的setKey，置空与当前request的相同的queue(mWaitingRequests.put(cacheKey, null))，然后把request加入到缓存请求对列当中。</li>\n</ol>\n<p>add()方法中主要是为了找到request的存放地，是网络请求队列还是缓存请求队列，在判断是否加入到缓存请求队列时维护了一个mWaitingRequests集合来管理相同的请求，如果cacheKey相同，则不会加入到任何请对队列当中，然后加入到mWaitingRequests存有相同SetKey的SetValue中，挂起。</p>\n<hr>\n<h4>Dispatcher</h4>\n\n<p>返回RequestQueue.start()中，这里会将CacheDispatcher和NetworkDispatchers启动，两种Dispatcher共同继承于Thread来处理延时操作–网络请求和缓存请求的过程，这里只详细讲述CacheDispatcher的run()过程，NetworkDispatchers只以简述的形式讲述。</p>\n<p>CacheDispatcher在run方法中写死一个无限循环，可以类比成handler机制中的Looper.loop()的设计思路，不断的轮训缓存队列(mCacheQueue)，从中取出request将其传递给mDelivery来进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//设置线程优先级</span></div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 初始化缓存相关参数</span></div><div class=\"line\">        mCache.initialize();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//从mCacheQueue取缓存</span></div><div class=\"line\">                <span class=\"keyword\">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\">              \t<span class=\"comment\">//添加缓存过的标记</span></div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-queue-take\"</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 当前request是否取消了</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(<span class=\"string\">\"cache-discard-canceled\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Attempt to retrieve this item from cache.</span></div><div class=\"line\">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">                <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"cache-miss\"</span>);</div><div class=\"line\">                    <span class=\"comment\">// Cache miss; send off to the network dispatcher.</span></div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If it is completely expired, just send it to the network.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (entry.isExpired()) &#123;</div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"cache-hit-expired\"</span>);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// We have a cache hit; parse its data for delivery back to the request.</span></div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-hit\"</span>);</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                        <span class=\"keyword\">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-hit-parsed\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//缓存数据是否需要更新</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                    <span class=\"comment\">// Completely unexpired cache hit. Just deliver the response.</span></div><div class=\"line\">                    mDelivery.postResponse(request, response);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"comment\">// Soft-expired cache hit. We can deliver the cached response,</span></div><div class=\"line\">                    <span class=\"comment\">// but we need to also send the request to the network for</span></div><div class=\"line\">                    <span class=\"comment\">// refreshing.</span></div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"cache-hit-refresh-needed\"</span>);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"comment\">// Mark the response as intermediate.</span></div><div class=\"line\">                    response.intermediate = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">                    <span class=\"comment\">// Post the intermediate response back to the user and have</span></div><div class=\"line\">                    <span class=\"comment\">// the delivery then forward the request along to the network.</span></div><div class=\"line\">                    mDelivery.postResponse(request, response, <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                        <span class=\"meta\">@Override</span></div><div class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                                mNetworkQueue.put(request);</div><div class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                                <span class=\"comment\">// Not much we can do about this.</span></div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                <span class=\"comment\">// We may have been interrupted because it was time to quit.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (mQuit) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>run方法内循环的过程中每次从mCacheQueue拿出一个request请求，对其添加已经访问过的marker，如果在期间request被取消了，最终会调用RequestQueue.finish()方法从mCurrentRequests中remove掉，一次循环完成；如果request没被取消则从缓存中获取数据，并且判断是否为空，如果为空则加入网络队列中重新请求，一次循环完成；如果不为空判断是否过期，过期了则加入网络队列中重新请求，一次循环完成；如果不过期判断是否需要更新缓存，需要则加入网络队列中重新请求，否则调用mDelivery.postResponse()完成数据传递的过程，执行图如下：</p>\n<img src=\"/2016/12/09/volley源码学习/CacheDispatcher_run.png\" alt=\"CacheDispatcher.run()\" title=\"CacheDispatcher.run()\">\n<p>NetworkDispatcher也继承自Thread接口，run方法实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">            Request&lt;?&gt; request;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// Take a request from the queue.</span></div><div class=\"line\">                request = mQueue.take();</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                <span class=\"comment\">// We may have been interrupted because it was time to quit.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (mQuit) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-queue-take\"</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If the request was cancelled already, do not perform the</span></div><div class=\"line\">                <span class=\"comment\">// network request.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(<span class=\"string\">\"network-discard-cancelled\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//获取到请求结果</span></div><div class=\"line\">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-http-complete\"</span>);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If the server returned 304 AND we delivered a response already,</span></div><div class=\"line\">                <span class=\"comment\">// we're done -- don't deliver a second identical response.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                    request.finish(<span class=\"string\">\"not-modified\"</span>);</div><div class=\"line\">                    <span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Parse the response here on the worker thread.</span></div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-parse-complete\"</span>);</div><div class=\"line\">              \t<span class=\"comment\">//是否缓存结果</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                    request.addMarker(<span class=\"string\">\"network-cache-written\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Post the response back.</span></div><div class=\"line\">                request.markDelivered();</div><div class=\"line\">              \t<span class=\"comment\">//交付给mDelivery</span></div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (VolleyError volleyError) &#123;</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                VolleyLog.e(e, <span class=\"string\">\"Unhandled exception %s\"</span>, e.toString());</div><div class=\"line\">                VolleyError volleyError = <span class=\"keyword\">new</span> VolleyError(e);</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                mDelivery.postError(request, volleyError);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在NetworkDispatcher中主要通过Network接口performRequest()方法获得一个NetworkResponse,进而在转换成Delivery.postResponse()可接受的Request对象进行传递，其中会判断是否需要缓存该request以及相关error的捕获并且传递给Delivery.postError()。</p>\n<hr>\n<h3>ResponseDelivery</h3>\n\n<p>无论是CacheDispatcher还是NetworkDispatcher，最终的结果都是交付由ResponseDelivery接口实现类来进行实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ResponseDelivery</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Parses a response from the network or cache and delivers it.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 处理从缓存和网络上获取的数据</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     *处理错误的情况</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postError</span><span class=\"params\">(Request&lt;?&gt; request, VolleyError error)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其具体实现类为ExecutorDelivery中，其代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 将请求结果传递给回调接口</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorDelivery</span> <span class=\"keyword\">implements</span> <span class=\"title\">ResponseDelivery</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/** Used for posting responses, typically to the main thread. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Executor mResponsePoster;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 传入Handler的原因，目的是为了与主线程进行交互</div><div class=\"line\">     * <span class=\"doctag\">@param</span> handler &#123;<span class=\"doctag\">@link</span> Handler&#125; to post responses on</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorDelivery</span><span class=\"params\">(<span class=\"keyword\">final</span> Handler handler)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Make an Executor that just wraps the handler.</span></div><div class=\"line\">        mResponsePoster = <span class=\"keyword\">new</span> Executor() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">                handler.post(command);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t...</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class=\"line\">      \t<span class=\"comment\">//request传递标记</span></div><div class=\"line\">        request.markDelivered();</div><div class=\"line\">        request.addMarker(<span class=\"string\">\"post-response\"</span>);</div><div class=\"line\">        mResponsePoster.execute(<span class=\"keyword\">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postError</span><span class=\"params\">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</div><div class=\"line\">        request.addMarker(<span class=\"string\">\"post-error\"</span>);</div><div class=\"line\">        Response&lt;?&gt; response = Response.error(error);</div><div class=\"line\">        mResponsePoster.execute(<span class=\"keyword\">new</span> ResponseDeliveryRunnable(request, response, <span class=\"keyword\">null</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * A Runnable used for delivering network responses to a listener on the</div><div class=\"line\">     * main thread.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"rawtypes\"</span>)</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResponseDeliveryRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Request mRequest;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Response mResponse;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mRunnable;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResponseDeliveryRunnable</span><span class=\"params\">(Request request, Response response, Runnable runnable)</span> </span>&#123;</div><div class=\"line\">            mRequest = request;</div><div class=\"line\">            mResponse = response;</div><div class=\"line\">            mRunnable = runnable;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// If this request has canceled, finish it and don't deliver.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mRequest.isCanceled()) &#123;</div><div class=\"line\">                mRequest.finish(<span class=\"string\">\"canceled-at-delivery\"</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 传递请求的结果，对应调用相应的回调接口，看mRequest对应实现类</span></div><div class=\"line\">          \t<span class=\"comment\">//如果是StringRequest，则回调对应接口。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mResponse.isSuccess()) &#123;</div><div class=\"line\">                mRequest.deliverResponse(mResponse.result);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                mRequest.deliverError(mResponse.error);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class=\"line\">            <span class=\"comment\">// and the request can be finished.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mResponse.intermediate) &#123;</div><div class=\"line\">                mRequest.addMarker(<span class=\"string\">\"intermediate-response\"</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                mRequest.finish(<span class=\"string\">\"done\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If we have been provided a post-delivery runnable, run it.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                mRunnable.run();</div><div class=\"line\">            &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从Dispatcher那边获取到request和response最终传递到内部类ResponseDeliveryRunnable中进行处理，如果request是被finish的则丢弃传递，否则调用Request的对应的deliverResponse或者deliverError方法。这里要注意以下，该方法中传递了handler变量进来，这个变量是主线程的handler，也就保证了request的回调从工作线程切换回了主线程，其初始化代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(cache, network, threadPoolSize,</div><div class=\"line\">                <span class=\"keyword\">new</span> ExecutorDelivery(<span class=\"keyword\">new</span> Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h4>Request</h4>\n\n<p>Request类是一个抽象方法，其子类实现主要有：StringRequest，JsonRequest，ImageRequest .etc ，为了简单查看后续步骤，我们拿StringRequest来查看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">    * Delivers error message to the ErrorListener that the Request was</div><div class=\"line\">    * initialized with.</div><div class=\"line\">    *</div><div class=\"line\">    * <span class=\"doctag\">@param</span> error Error details</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverError</span><span class=\"params\">(VolleyError error)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mErrorListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           mErrorListener.onErrorResponse(error);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(String response)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (mListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           mListener.onResponse(response);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>到这里就执行到了最终的回调，所有的过程也就完成了。</p>\n<hr>\n<h4>个人总结</h4>\n\n<p>个人认为volley的精髓在于面向接口编程，具有非常广阔的拓展性，开发者完全可以自主写一套自己的volley逻辑，充分解耦了各个模块，使用组合的方式进行编程，是我们学习设计代码的一个非常好的库吧。</p>\n<p>附上Volley过程图：<br><img src=\"/2016/12/09/volley源码学习/volley_flowchart.png\" alt=\"volley流程图\" title=\"volley流程图\"></p>"}],"PostAsset":[{"_id":"source/_posts/android-View的探索-一-setContentView-过程研究/setcontentView.png","post":"ciwmz2w8g0002dgs6kotec2fu","slug":"setcontentView.png","modified":1,"renderable":1},{"_id":"source/_posts/android-View的探索-二-View的形成过程/one.png","post":"ciwmz2w8m0006dgs606ng7g76","slug":"one.png","modified":1,"renderable":1},{"_id":"source/_posts/android-View的探索-二-View的形成过程/two.jpg","post":"ciwmz2w8m0006dgs606ng7g76","slug":"two.jpg","modified":1,"renderable":1},{"_id":"source/_posts/volley源码学习/CacheDispatcher_run.png","post":"ciwmz2w8p0008dgs6j9je3qtb","slug":"CacheDispatcher_run.png","modified":1,"renderable":1},{"_id":"source/_posts/volley源码学习/reuqestqueue_add.png","post":"ciwmz2w8p0008dgs6j9je3qtb","slug":"reuqestqueue_add.png","modified":1,"renderable":1},{"_id":"source/_posts/volley源码学习/volley_flowchart.png","post":"ciwmz2w8p0008dgs6j9je3qtb","slug":"volley_flowchart.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ciwmz2w8p0008dgs6j9je3qtb","category_id":"ciwmz2w8j0004dgs6iuukjbt9","_id":"ciwmz2w8t000cdgs6btzbd9sx"},{"post_id":"ciwmz2w8c0000dgs6ngfy5lvp","category_id":"ciwmz2w8j0004dgs6iuukjbt9","_id":"ciwmz2w8v000gdgs69n8vv06v"},{"post_id":"ciwmz2w8g0002dgs6kotec2fu","category_id":"ciwmz2w8r0009dgs6fd3fmt99","_id":"ciwmz2w8v000idgs6skucn79e"},{"post_id":"ciwmz2w8m0006dgs606ng7g76","category_id":"ciwmz2w8r0009dgs6fd3fmt99","_id":"ciwmz2w8v000kdgs6xi527uza"}],"PostTag":[{"post_id":"ciwmz2w8p0008dgs6j9je3qtb","tag_id":"ciwmz2w8m0005dgs62lt8fj97","_id":"ciwmz2w8t000bdgs6wqjmcxsb"},{"post_id":"ciwmz2w8c0000dgs6ngfy5lvp","tag_id":"ciwmz2w8m0005dgs62lt8fj97","_id":"ciwmz2w8u000ddgs6hxz1a84v"},{"post_id":"ciwmz2w8g0002dgs6kotec2fu","tag_id":"ciwmz2w8m0005dgs62lt8fj97","_id":"ciwmz2w8v000hdgs64i8rkbg6"},{"post_id":"ciwmz2w8m0006dgs606ng7g76","tag_id":"ciwmz2w8m0005dgs62lt8fj97","_id":"ciwmz2w8v000jdgs65as0hhil"}],"Tag":[{"name":"android","_id":"ciwmz2w8m0005dgs62lt8fj97"}]}}